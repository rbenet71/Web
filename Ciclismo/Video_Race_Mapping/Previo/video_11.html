<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VIDEO MAPPING</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    :root{
      /* panel splitter sizes (in px) */
      --splitter: 8px;
      --colLeft: 50%;
      --rowTop: 50%;
    }

    html, body{
      margin:0; padding:0; height:100%;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:#fff;
    }

    /* ============================================================
       TOP LAYOUT
       ============================================================ */
    #layout{
      height:100%;
      display:grid;
      grid-template-rows: auto 1fr;
      min-height:0;
    }

    #controls{
      padding:8px 10px;
      background:#f2f2f2;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      border-bottom:1px solid #ddd;
    }

    #logo{
      height:34px;
      width:auto;
      display:block;
      margin-right:4px;
    }

    label{
      background:#fff;
      padding:6px 10px;
      border-radius:8px;
      border:1px solid #ccc;
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      white-space:nowrap;
    }

    select, button{
      padding:6px 10px;
      border-radius:8px;
      border:1px solid #ccc;
      background:#fff;
      cursor:pointer;
      font-size:14px;
    }

    #status{
      margin-left:auto;
      font-size:.9em;
      opacity:.85;
      white-space:nowrap;
    }

    /* ============================================================
       MAIN 2x2 GRID with splitters
       ============================================================ */
    #main{
      height:100%;
      min-height:0;
      display:grid;

      /* 3 cols: left / splitter / right */
      grid-template-columns: var(--colLeft) var(--splitter) 1fr;

      /* 3 rows: top / splitter / bottom */
      grid-template-rows: var(--rowTop) var(--splitter) 1fr;

      grid-template-areas:
        "video vSplit map"
        "hSplit hSplit hSplit"
        "table . profile";
    }

    .panel{
      position:relative;
      min-height:0;
      overflow:hidden;
      border:1px solid #ddd;
      background:#fff;
    }

    #videoWrap{ grid-area: video; background:#000; border-right:none; border-bottom:none; }
    #mapPanel { grid-area: map;   border-left:none; border-bottom:none; }
    #tablePanel{ grid-area: table; border-right:none; border-top:none; }
    #profilePanel{ grid-area: profile; border-left:none; border-top:none; background:#fafafa; }

    /* splitters */
    .splitter{
      background: rgba(0,0,0,0.08);
      border-radius: 6px;
      user-select: none;
      touch-action: none;
      z-index: 50;
    }
    .splitter:hover{ background: rgba(0,0,0,0.16); }
    #vSplit{ grid-area: vSplit; cursor: col-resize; }
    #hSplit{ grid-area: hSplit; cursor: row-resize; }

    /* ============================================================
       VIDEO
       ============================================================ */
    video{
      width:100%;
      height:100%;
      background:#000;
      object-fit:contain;
      display:block;
      outline:none;
    }

    #hud{
      position:absolute;
      left:10px;
      top:10px;
      background: rgba(0,0,0,0.55);
      color:#fff;
      padding:6px 8px;
      border-radius:10px;
      font-size:12px;
      pointer-events:none;
      z-index:20;
      max-width: calc(100% - 20px);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    #videoTools{
      position:absolute;
      right:10px;
      top:10px;
      display:flex;
      gap:8px;
      z-index:25;
    }

    .iconBtn{
      width:36px;
      height:36px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.45);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
    }
    .iconBtn:hover{ background: rgba(0,0,0,0.65); }

    /* pictos blancos */
    .iconBtn img{
      width:20px;
      height:20px;
      opacity:0.98;
      pointer-events:none;
      filter:none;
    }
    .iconBtn svg{
      width:20px; height:20px;
      display:block;
      fill:#fff;
    }

    /* ============================================================
       MAP
       ============================================================ */
    #map{ width:100%; height:100%; }

    /* KMZ icon markers: keep crisp */
    .kmz-icon{
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }

    /* ============================================================
       TABLE (Rut√≥metro)
       ============================================================ */
    #tableWrap{
      display:flex;
      flex-direction:column;
      height:100%;
      min-height:0;
      background:#fff;
    }

    #tableHeader{
      padding:6px 8px;
      background:#fafafa;
      border-bottom:1px solid #ddd;
      display:flex;
      align-items:center;
      gap:10px;
      font-size:13px;
      white-space:nowrap;
    }

    #tableHeader .pill{
      padding:2px 8px;
      border:1px solid #ddd;
      border-radius:999px;
      background:#fff;
      opacity:.9;
    }

    #rutometreTableContainer{
      overflow:auto;      /* vertical + horizontal scrollbars */
      flex:1;
      min-height:0;
    }

    table{
      border-collapse:collapse;
      font-size:12px;
    }

    /* fixed layout => we can resize columns reliably */
    #rutometreTable{
      table-layout: fixed;
      width: max(100%, 1100px);
    }

    thead th{
      position:sticky;
      top:0;
      z-index:5;
      background:#f3f3f3;
      border-bottom:1px solid #ddd;
      padding:6px 10px 6px 6px;
      text-align:left;
      white-space:nowrap;
      vertical-align:bottom;
    }

    tbody td{
      border-bottom:1px solid #eee;
      padding:6px 6px;
      vertical-align:top;
    }

    tbody tr:hover{ background:#f8fbff; cursor:pointer; }
    tbody tr.active{ background:#ffe8cc; }
    tbody tr.active td{ border-bottom-color:#ffd19a; }

    .td-num{
      text-align:right;
      font-variant-numeric: tabular-nums;
      white-space:nowrap;
    }
    .td-small{ white-space:nowrap; opacity:.9; }

    /* Describe_Es: wrap after ~50 chars (approx using ch units) */
    .col-desc{
      white-space: normal !important;
      max-width: 50ch;
      overflow-wrap: break-word;
      word-break: break-word;
    }

    /* column resizer handle */
    .col-resizer{
      position:absolute;
      top:0; right:0;
      width:8px; height:100%;
      cursor: col-resize;
      user-select:none;
      touch-action:none;
    }
    .col-resizer:hover{ background: rgba(0,0,0,0.10); }

    /* ============================================================
       PROFILE
       ============================================================ */
    #profileWrap{
      padding:8px;
      background:#fafafa;
      box-sizing:border-box;
      height:100%;
      width:100%;
    }

    #elevCanvas{
      width:100%;
      height:100%;
      display:block;
      background:#fff;
      border:1px solid #ddd;
      border-radius:10px;
    }

    /* ============================================================
       MOBILE
       ============================================================ */
    @media (max-width: 980px){
      #main{
        grid-template-columns: 1fr;
        grid-template-rows: 30vh var(--splitter) 30vh var(--splitter) 30vh var(--splitter) 30vh;
        grid-template-areas:
          "video"
          "hSplit"
          "map"
          "hSplit"
          "table"
          "hSplit"
          "profile";
      }
      #vSplit{ display:none; }
      #hSplit{ cursor: row-resize; }
    }
  </style>
</head>

<body>
  <div id="layout">

    <!-- CONTROLS -->
    <div id="controls">
      <img id="logo" src="logo.jpg" alt="logo" />

      <label title="Selecciona carpeta (mp4 + gpx + kmz/kml + xlsx)">
        üìÅ Carpeta
        <input id="dirInput" type="file" webkitdirectory hidden>
      </label>

      <label title="Selecciona el MP4 dentro de la carpeta">
        üé¨ MP4
        <select id="mp4Select">
          <option value="">(elige carpeta primero)</option>
        </select>
      </label>

      <label title="Capa base del mapa">
        üó∫Ô∏è Mapa
        <select id="baseMapSelect">
          <option value="osm">OSM (tiles)</option>
          <option value="google_road">Google (XYZ road)</option>
          <option value="icgc_topo_wms">ICGC Topo (WMS)</option>
          <option value="ign_baseorto_wms">IGN Base Orto (WMS)</option>
          <option value="icc_orto_wms">ICC Orto (WMS)</option>
          <option value="gencat_viari_wms">Gencat Viari (WMS)</option>
        </select>
      </label>

      <button id="fitBtn" title="Ajustar mapa al track">Ajustar</button>

      <label title="Velocidad de reproducci√≥n">
        ‚è© Velocidad
        <select id="rateSelect">
          <option value="1">1x</option>
          <option value="2">2x</option>
          <option value="8">8x</option>
          <option value="16">16x</option>
        </select>
      </label>

      <label title="Importar KML o KMZ manualmente (opcional)">
        üß© KML/KMZ
        <input id="kmlKmzInput" type="file" accept=".kml,.kmz" hidden>
      </label>

      <label title="Cargar rut√≥metro desde Excel manualmente (opcional)">
        üìÑ Excel
        <input id="excelInput" type="file" accept=".xlsx" hidden>
      </label>

      <span id="status">Esperando carpeta‚Ä¶</span>
    </div>

    <!-- MAIN 2x2 -->
    <div id="main">
      <!-- ZONA 1: VIDEO -->
      <div class="panel" id="videoWrap">
        <div id="hud">‚Äî</div>

        <div id="videoTools">
          <div class="iconBtn" id="btnGoogleMaps" title="Abrir en Google Maps">
            <img alt="Google Maps"
                 src='data:image/svg+xml;utf8,
                 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                   <path fill="white" d="M12 2C8.1 2 5 5.1 5 9c0 5.2 7 13 7 13s7-7.8 7-13c0-3.9-3.1-7-7-7zm0 9.5c-1.4 0-2.5-1.1-2.5-2.5S10.6 6.5 12 6.5s2.5 1.1 2.5 2.5S13.4 11.5 12 11.5z"/>
                 </svg>'/>
          </div>

          <div class="iconBtn" id="btnStreetView" title="Abrir en Street View">
            <img alt="Street View"
                 src='data:image/svg+xml;utf8,
                 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                   <path fill="white" d="M12 2a4 4 0 100 8 4 4 0 000-8zm0 9c-4.4 0-8 2.2-8 5v4h16v-4c0-2.8-3.6-5-8-5z"/>
                 </svg>'/>
          </div>

          <div class="iconBtn" id="btnSnapshot" title="Capturar frame (PNG)">
            <img alt="Snapshot"
                 src='data:image/svg+xml;utf8,
                 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                   <path fill="white" d="M9 2l1.8 2H15l1.8-2H20c1.1 0 2 .9 2 2v16c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h5zm3 6a6 6 0 100 12 6 6 0 000-12zm0 2a4 4 0 110 8 4 4 0 010-8z"/>
                 </svg>'/>
          </div>
        </div>

        <video id="video" controls playsinline></video>
      </div>

      <!-- V splitter -->
      <div id="vSplit" class="splitter"></div>

      <!-- ZONA 2: MAPA -->
      <div class="panel" id="mapPanel">
        <div id="map"></div>
      </div>

      <!-- H splitter -->
      <div id="hSplit" class="splitter"></div>

      <!-- ZONA 3: TABLA -->
      <div class="panel" id="tablePanel">
        <div id="tableWrap">
          <div id="tableHeader">
            <span class="pill" id="rutometreInfo">Rut√≥metro: ‚Äî</span>
            <span class="pill" id="rutometreSyncInfo">Sync: ‚Äî</span>
          </div>

          <div id="rutometreTableContainer">
            <table id="rutometreTable">
              <thead>
                <tr id="rutometreHeaderRow">
                  <th class="col-desc">Describe_Es</th>
                  <th class="td-num">Km_Etapa</th>
                  <th class="td-num">Km_Faltan</th>
                  <th class="td-small">Horario_1</th>
                  <th class="td-small">Horario_2</th>
                  <th class="td-small">Horario_3</th>
                  <th class="td-small">codi picto</th>
                  <th class="td-small">Coordenada_X</th>
                  <th class="td-small">Coordenada_Y</th>
                  <th class="td-small">Coordenades_GPS</th>
                </tr>
              </thead>
              <tbody id="rutometreTbody">
                <tr><td colspan="10" style="padding:10px;opacity:.7;">Carga el Excel para ver el rut√≥metro‚Ä¶</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- ZONA 4: PERFIL -->
      <div class="panel" id="profilePanel">
        <div id="profileWrap">
          <canvas id="elevCanvas"></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- LIBS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://unpkg.com/@tmcw/togeojson@5.8.1/dist/togeojson.umd.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <script>
  /* ============================================================
     UI / HELPERS
     ============================================================ */
  const dirInput      = document.getElementById("dirInput");
  const mp4Select     = document.getElementById("mp4Select");
  const baseMapSelect = document.getElementById("baseMapSelect");
  const fitBtn        = document.getElementById("fitBtn");
  const rateSelect    = document.getElementById("rateSelect");
  const statusEl      = document.getElementById("status");

  const kmlKmzInput   = document.getElementById("kmlKmzInput");
  const excelInput    = document.getElementById("excelInput");

  const video         = document.getElementById("video");
  const hud           = document.getElementById("hud");

  const elevCanvas    = document.getElementById("elevCanvas");
  const ctx           = elevCanvas.getContext("2d");

  const btnGoogleMaps = document.getElementById("btnGoogleMaps");
  const btnStreetView = document.getElementById("btnStreetView");
  const btnSnapshot   = document.getElementById("btnSnapshot");

  const rutometreTbody     = document.getElementById("rutometreTbody");
  const rutometreInfo      = document.getElementById("rutometreInfo");
  const rutometreSyncInfo  = document.getElementById("rutometreSyncInfo");

  const mainEl        = document.getElementById("main");
  const vSplit        = document.getElementById("vSplit");
  const hSplit        = document.getElementById("hSplit");

  function setStatus(msg){ statusEl.textContent = msg; }
  function basenameNoExt(name){ return name.replace(/\\.[^.]+$/, ""); }
  function pad2(n){ return String(n).padStart(2,"0"); }
  function fmtTimeHMS(seconds){
    if (!Number.isFinite(seconds)) return "‚Äî";
    seconds = Math.max(0, seconds);
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);
    return `${h}:${pad2(m)}:${pad2(s)}`;
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function escapeHtml(str){
    return String(str)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;");
  }
  function readFileAsText(file){
    return new Promise((resolve, reject) => {
      const r = new FileReader();
      r.onload = () => resolve(String(r.result));
      r.onerror = reject;
      r.readAsText(file);
    });
  }
  function haversineMeters(a, b){
    const R = 6371000;
    const toRad = x => x * Math.PI / 180;
    const dLat = toRad(b.lat - a.lat);
    const dLon = toRad(b.lon - a.lon);
    const s1 = Math.sin(dLat/2), s2 = Math.sin(dLon/2);
    const q = s1*s1 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2;
    return 2 * R * Math.asin(Math.sqrt(q));
  }
  function computeBearingDeg(a, b){
    const toRad = x => x * Math.PI/180;
    const toDeg = x => x * 180/Math.PI;
    const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
    const dLon = toRad(b.lon - a.lon);
    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
    let brng = toDeg(Math.atan2(y, x));
    return (brng + 360) % 360;
  }

  /* ============================================================
     MAP
     ============================================================ */
  const map = L.map("map", { zoomControl:true }).setView([0,0], 2);

  const baseLayers = {
    osm: L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "¬© OpenStreetMap",
      maxZoom: 19
    }),
    google_road: L.tileLayer("https://mt1.google.com/vt/lyrs=r&x={x}&y={y}&z={z}", {
      attribution: "¬© Google",
      maxZoom: 20
    }),
    icgc_topo_wms: L.tileLayer.wms("https://geoserveis.icgc.cat/icc_mapesmultibase/utm/wms/service", {
      layers: "topo",
      format: "image/png",
      transparent: false,
      attribution: "ICGC (WMS)"
    }),
    ign_baseorto_wms: L.tileLayer.wms("http://www.ign.es/wms-inspire/ign-base", {
      layers: "IGNBaseOrto",
      format: "image/png",
      transparent: false,
      attribution: "IGN (WMS)"
    }),
    icc_orto_wms: L.tileLayer.wms("http://mapcache.icc.cat/map/bases/service", {
      layers: "orto",
      format: "image/png",
      transparent: false,
      attribution: "ICC (WMS)"
    }),
    gencat_viari_wms: L.tileLayer.wms("https://sig.gencat.cat/ows/XARXES_TRANSPORT/wms", {
      layers: "XT_VIARI_PK_CARRETERES",
      format: "image/png",
      transparent: true,
      attribution: "Gencat (WMS)"
    })
  };

  let currentBaseLayer = baseLayers.osm;
  currentBaseLayer.addTo(map);

  baseMapSelect.addEventListener("change", () => {
    const key = baseMapSelect.value;
    if (!baseLayers[key]) return;
    if (currentBaseLayer) map.removeLayer(currentBaseLayer);
    currentBaseLayer = baseLayers[key];
    currentBaseLayer.addTo(map);
    setStatus(`Mapa base: ${baseMapSelect.options[baseMapSelect.selectedIndex].text}`);
  });

  /* ============================================================
     FILE INDEX (folder) + AUTOLOAD per video basename
     ============================================================ */
  const mp4Files = new Map();   // filename -> File
  const gpxFiles = new Map();   // base -> File
  const kmzFiles = new Map();   // base -> File (.kmz)
  const kmlFiles = new Map();   // base -> File (.kml)
  const xlsxFiles= new Map();   // base -> File (.xlsx)

  /* ============================================================
     TRACK / VIDEO STATE
     ============================================================ */
  let overlayLayer = null;

  let points = [];
  let firstAbsTime = null;
  let hasEle = false;

  let polyline = null;
  let marker = null;

  let lastCenterTs = 0;
  let lastSeekTs = 0;
  let lastBearingDeg = 0;

  /* ============================================================
     RUT√ìMETRO STATE
     ============================================================ */
  let rutometreRows = [];
  let rutometreWpts = [];  // [{rowIndex, tOffset, dist, Describe_Es}]
  let activeRutometreIndex = -1;

  /* ============================================================
     GPX
     ============================================================ */
  function parseGpx(xmlText){
    const xml = new DOMParser().parseFromString(xmlText, "application/xml");
    const trkpts = [...xml.querySelectorAll("trkpt")];

    const out = trkpts.map(pt => {
      const lat = +pt.getAttribute("lat");
      const lon = +pt.getAttribute("lon");
      const tNode = pt.querySelector("time");
      if (!tNode || !tNode.textContent) return null;

      const eleNode = pt.querySelector("ele");
      const ele = eleNode ? +eleNode.textContent : null;

      const t = new Date(tNode.textContent);
      return { lat, lon, ele, tAbs: t.getTime(), tOffset:0, dist:0 };
    }).filter(Boolean);

    out.sort((a,b)=>a.tAbs - b.tAbs);
    return out;
  }

  function computeOffsetsAndDist(){
    if (!points.length) return;

    for (const p of points){
      p.tOffset = (p.tAbs - firstAbsTime) / 1000;
    }

    let d=0;
    points[0].dist = 0;
    for (let i=1;i<points.length;i++){
      d += haversineMeters(points[i-1], points[i]);
      points[i].dist = d;
    }

    hasEle = points.some(p => Number.isFinite(p.ele));
  }

  function clearTrack(){
    if (polyline) map.removeLayer(polyline);
    if (marker) map.removeLayer(marker);
    polyline = null;
    marker = null;

    points = [];
    firstAbsTime = null;
    hasEle = false;

    drawElevationProfile(null);
    hud.textContent = "‚Äî";
    lastBearingDeg = 0;

    rutometreWpts = [];
    activeRutometreIndex = -1;
    updateRutometreActive(-1);
  }

  function clearOverlay(){
    if (overlayLayer){
      map.removeLayer(overlayLayer);
      overlayLayer = null;
    }
  }

  function clearRutometre(){
    rutometreRows = [];
    rutometreWpts = [];
    activeRutometreIndex = -1;
    rutometreInfo.textContent = "Rut√≥metro: ‚Äî";
    rutometreSyncInfo.textContent = "Sync: ‚Äî";
    rutometreTbody.innerHTML = `<tr><td colspan="10" style="padding:10px;opacity:.7;">Carga el Excel para ver el rut√≥metro‚Ä¶</td></tr>`;
  }

  function drawTrack(){
    computeOffsetsAndDist();

    polyline = L.polyline(points.map(p => [p.lat, p.lon]), { color:"blue", weight:4 }).addTo(map);

    marker = L.circleMarker([points[0].lat, points[0].lon], {
      radius:7,
      color:"#b00000",
      weight:2,
      fillColor:"#ff0000",
      fillOpacity:1.0
    }).addTo(map);

    map.fitBounds(polyline.getBounds(), { padding:[20,20] });

    polyline.on("click", (e) => {
      const p = nearestPoint(e.latlng.lat, e.latlng.lng);
      if (p) syncToPoint(p, { seekVideo:true, centerMap:true, redrawProfile:true });
    });

    enableMarkerDragScrub();

    computeRutometreSync();
    drawElevationProfile(0);
  }

  function nearestPoint(lat, lon){
    let best=null, bestDist=Infinity;
    for (const p of points){
      const d = (p.lat-lat)**2 + (p.lon-lon)**2;
      if (d < bestDist){ bestDist=d; best=p; }
    }
    return best;
  }

  function pointAtTime(t){
    let p = points[0];
    for (const q of points){
      if (q.tOffset <= t) p = q;
      else break;
    }
    return p;
  }

  function findPointIndex(p){
    for (let i=0;i<points.length;i++) if (points[i] === p) return i;
    return -1;
  }

  async function safeSeek(targetTime){
    if (!Number.isFinite(targetTime)) return;

    const now = performance.now();
    if (now - lastSeekTs < 35) return;
    lastSeekTs = now;

    targetTime = Math.max(0, targetTime);
    if (Math.abs(video.currentTime - targetTime) < 0.04) return;

    video.currentTime = targetTime;

    if (typeof video.requestVideoFrameCallback === "function"){
      await new Promise(resolve => video.requestVideoFrameCallback(() => resolve()));
    } else {
      await new Promise(resolve => {
        const onSeeked = () => { video.removeEventListener("seeked", onSeeked); resolve(); };
        video.addEventListener("seeked", onSeeked, { once:true });
      });
    }

    drawElevationProfile(video.currentTime);

    if (rutometreWpts.length){
      updateRutometreActive(rutometreActiveIndexForTime(video.currentTime));
    }
  }

  function syncToPoint(p, opts){
    const { seekVideo=false, centerMap=true, redrawProfile=true } = (opts||{});
    if (!p || !marker) return;

    marker.setLatLng([p.lat, p.lon]);

    const idx = findPointIndex(p);
    if (idx !== -1){
      const a = points[Math.max(0, idx-1)];
      const b = points[Math.min(points.length-1, idx+1)];
      if (a && b && a !== b) lastBearingDeg = computeBearingDeg(a, b);
    }

    if (centerMap){
      const now = performance.now();
      if (now - lastCenterTs > 60){
        lastCenterTs = now;
        map.panTo([p.lat, p.lon], { animate:false });
      }
    }

    if (seekVideo) safeSeek(p.tOffset);
    if (redrawProfile) drawElevationProfile(video.currentTime);

    const distKm = (p.dist||0)/1000;
    hud.textContent = `t=${fmtTimeHMS(p.tOffset)} ¬∑ ${distKm.toFixed(2)} km ¬∑ lat=${p.lat.toFixed(5)} lon=${p.lon.toFixed(5)}`;

    if (rutometreWpts.length){
      updateRutometreActive(rutometreActiveIndexForTime(video.currentTime));
    }
  }

  /* ============================================================
     VIDEO EVENTS
     ============================================================ */
  rateSelect.addEventListener("change", () => {
    const r = +rateSelect.value;
    video.playbackRate = r;
    setStatus(`Velocidad: ${r}x`);
  });
  video.playbackRate = +rateSelect.value;

  video.addEventListener("loadedmetadata", () => {
    video.playbackRate = +rateSelect.value;
  });

  video.addEventListener("timeupdate", () => {
    if (!points.length) return;
    const p = pointAtTime(video.currentTime);
    syncToPoint(p, { seekVideo:false, centerMap:true, redrawProfile:true });
  });

  video.addEventListener("wheel", (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    const step = (delta > 0) ? +1 : -1;
    video.currentTime = Math.max(0, video.currentTime + step);
  }, { passive:false });

  video.addEventListener("click", () => video.focus());
  document.addEventListener("keydown", (e) => {
    if (document.activeElement !== video) return;
    if (e.key === "ArrowLeft"){
      e.preventDefault();
      video.currentTime = Math.max(0, video.currentTime - 1);
    } else if (e.key === "ArrowRight"){
      e.preventDefault();
      video.currentTime = Math.max(0, video.currentTime + 1);
    }
  });

  /* ============================================================
     MAP EVENTS
     ============================================================ */
  map.on("click", (e) => {
    if (!points.length) return;
    const p = nearestPoint(e.latlng.lat, e.latlng.lng);
    if (p) syncToPoint(p, { seekVideo:true, centerMap:true, redrawProfile:true });
  });

  fitBtn.addEventListener("click", () => {
    if (polyline) map.fitBounds(polyline.getBounds(), { padding:[20,20] });
  });

  function enableMarkerDragScrub(){
    let dragging = false;

    function distPx(a,b){
      const pa = map.latLngToContainerPoint(a);
      const pb = map.latLngToContainerPoint(b);
      return pa.distanceTo(pb);
    }

    map.on("mousedown", (e) => {
      if (!marker) return;
      if (distPx(marker.getLatLng(), e.latlng) < 18){
        dragging = true;
        map.dragging.disable();
      }
    });

    map.on("mousemove", (e) => {
      if (!dragging) return;
      const p = nearestPoint(e.latlng.lat, e.latlng.lng);
      if (p) syncToPoint(p, { seekVideo:true, centerMap:true, redrawProfile:true });
    });

    function stop(){
      if (!dragging) return;
      dragging = false;
      map.dragging.enable();
    }
    map.on("mouseup", stop);
    map.on("mouseleave", stop);
  }

  /* ============================================================
     PROFILE (canvas)
     ============================================================ */
  function resizeCanvasToCSS(){
    const r = elevCanvas.getBoundingClientRect();
    const w = Math.max(1, Math.round(r.width));
    const h = Math.max(1, Math.round(r.height));
    if (elevCanvas.width !== w) elevCanvas.width = w;
    if (elevCanvas.height !== h) elevCanvas.height = h;
  }

  window.addEventListener("resize", () => {
    resizeCanvasToCSS();
    drawElevationProfile(video.currentTime);
  });

  function drawElevationProfile(cursorTime){
    resizeCanvasToCSS();
    const W = elevCanvas.width, H = elevCanvas.height;
    ctx.clearRect(0,0,W,H);

    ctx.font = "14px system-ui";
    ctx.fillStyle = "#000";

    if (!points.length){
      ctx.fillText("Carga un MP4 con su GPX (misma base)", 10, 24);
      return;
    }
    if (!hasEle){
      ctx.fillText("GPX sin <ele> (sin perfil)", 10, 24);
      return;
    }

    const pad = 14;
    const distMax = points[points.length-1].dist || 1;
    const eles = points.filter(p=>Number.isFinite(p.ele)).map(p=>p.ele);
    const eMin = Math.min(...eles), eMax = Math.max(...eles);
    const eSpan = (eMax-eMin) || 1;

    const linePts = [];
    for (const p of points){
      if (!Number.isFinite(p.ele)) continue;
      const x = pad + (p.dist/distMax)*(W - pad*2);
      const y = pad + (1 - (p.ele-eMin)/eSpan)*(H - pad*2);
      linePts.push({x,y,p});
    }
    if (linePts.length < 2) return;

    ctx.beginPath();
    ctx.moveTo(linePts[0].x, linePts[0].y);
    for (let i=1;i<linePts.length;i++) ctx.lineTo(linePts[i].x, linePts[i].y);
    ctx.lineTo(linePts[linePts.length-1].x, H - pad);
    ctx.lineTo(linePts[0].x, H - pad);
    ctx.closePath();

    const grad = ctx.createLinearGradient(0, pad, 0, H - pad);
    grad.addColorStop(0.0, "rgba(255, 0, 0, 0.45)");
    grad.addColorStop(1.0, "rgba(255, 140, 0, 0.25)");
    ctx.fillStyle = grad;
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(linePts[0].x, linePts[0].y);
    for (let i=1;i<linePts.length;i++) ctx.lineTo(linePts[i].x, linePts[i].y);
    ctx.strokeStyle = "rgba(120,0,0,0.9)";
    ctx.lineWidth = 2;
    ctx.stroke();

    if (Number.isFinite(cursorTime)){
      const p = pointAtTime(cursorTime);
      const x = pad + (p.dist/distMax)*(W - pad*2);

      ctx.strokeStyle = "rgba(0,0,0,0.75)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(x, pad);
      ctx.lineTo(x, H - pad);
      ctx.stroke();

      const distKmCur = (p.dist||0)/1000;
      const eleTxt = Number.isFinite(p.ele) ? `${Math.round(p.ele)} m` : "‚Äî";
      const label = `${fmtTimeHMS(p.tOffset)} ¬∑ ${distKmCur.toFixed(2)} km ¬∑ ${eleTxt}`;

      ctx.font = "12px system-ui";
      const tw = ctx.measureText(label).width;
      const bx = clamp(x - tw/2 - 6, pad, W - pad - tw - 12);
      const by = pad;

      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.fillRect(bx, by, tw + 12, 18);
      ctx.fillStyle = "#fff";
      ctx.fillText(label, bx + 6, by + 13);
    }
  }

  function nearestPointByDist(targetDist){
    let best = points[0], bestD = Infinity;
    for (const p of points){
      const d = Math.abs(p.dist - targetDist);
      if (d < bestD){ bestD = d; best = p; }
    }
    return best;
  }
  let draggingProfile = false;
  function scrubFromCanvas(clientX){
    if (!points.length) return;
    const rect = elevCanvas.getBoundingClientRect();
    const xCss = clientX - rect.left;

    const pad = 14;
    const W = elevCanvas.width;
    const usable = Math.max(1, W - pad*2);

    const f = clamp((xCss - pad)/usable, 0, 1);
    const distMax = points[points.length-1].dist || 1;
    const targetDist = f * distMax;

    const p = nearestPointByDist(targetDist);
    syncToPoint(p, { seekVideo:true, centerMap:true, redrawProfile:true });
  }
  elevCanvas.addEventListener("mousedown", (e) => { draggingProfile = true; scrubFromCanvas(e.clientX); });
  window.addEventListener("mousemove", (e) => { if (draggingProfile) scrubFromCanvas(e.clientX); });
  window.addEventListener("mouseup", () => { draggingProfile = false; });
  elevCanvas.addEventListener("click", (e) => scrubFromCanvas(e.clientX));

  /* ============================================================
     FOLDER LOAD
     ============================================================ */
  dirInput.addEventListener("change", () => {
    mp4Files.clear(); gpxFiles.clear(); kmzFiles.clear(); kmlFiles.clear(); xlsxFiles.clear();
    mp4Select.innerHTML = `<option value="">(elige MP4)</option>`;

    for (const f of dirInput.files){
      const low = f.name.toLowerCase();
      const base = basenameNoExt(f.name);
      if (low.endsWith(".mp4")) mp4Files.set(f.name, f);
      if (low.endsWith(".gpx")) gpxFiles.set(base, f);
      if (low.endsWith(".kmz")) kmzFiles.set(base, f);
      if (low.endsWith(".kml")) kmlFiles.set(base, f);
      if (low.endsWith(".xlsx")) xlsxFiles.set(base, f);
    }

    const names = [...mp4Files.keys()].sort((a,b)=>a.localeCompare(b, "es", { numeric:true }));
    for (const name of names){
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      mp4Select.appendChild(opt);
    }

    setStatus(`Carpeta cargada: ${mp4Files.size} mp4, ${gpxFiles.size} gpx, ${kmzFiles.size} kmz, ${xlsxFiles.size} xlsx`);
  });

  mp4Select.addEventListener("change", async () => {
    const name = mp4Select.value;
    if (!name) return;

    clearTrack();
    clearOverlay();
    clearRutometre();

    const mp4 = mp4Files.get(name);
    video.src = URL.createObjectURL(mp4);

    const base = basenameNoExt(name);

    const gpx = gpxFiles.get(base);
    if (gpx){
      const text = await readFileAsText(gpx);
      points = parseGpx(text);
      if (points.length){
        firstAbsTime = points[0].tAbs;
        drawTrack();
      } else {
        setStatus("GPX vac√≠o o sin puntos v√°lidos");
      }
    } else {
      setStatus("MP4 cargado (sin GPX con mismo nombre)");
    }

    const kmz = kmzFiles.get(base);
    const kml = kmlFiles.get(base);
    if (kmz){
      try { await loadKmzFile(kmz, { fit:false }); } catch(e){ console.error(e); }
    } else if (kml){
      try { await loadKmlFile(kml, { fit:false }); } catch(e){ console.error(e); }
    }

    const xlsx = xlsxFiles.get(base);
    if (xlsx){
      try { await loadExcelFile(xlsx); } catch(e){ console.error(e); }
    }

    if (points.length){
      setStatus(`Listo: ${name} (GPX${(kmz||kml)?", KMZ/KML":""}${xlsx?", Excel":""})`);
    }
  });

  /* ============================================================
     MANUAL IMPORTS
     ============================================================ */
  kmlKmzInput.addEventListener("change", async () => {
    const f = kmlKmzInput.files && kmlKmzInput.files[0];
    if (!f) return;
    try{
      if (f.name.toLowerCase().endsWith(".kmz")) await loadKmzFile(f, { fit:true });
      else await loadKmlFile(f, { fit:true });
    } finally { kmlKmzInput.value = ""; }
  });

  excelInput.addEventListener("change", async () => {
    const f = excelInput.files && excelInput.files[0];
    if (!f) return;
    try{ await loadExcelFile(f); } finally { excelInput.value = ""; }
  });

  /* ============================================================
     EXCEL: header + render + sync
     ============================================================ */
  async function loadExcelFile(file){
    const ab = await file.arrayBuffer();
    const wb = XLSX.read(ab, { type:"array" });

    let chosen = null;
    for (const shName of wb.SheetNames){
      const ws = wb.Sheets[shName];
      const grid = XLSX.utils.sheet_to_json(ws, { header:1, defval:"" });
      const headerRow = findHeaderRowIndex(grid);
      if (headerRow !== -1){
        chosen = { shName, grid, headerRow };
        break;
      }
    }
    if (!chosen){
      const shName = wb.SheetNames[0];
      const ws = wb.Sheets[shName];
      chosen = { shName, grid: XLSX.utils.sheet_to_json(ws, { header:1, defval:"" }), headerRow:0 };
    }

    const rows = gridToObjects(chosen.grid, chosen.headerRow);

    rutometreRows = rows
      .map(r => normalizeRutometreRow(r))
      .filter(r => {
        const hasAny = String(r.Describe_Es||"").trim()
          || String(r.Coordenades_GPS||"").trim()
          || String(r.Coordenada_X||"").trim()
          || String(r.Coordenada_Y||"").trim();
        return !!hasAny;
      });

    renderRutometreTable();
    rutometreInfo.textContent = `Rut√≥metro: ${rutometreRows.length} filas`;
    setStatus(`Excel cargado: ${file.name} (${rutometreRows.length} filas)`);

    computeRutometreSync();
  }

  function findHeaderRowIndex(grid){
    for (let i=0;i<Math.min(grid.length, 50);i++){
      const row = grid[i] || [];
      const norm = row.map(x => String(x||"").trim().toLowerCase());
      if (norm.includes("describe_es")) return i;
    }
    return -1;
  }

  function gridToObjects(grid, headerRowIndex){
    const header = (grid[headerRowIndex] || []).map(x => String(x||"").trim());
    const out = [];
    for (let i=headerRowIndex+1;i<grid.length;i++){
      const row = grid[i] || [];
      const any = row.some(v => String(v||"").trim() !== "");
      if (!any) continue;

      const obj = {};
      for (let c=0;c<header.length;c++){
        const key = header[c] || `COL_${c+1}`;
        obj[key] = row[c] ?? "";
      }
      out.push(obj);
    }
    return out;
  }

  function normalizeRutometreRow(r){
    const pick = (obj, ...keys) => {
      for (const k of keys){
        if (k in obj) return obj[k];
        const kk = Object.keys(obj).find(x => x.trim().toLowerCase() === k.trim().toLowerCase());
        if (kk) return obj[kk];
      }
      return "";
    };

    return {
      Describe_Es:      pick(r, "Describe_Es"),
      Km_Etapa:        pick(r, "Km_Etapa"),
      Km_Faltan:       pick(r, "Km_Faltan"),
      Horario_1:       pick(r, "Horario_1"),
      Horario_2:       pick(r, "Horario_2"),
      Horario_3:       pick(r, "Horario_3"),
      codi_picto:      pick(r, "codi picto", "codi_picto"),
      Coordenada_X:    pick(r, "Coordenada_X"),
      Coordenada_Y:    pick(r, "Coordenada_Y"),
      Coordenades_GPS: pick(r, "Coordenades_GPS", "Coordenades GPS"),
    };
  }

  function renderRutometreTable(){
    if (!rutometreRows.length){
      rutometreTbody.innerHTML = `<tr><td colspan="10" style="padding:10px;opacity:.7;">Excel vac√≠o‚Ä¶</td></tr>`;
      return;
    }

    rutometreTbody.innerHTML = rutometreRows.map((r, idx) => `
      <tr data-idx="${idx}">
        <td class="col-desc">${escapeHtml(r.Describe_Es||"")}</td>
        <td class="td-num">${escapeHtml(r.Km_Etapa||"")}</td>
        <td class="td-num">${escapeHtml(r.Km_Faltan||"")}</td>
        <td class="td-small">${escapeHtml(r.Horario_1||"")}</td>
        <td class="td-small">${escapeHtml(r.Horario_2||"")}</td>
        <td class="td-small">${escapeHtml(r.Horario_3||"")}</td>
        <td class="td-small">${escapeHtml(r.codi_picto||"")}</td>
        <td class="td-small">${escapeHtml(r.Coordenada_X||"")}</td>
        <td class="td-small">${escapeHtml(r.Coordenada_Y||"")}</td>
        <td class="td-small">${escapeHtml(r.Coordenades_GPS||"")}</td>
      </tr>
    `).join("");

    rutometreTbody.querySelectorAll("tr[data-idx]").forEach(tr => {
      tr.addEventListener("click", () => {
        const idx = +tr.dataset.idx;
        const wp = rutometreWpts.find(w => w.rowIndex === idx);
        if (wp && Number.isFinite(wp.tOffset) && points.length){
          video.currentTime = wp.tOffset;
          const p = pointAtTime(wp.tOffset);
          syncToPoint(p, { seekVideo:true, centerMap:true, redrawProfile:true });
        } else {
          const ll = parseGpsLatLonFromRow(rutometreRows[idx]);
          if (ll){
            map.panTo([ll.lat, ll.lon], { animate:false });
            if (points.length){
              const p = nearestPoint(ll.lat, ll.lon);
              if (p) syncToPoint(p, { seekVideo:true, centerMap:true, redrawProfile:true });
            }
          } else {
            setStatus("Fila sin coordenadas/sync");
          }
        }
      });
    });

    ensureTableColumnWidths();
    makeTableResizable(document.getElementById("rutometreTable"));
  }

  function parseGpsLatLonFromRow(row){
    const s = String(row.Coordenades_GPS||"").trim();
    if (s){
      const cleaned = s.replaceAll(";", ",").replaceAll("|", ",").replaceAll("\\t", " ");
      let parts = cleaned.split(",").map(x=>x.trim()).filter(Boolean);
      if (parts.length < 2){
        parts = cleaned.split(/\\s+/).map(x=>x.trim()).filter(Boolean);
      }
      if (parts.length >= 2){
        const a = parseFloat(parts[0]);
        const b = parseFloat(parts[1]);
        if (Number.isFinite(a) && Number.isFinite(b)){
          if (Math.abs(a) <= 90 && Math.abs(b) <= 180) return { lat:a, lon:b };
          if (Math.abs(a) <= 180 && Math.abs(b) <= 90) return { lat:b, lon:a };
        }
      }
    }

    const x = parseFloat(String(row.Coordenada_X||"").replace(",", "."));
    const y = parseFloat(String(row.Coordenada_Y||"").replace(",", "."));
    if (Number.isFinite(x) && Number.isFinite(y)){
      if (Math.abs(x) <= 180 && Math.abs(y) <= 90) return { lat:y, lon:x };
      if (Math.abs(x) <= 90 && Math.abs(y) <= 180) return { lat:x, lon:y };
    }
    return null;
  }

  function computeRutometreSync(){
    if (!rutometreRows.length){
      rutometreSyncInfo.textContent = "Sync: ‚Äî";
      rutometreWpts = [];
      updateRutometreActive(-1);
      return;
    }
    if (!points.length){
      rutometreSyncInfo.textContent = "Sync: falta GPX";
      rutometreWpts = [];
      updateRutometreActive(-1);
      return;
    }

    const wpts = [];
    let ok = 0;

    for (let i=0;i<rutometreRows.length;i++){
      const row = rutometreRows[i];
      const ll = parseGpsLatLonFromRow(row);
      if (!ll) continue;

      const near = nearestPoint(ll.lat, ll.lon);
      if (!near) continue;

      wpts.push({
        rowIndex: i,
        tOffset: near.tOffset,
        dist: near.dist,
        Describe_Es: row.Describe_Es || ""
      });
      ok++;
    }

    wpts.sort((a,b)=>a.tOffset - b.tOffset);
    rutometreWpts = wpts;

    rutometreSyncInfo.textContent = `Sync: ${ok} filas enlazadas`;
    updateRutometreActive(rutometreActiveIndexForTime(video.currentTime));
  }

  function rutometreActiveIndexForTime(t){
    if (!rutometreWpts.length || !Number.isFinite(t)) return -1;
    let active = -1;
    for (let i=0;i<rutometreWpts.length;i++){
      if (rutometreWpts[i].tOffset <= t) active = i;
      else break;
    }
    return active;
  }

  function updateRutometreActive(wptIndex){
    if (activeRutometreIndex === wptIndex) return;

    if (activeRutometreIndex !== -1){
      const prevRowIndex = rutometreWpts[activeRutometreIndex]?.rowIndex;
      if (Number.isFinite(prevRowIndex)){
        const prevTr = rutometreTbody.querySelector(`tr[data-idx="${prevRowIndex}"]`);
        if (prevTr) prevTr.classList.remove("active");
      }
    }

    activeRutometreIndex = wptIndex;

    if (activeRutometreIndex === -1) return;

    const rowIndex = rutometreWpts[activeRutometreIndex].rowIndex;
    const tr = rutometreTbody.querySelector(`tr[data-idx="${rowIndex}"]`);
    if (tr){
      tr.classList.add("active");
      tr.scrollIntoView({ block:"nearest", behavior:"smooth" });
    }

    const label = rutometreWpts[activeRutometreIndex].Describe_Es || "";
    rutometreSyncInfo.textContent = `Sync: #${activeRutometreIndex+1}/${rutometreWpts.length} ¬∑ ${label}`;
  }

  /* ============================================================
     TABLE: min widths + Describe 10x others + resizable columns
     ============================================================ */
  const COLS = [
    { min:220, init:520 },  // Describe_Es (10x)
    { min:70,  init:90  },  // Km_Etapa
    { min:70,  init:90  },  // Km_Faltan
    { min:80,  init:95  },  // Horario_1
    { min:80,  init:95  },  // Horario_2
    { min:80,  init:95  },  // Horario_3
    { min:80,  init:95  },  // codi picto
    { min:95,  init:120 },  // Coordenada_X
    { min:95,  init:120 },  // Coordenada_Y
    { min:110, init:170 },  // Coordenades_GPS
  ];

  function ensureTableColumnWidths(){
    const table = document.getElementById("rutometreTable");
    if (!table) return;

    let colgroup = table.querySelector("colgroup");
    if (colgroup) colgroup.remove();
    colgroup = document.createElement("colgroup");

    for (const c of COLS){
      const col = document.createElement("col");
      col.style.width = c.init + "px";
      col.style.minWidth = c.min + "px";
      colgroup.appendChild(col);
    }
    table.insertBefore(colgroup, table.firstChild);
  }

  function makeTableResizable(table){
    if (!table) return;
    table.querySelectorAll(".col-resizer").forEach(x => x.remove());

    const ths = table.querySelectorAll("thead th");
    const colgroup = table.querySelector("colgroup");
    if (!colgroup) return;
    const cols = colgroup.querySelectorAll("col");

    ths.forEach((th, colIndex) => {
      const resizer = document.createElement("div");
      resizer.className = "col-resizer";
      th.appendChild(resizer);

      let startX = 0;
      let startW = 0;

      const onMove = (e) => {
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const dx = clientX - startX;
        const minW = COLS[colIndex]?.min ?? 40;
        const newW = Math.max(minW, startW + dx);
        cols[colIndex].style.width = newW + "px";
      };

      const onUp = () => {
        document.removeEventListener("mousemove", onMove);
        document.removeEventListener("mouseup", onUp);
        document.removeEventListener("touchmove", onMove);
        document.removeEventListener("touchend", onUp);
        document.body.style.cursor = "";
      };

      const onDown = (e) => {
        e.preventDefault();
        startX = e.touches ? e.touches[0].clientX : e.clientX;
        startW = cols[colIndex].getBoundingClientRect().width;
        document.body.style.cursor = "col-resize";

        document.addEventListener("mousemove", onMove);
        document.addEventListener("mouseup", onUp);
        document.addEventListener("touchmove", onMove, { passive:false });
        document.addEventListener("touchend", onUp);
      };

      resizer.addEventListener("mousedown", onDown);
      resizer.addEventListener("touchstart", onDown, { passive:false });
    });
  }

  ensureTableColumnWidths();
  makeTableResizable(document.getElementById("rutometreTable"));

  /* ============================================================
     KMZ/KML with icons + name/description
     ============================================================ */
  async function loadKmlFile(file, opts){
    clearOverlay();
    const txt = await readFileAsText(file);
    overlayLayer = kmlToLeafletLayer(txt);
    overlayLayer.addTo(map);
    if (opts?.fit){
      try{ map.fitBounds(overlayLayer.getBounds(), { padding:[20,20] }); } catch(_){}
    }
    setStatus(`Overlay cargado: ${file.name}`);
  }

  async function loadKmzFile(file, opts){
    clearOverlay();

    const ab = await file.arrayBuffer();
    const zip = await JSZip.loadAsync(ab);

    const blobUrlByPath = new Map();
    const fileByLower = new Map();
    zip.forEach((relPath, zf) => { fileByLower.set(relPath.toLowerCase(), zf); });

    async function getBlobUrl(relPath){
      let key = relPath.toLowerCase();
      while (key.startsWith("./")) key = key.slice(2);
      while (key.startsWith("/")) key = key.slice(1);
      if (blobUrlByPath.has(key)) return blobUrlByPath.get(key);
      const zf = fileByLower.get(key);
      if (!zf) return null;
      const blob = await zf.async("blob");
      const url = URL.createObjectURL(blob);
      blobUrlByPath.set(key, url);
      return url;
    }

    let kmlPath = null;
    zip.forEach((relPath) => { if (!kmlPath && relPath.toLowerCase().endsWith(".kml")) kmlPath = relPath; });
    if (!kmlPath){
      setStatus("KMZ sin KML (no encontrado .kml)");
      return;
    }

    const kmlText = await zip.file(kmlPath).async("text");

    const iconResolver = async (href) => {
      if (!href) return null;
      href = href.split("#")[0];
      while (href.startsWith("./")) href = href.slice(2);
      while (href.startsWith("/")) href = href.slice(1);
      if (href.startsWith("http://") || href.startsWith("https://")) return href;

      let url = await getBlobUrl(href);
      if (url) return url;

      const kmlDir = kmlPath.replace(/[^\\/]+$/, "");
      if (kmlDir){
        url = await getBlobUrl((kmlDir + href).replace(/\\\\/g,"/"));
        if (url) return url;
      }

      url = await getBlobUrl(("files/" + href).replace(/\\\\/g,"/"));
      if (url) return url;

      return null;
    };

    overlayLayer = await kmlToLeafletLayerAsync(kmlText, iconResolver);
    overlayLayer.addTo(map);

    if (opts?.fit){
      try{ map.fitBounds(overlayLayer.getBounds(), { padding:[20,20] }); } catch(_){}
    }

    setStatus(`Overlay cargado: ${file.name}`);
  }

  function kmlToLeafletLayer(kmlText){
    const xml = new DOMParser().parseFromString(kmlText, "application/xml");
    const gj = toGeoJSON.kml(xml);
    return L.geoJSON(gj, {
      style: () => ({ color:"#cc00cc", weight:3, opacity:0.85 }),
      pointToLayer: (feature, latlng) => {
        const name = feature?.properties?.name || "";
        const desc = feature?.properties?.description || "";
        return L.circleMarker(latlng, {
          radius: 5,
          color: "#cc00cc",
          fillColor: "#cc00cc",
          fillOpacity: 0.8,
          weight: 1
        }).bindPopup(`<b>${escapeHtml(name)}</b><br>${desc}`);
      }
    });
  }

  async function kmlToLeafletLayerAsync(kmlText, iconResolver){
    const xml = new DOMParser().parseFromString(kmlText, "application/xml");

    const styleIcon = new Map(); // "#styleId" -> href
    const styles = [...xml.querySelectorAll("Style[id]")];
    for (const st of styles){
      const id = st.getAttribute("id");
      const href = st.querySelector("IconStyle Icon href")?.textContent?.trim()
                || st.querySelector("IconStyle Icon Href")?.textContent?.trim();
      if (id && href) styleIcon.set("#"+id, href);
    }

    const styleMapNormal = new Map(); // "#mapId" -> "#styleId"
    const styleMaps = [...xml.querySelectorAll("StyleMap[id]")];
    for (const sm of styleMaps){
      const id = sm.getAttribute("id");
      if (!id) continue;
      const pairs = [...sm.querySelectorAll("Pair")];
      for (const p of pairs){
        const key = p.querySelector("key")?.textContent?.trim();
        const url = p.querySelector("styleUrl")?.textContent?.trim();
        if (key === "normal" && url){
          styleMapNormal.set("#"+id, url);
        }
      }
    }

    const markers = [];
    const placemarks = [...xml.querySelectorAll("Placemark")];

    for (const pm of placemarks){
      const coordText = pm.querySelector("Point coordinates")?.textContent?.trim();
      if (!coordText) continue;

      const parts = coordText.split(",").map(x=>x.trim());
      if (parts.length < 2) continue;
      const lon = parseFloat(parts[0]);
      const lat = parseFloat(parts[1]);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;

      const name = pm.querySelector("name")?.textContent?.trim() || "";
      const desc = pm.querySelector("description")?.textContent?.trim() || "";

      let styleUrl = pm.querySelector("styleUrl")?.textContent?.trim() || "";
      if (styleUrl && styleMapNormal.has(styleUrl)) styleUrl = styleMapNormal.get(styleUrl);
      const href = styleIcon.get(styleUrl) || "";

      const iconUrl = iconResolver ? await iconResolver(href) : null;
      let icon = null;

      if (iconUrl){
        icon = L.icon({
          iconUrl,
          iconSize: [26, 26],
          iconAnchor: [13, 26],
          popupAnchor: [0, -26],
          className: "kmz-icon"
        });
      }

      const m = icon
        ? L.marker([lat, lon], { icon })
        : L.circleMarker([lat, lon], { radius:5, color:"#cc00cc", fillColor:"#cc00cc", fillOpacity:0.8, weight:1 });

      m.bindPopup(`<b>${escapeHtml(name)}</b><br>${desc}`);
      markers.push(m);
    }

    const gj = toGeoJSON.kml(xml);
    const geo = L.geoJSON(gj, {
      style: (feat) => {
        const t = feat?.geometry?.type || "";
        if (t === "LineString" || t === "MultiLineString") return { color:"#cc00cc", weight:3, opacity:0.85 };
        if (t === "Polygon" || t === "MultiPolygon") return { color:"#cc00cc", weight:2, opacity:0.85, fillOpacity:0.15 };
        return { color:"#cc00cc", weight:2, opacity:0.85 };
      },
      pointToLayer: () => null
    });

    return L.featureGroup([geo, ...markers]);
  }

  /* ============================================================
     GOOGLE + SNAPSHOT
     ============================================================ */
  function getCurrentLatLon(){
    if (!points.length || !marker) return null;
    const ll = marker.getLatLng();
    return { lat: ll.lat, lon: ll.lng };
  }

  btnGoogleMaps.addEventListener("click", () => {
    const pos = getCurrentLatLon();
    if (!pos) return;
    window.open(`https://www.google.com/maps?q=${pos.lat},${pos.lon}&z=18`, "_blank", "noopener");
  });

  btnStreetView.addEventListener("click", () => {
    const pos = getCurrentLatLon();
    if (!pos) return;
    const heading = Number.isFinite(lastBearingDeg) ? lastBearingDeg : 0;
    const url = `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${pos.lat},${pos.lon}&heading=${heading}&pitch=0`;
    window.open(url, "_blank", "noopener");
  });

  btnSnapshot.addEventListener("click", () => {
    if (!video.videoWidth || !video.videoHeight){
      setStatus("No hay frame para capturar (reproduce el v√≠deo un momento)");
      return;
    }
    const c = document.createElement("canvas");
    c.width = video.videoWidth;
    c.height = video.videoHeight;
    c.getContext("2d").drawImage(video, 0, 0, c.width, c.height);

    const pos = getCurrentLatLon();
    const t = fmtTimeHMS(video.currentTime).replaceAll(":","-");
    const lat = pos ? pos.lat.toFixed(5) : "NA";
    const lon = pos ? pos.lon.toFixed(5) : "NA";

    c.toBlob((blob) => {
      if (!blob) return;
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = `frame_${t}_${lat}_${lon}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setStatus("Snapshot descargado (PNG)");
    }, "image/png");
  });

  /* ============================================================
     SPLITTERS: resize the 2x2 panels (vertical + horizontal)
     ============================================================ */
  function invalidateAfterResize(){
    if (typeof map.invalidateSize === "function") map.invalidateSize(false);
    drawElevationProfile(video.currentTime);
  }

  function enableSplitters(){
    // Vertical splitter -> --colLeft
    (function(){
      let startX=0, startLeftPx=0, totalW=0;
      const minCol = 260;

      function down(e){
        e.preventDefault();
        const rect = mainEl.getBoundingClientRect();
        totalW = rect.width;

        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        startX = clientX - rect.left;

        const cs = getComputedStyle(mainEl).gridTemplateColumns.split(" ");
        startLeftPx = parseFloat(cs[0]) || (totalW/2);

        document.body.style.cursor = "col-resize";
        document.addEventListener("mousemove", move);
        document.addEventListener("mouseup", up);
        document.addEventListener("touchmove", move, { passive:false });
        document.addEventListener("touchend", up);
      }

      function move(e){
        e.preventDefault();
        const rect = mainEl.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const x = clientX - rect.left;
        const dx = x - startX;

        const splitW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--splitter")) || 8;
        const newLeft = clamp(startLeftPx + dx, minCol, totalW - splitW - minCol);

        const pct = (newLeft / totalW) * 100;
        document.documentElement.style.setProperty("--colLeft", pct.toFixed(3) + "%");
        invalidateAfterResize();
      }

      function up(){
        document.body.style.cursor = "";
        document.removeEventListener("mousemove", move);
        document.removeEventListener("mouseup", up);
        document.removeEventListener("touchmove", move);
        document.removeEventListener("touchend", up);
      }

      vSplit.addEventListener("mousedown", down);
      vSplit.addEventListener("touchstart", down, { passive:false });
    })();

    // Horizontal splitter -> --rowTop
    (function(){
      let startY=0, startTopPx=0, totalH=0;
      const minRow = 220;

      function down(e){
        e.preventDefault();
        const rect = mainEl.getBoundingClientRect();
        totalH = rect.height;

        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        startY = clientY - rect.top;

        const rs = getComputedStyle(mainEl).gridTemplateRows.split(" ");
        startTopPx = parseFloat(rs[0]) || (totalH/2);

        document.body.style.cursor = "row-resize";
        document.addEventListener("mousemove", move);
        document.addEventListener("mouseup", up);
        document.addEventListener("touchmove", move, { passive:false });
        document.addEventListener("touchend", up);
      }

      function move(e){
        e.preventDefault();
        const rect = mainEl.getBoundingClientRect();
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const y = clientY - rect.top;
        const dy = y - startY;

        const splitH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--splitter")) || 8;
        const newTop = clamp(startTopPx + dy, minRow, totalH - splitH - minRow);

        const pct = (newTop / totalH) * 100;
        document.documentElement.style.setProperty("--rowTop", pct.toFixed(3) + "%");
        invalidateAfterResize();
      }

      function up(){
        document.body.style.cursor = "";
        document.removeEventListener("mousemove", move);
        document.removeEventListener("mouseup", up);
        document.removeEventListener("touchmove", move);
        document.removeEventListener("touchend", up);
      }

      hSplit.addEventListener("mousedown", down);
      hSplit.addEventListener("touchstart", down, { passive:false });
    })();
  }

  enableSplitters();

  /* ============================================================
     INIT
     ============================================================ */
  setStatus("Esperando carpeta‚Ä¶");
  resizeCanvasToCSS();
  drawElevationProfile(null);
  </script>
</body>
</html>
