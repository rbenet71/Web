<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Video Race Mapping (VRM)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>


  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#111111">
  <!-- Manifest injected by JS for file:// compatibility -->
  <link rel="icon" href="assets/logo_192x192.png">
  <link rel="apple-touch-icon" href="assets/logo_192x192.png">


  <style>
    :root{
      --splitter: 8px;
      --colLeft: 50%;
      --rowTop: 50%;
      --appFooterH: 34px;
      --appHeaderH: 84px;
    }

    html, body{
      margin:0; padding:0; height:100%;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:#fff;
    }

    
    /* ============================================================
       FIXED APP HEADER
       ============================================================ */
    #appHeader{
      position:fixed;
      top:0; left:0; right:0;
      height:84px;
      background:#fff;
      border-bottom:1px solid #ddd;
      z-index:1000;
      display:flex;
      flex-direction:column;
      box-sizing:border-box;
    }
    
    #appHeader .headerMain img{
      height:60px;
      width:auto;
      display:block;
    }
    #appHeader .appName{
      font-weight:600;
      font-size:30px;
      line-height:1.1;
    }
    #appHeader .appShort{
      font-size:18px;
      opacity:.6;
      line-height:1.1;
    }
    #appHeader .raceName{
      font-size:16px;
      padding:2px 12px 4px;
      border-top:1px solid #eee;
      background:#fafafa;
      box-sizing:border-box;

      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      min-height: 28px;
    }
    #raceName{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
/* ============================================================
       TOP LAYOUT
       ============================================================ */
    #layout{
      margin-top: var(--appHeaderH);
      height: calc(100vh - var(--appHeaderH) - var(--appFooterH));
      display: grid;
      grid-template-rows: auto 1fr; /* controls + main */
      min-height: 0;
    }

    /* Fix: keep main in row 2 even when #controls is display:none */
    #controls{ grid-row: 1; grid-column: 1; }
    #main{ grid-row: 2; grid-column: 1; min-height: 0; }



    #controls{
      padding:8px 10px;
      background:#f2f2f2;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      border-bottom:1px solid #ddd;
    }

    #logo{
      height:34px;
      width:auto;
      display:block;
      margin-right:4px;
    }

    label{
      background:#fff;
      padding:6px 10px;
      border-radius:8px;
      border:1px solid #ccc;
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      white-space:nowrap;
    }

    select, button{
      padding:6px 10px;
      border-radius:8px;
      border:1px solid #ccc;
      background:#fff;
      cursor:pointer;
      font-size:14px;
    }

    #status{
      margin-left:auto;
      font-size:.9em;
      opacity:.85;
      white-space:nowrap;
    }

    /* ============================================================
       MAIN 2x2 GRID with splitters
       ============================================================ */
    #main{
      height:100%;
      min-height:0;
      display:grid;

      grid-template-columns: var(--colLeft) var(--splitter) 1fr;
      grid-template-rows: var(--rowTop) var(--splitter) 1fr;

      grid-template-areas:
        "video  .  map"
        ".      .  ."
        "table  .  profile";
    }

    .panel{
      position:relative;
      min-height:0;
      overflow:hidden;
      border:1px solid #ddd;
      background:#fff;
    }

    #videoWrap{ grid-area: video; background:#000; border-right:none; border-bottom:none; }
    #mapPanel { grid-area: map;   border-left:none; border-bottom:none; }
    #tablePanel{ grid-area: table; border-right:none; border-top:none; }
    #profilePanel{ grid-area: profile; border-left:none; border-top:none; background:#fafafa; }

    /* splitters */
    .splitter{
      background: rgba(0,0,0,0.08);
      border-radius: 6px;
      user-select: none;
      touch-action: none;
      z-index: 50;
    }
    .splitter:hover{ background: rgba(0,0,0,0.16); }

    #vSplit{
      grid-column: 2;
      grid-row: 1 / 4;   /* <- ocupa las 3 filas (arriba, splitter, abajo) */
      cursor: col-resize;
    }

    #hSplit{
      grid-column: 1 / 4; /* <- ocupa las 3 columnas */
      grid-row: 2;
      cursor: row-resize;
    }


    /* ============================================================
       VIDEO
       ============================================================ */
    video{
      width:100%;
      height:100%;
      background:#000;
      object-fit:contain;
      display:block;
      outline:none;
    }

    #hud{
      position:absolute;
      left:10px;
      top:10px;
      background: rgba(0,0,0,0.55);
      color:#fff;
      padding:6px 8px;
      border-radius:10px;
      font-size:12px;
      pointer-events:none;
      z-index:20;
      max-width: calc(100% - 20px);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    #videoTools{
      position:absolute;
      right:10px;
      top:10px;
      display:flex;
      gap:8px;
      z-index:25;
    }

    .iconBtn{
      width:36px;
      height:36px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.45);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
    }
    .iconBtn:hover{ background: rgba(0,0,0,0.65); }

    /* pictos blancos */
    .iconBtn img{
      width:20px;
      height:20px;
      opacity:0.98;
      pointer-events:none;
      filter:none;
    }
    .iconBtn svg{
      width:20px; height:20px;
      display:block;
      fill:#fff;
    }

    /* ============================================================
       MAP
       ============================================================ */
    #map{ width:100%; height:100%; }

    /* KMZ icon markers: keep crisp */
    .kmz-icon{
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }

    /* ============================================================
       TABLE (Rut√≥metro)
       ============================================================ */
    #tableWrap{
      display:flex;
      flex-direction:column;
      height:100%;
      min-height:0;
      background:#fff;
    }

    #tableHeader{
      padding:6px 8px;
      background:#fafafa;
      border-bottom:1px solid #ddd;
      display:flex;
      align-items:center;
      gap:10px;
      font-size:13px;
      white-space:nowrap;
    }

    #tableHeader .pill{
      padding:2px 8px;
      border:1px solid #ddd;
      border-radius:999px;
      background:#fff;
      opacity:.9;
    }

    #rutometreTableContainer{
      overflow:auto;      /* vertical + horizontal scrollbars */
      flex:1;
      min-height:0;
    }

    table{
      border-collapse:collapse;
      font-size:12px;
    }

    /* fixed layout => we can resize columns reliably */
    #rutometreTable{
      table-layout: fixed;
      width: max(100%, 1100px);
    }

    thead th{
      position:sticky;
      top:0;
      z-index:5;
      background:#f3f3f3;
      border-bottom:1px solid #ddd;
      padding:6px 10px 6px 6px;
      text-align:left;
      white-space:nowrap;
      vertical-align:bottom;
    }

    tbody td{
      border-bottom:1px solid #eee;
      padding:6px 6px;
      vertical-align:top;
    }

    tbody tr:hover{ background:#f8fbff; cursor:pointer; }
    tbody tr.active{ background:#ffe8cc; }
    tbody tr.active td{ border-bottom-color:#ffd19a; }

    .td-num{
      text-align:right;
      font-variant-numeric: tabular-nums;
      white-space:nowrap;
    }
    .td-small{ white-space:nowrap; opacity:.9; }

    /* Describe_Es: wrap after ~50 chars (approx using ch units) */
    .col-desc{
      white-space: normal !important;
      max-width: 50ch;
      overflow-wrap: break-word;
      word-break: break-word;
    }

    /* column resizer handle */
    .col-resizer{
      position:absolute;
      top:0; right:0;
      width:8px; height:100%;
      cursor: col-resize;
      user-select:none;
      touch-action:none;
    }
    .col-resizer:hover{ background: rgba(0,0,0,0.10); }

    /* ============================================================
       PROFILE
       ============================================================ */
    #profileWrap{
      padding:8px;
      background:#fafafa;
      box-sizing:border-box;
      height:100%;
      width:100%;
    }

    #elevCanvas{
      width:100%;
      height:100%;
      display:block;
      background:#fff;
      border:1px solid #ddd;
      border-radius:10px;
    }

    /* ============================================================
       MOBILE
       ============================================================ */
    @media (max-width: 980px){
      #main{
        grid-template-columns: 1fr;
        grid-template-rows: 30vh var(--splitter) 30vh var(--splitter) 30vh var(--splitter) 30vh;
        grid-template-areas:
          "video"
          "hSplit"
          "map"
          "hSplit"
          "table"
          "hSplit"
          "profile";
      }
      #vSplit{ display:none; }
      #hSplit{ cursor: row-resize; }
    }

        
    /* Marker icon (bike) - animated cyclist (high-contrast, thin stroke) */
    .bike-marker{
      width:36px;height:36px;
      display:flex;align-items:center;justify-content:center;
      border-radius:18px;
      background: rgba(255,255,255,.85);
      border: 2px solid rgba(0,0,0,.45);
      box-sizing:border-box;
      filter: drop-shadow(0 2px 3px rgba(0,0,0,.35));
    }
    .bike-marker svg{ width:32px;height:32px; display:block; }
    .bike-marker .wheel-anim, .bike-marker .crank{
      transform-box: fill-box;
      transform-origin: center;
      animation: vrmSpin .7s linear infinite;
    }
    @keyframes vrmSpin{ to{ transform: rotate(360deg); } }




    /* ============================================================
      HEADER toggle (show/hide operations bar)
      ============================================================ */

    #appHeader .headerLeft{ display:flex; align-items:center; gap:10px; }
    #appHeader .headerToggle{
      width:34px;height:34px;border-radius:10px;
      border:1px solid rgba(0,0,0,.22); background:#fff;
      display:inline-flex;align-items:center;justify-content:center;
      cursor:pointer;
    }


    #appHeader .headerRight{
      display:flex;
      align-items:center;
      gap:10px;
    }
    #appHeader .headerAction{
      height:34px;
      border-radius:10px;
      border:1px solid rgba(0,0,0,.22);
      background:#fff;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:0 10px;
      font-size:14px;
      line-height:1;
      white-space:nowrap;
    }
    #appHeader .headerAction:disabled{
      opacity:.5;
      cursor:not-allowed;
    }

    /* PWA install help modal */
    #installHelp{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.55);
      z-index:2000;
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      box-sizing:border-box;
    }
    #installHelp .panel{
      max-width:520px;
      width:100%;
      background:#fff;
      border-radius:14px;
      padding:16px 16px 14px;
      box-shadow:0 10px 30px rgba(0,0,0,.25);
      font-size:14px;
    }
    #installHelp .panel h3{
      margin:0 0 10px 0;
      font-size:18px;
    }
    #installHelp .panel ol{
      margin:8px 0 0 18px;
      padding:0;
    }
    #installHelp .panel .row{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      margin-top:12px;
    }
    #installHelp .panel button{
      border:1px solid rgba(0,0,0,.22);
      background:#fff;
      border-radius:10px;
      padding:6px 10px;
      cursor:pointer;
    }
    
    /* HELP modal (i18n from external file) */
    #helpDialog{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.55);
      z-index:2100;
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      box-sizing:border-box;
    }
    #helpDialog .panel{
      max-width: 780px;
      width:100%;
      max-height: calc(100vh - 60px);
      background:#fff;
      border-radius:14px;
      padding:14px 14px 12px;
      box-shadow:0 10px 30px rgba(0,0,0,.25);
      display:flex;
      flex-direction:column;
      overflow:hidden;
      font-size:14px;
    }
    #helpDialog .helpHeader{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      border-bottom:1px solid #eee;
      padding-bottom:8px;
      margin-bottom:10px;
    }
    #helpDialog h3{
      margin:0;
      font-size:18px;
      line-height:1.2;
    }
    #helpDialog .helpControls{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    #helpDialog .helpLangLabel{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border:1px solid rgba(0,0,0,.18);
      border-radius:10px;
      background:#fff;
      cursor:default;
      user-select:none;
      white-space:nowrap;
    }
    #helpDialog .helpLangLabel select{
      border:1px solid rgba(0,0,0,.18);
      border-radius:8px;
      padding:4px 8px;
      background:#fff;
      cursor:pointer;
    }
    #helpDialog .helpClose{
      border:1px solid rgba(0,0,0,.22);
      background:#fff;
      border-radius:10px;
      padding:6px 10px;
      cursor:pointer;
      white-space:nowrap;
    }
    #helpDialog .helpBody{
      overflow:auto;
      min-height:0;
      padding-right:4px;
    }
    #helpDialog .helpLoading{
      opacity:.75;
      font-style:italic;
    }
    #helpDialog .helpSection{
      margin: 0 0 14px 0;
      padding: 0;
    }
    #helpDialog .helpSection h4{
      margin: 12px 0 6px;
      font-size: 15px;
    }
    #helpDialog ol{
      margin: 6px 0 0 20px;
      padding: 0;
    }
    #helpDialog li{ margin: 4px 0; }
    #helpDialog .kbd{
      display:inline-block;
      padding:1px 6px;
      border:1px solid rgba(0,0,0,.22);
      border-bottom-width:2px;
      border-radius:6px;
      background:#fafafa;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      line-height: 1.4;
      vertical-align: middle;
    }
    #helpDialog .tip{
      border-left: 3px solid rgba(0,0,0,.2);
      padding: 6px 10px;
      background: rgba(0,0,0,.03);
      border-radius: 10px;
      margin-top: 8px;
    }


    #controls.collapsed{ display:none; }


    #appHeader .headerMain{
      display:flex;
      align-items:center;
      justify-content: space-between;
    }
    #appHeader .headerLeft{
      display:flex;
      align-items:center;
      gap:10px;
    }

    /* ============================================================
      FOOTER (fixed)
      ============================================================ */
    #appFooter{
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      height: 34px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      border-top: 1px solid rgba(0,0,0,.15);
      background: #fff;
      z-index: 1200;
    }

    /* keep app content between header and footer */
    :root{
      --appFooterH: 34px;
    }

    /* ============================================================
      NEGATIVE KM VISUAL MARK
      ============================================================ */
    #hud.km-negative{
      color:#b00020;
      font-weight:700;
    }
    #hud .km-neg-flag{
      display:inline-block;
      padding:0 6px;
      margin-right:4px;
      border-radius:999px;
      border:1px solid rgba(176,0,32,.35);
      background:rgba(176,0,32,.06);
      font-weight:800;
    }

    #offlineHelp{cursor:help; font-size:14px; margin-left:6px; opacity:.85;}

  /* Checkbox GPS con icono */
  .checkIcon{
    display:inline-flex;
    align-items:center;
    gap:6px;
    user-select:none;
  }

  .checkIcon input{
    transform: translateY(1px);
  }
   
  </style>
<script>
  // Avoid CORS errors when opening as file:// (manifest fetch is blocked by browsers)
  (function(){
    try{
      if (location.protocol === "http:" || location.protocol === "https:"){
        var l = document.createElement("link");
        l.rel = "manifest";
        l.href = "VRM_manifest.json";
        document.head.appendChild(l);
      }
    }catch(e){}
  })();
</script>
  <script src="help_i18n.js"></script>
</head>

<body>

  <!-- FIXED HEADER -->
  <div id="appHeader">
    <div class="headerMain">
      <div class="headerLeft">
        <img src="logo.jpg" alt="logo" />
        <div class="title">
          <div class="appName">Video Race Mapping</div>
          <div class="appShort">VRM 2.12.1</div>
        </div>
      </div>

      <div class="headerRight">
        <button id="pwaInstallBtn" class="headerAction" title="Instalar VRM" aria-label="Instalar VRM" style="display:none">‚¨áÔ∏é Instalar</button>
        <button id="pwaUpdateBtn" class="headerAction" title="Actualizar VRM" aria-label="Actualizar VRM" style="display:none">‚ü≥ Actualizar</button>
        <button id="helpBtn" class="headerAction" title="Ayuda" aria-label="Ayuda">‚ùì Ayuda</button>
</div>

    </div>
    <div class="raceName"><span id="raceName">Video: ‚Äî</span>
      <button id="toggleOpsBtn" class="headerToggle" title="Ocultar/mostrar operaciones" aria-label="Ocultar/mostrar operaciones">
        <span id="toggleOpsIcon">‚ñæ</span>
      </button>
    </div>
  

    <div id="installHelp" role="dialog" aria-modal="true" aria-label="Instalar VRM">
      <div class="panel">
        <h3>Instalar VRM</h3>
        <div id="installHelpText">
          <p><b>iPhone/iPad (Safari):</b></p>
          <ol>
            <li>Abre esta p√°gina en <b>Safari</b> (no dentro de otra app).</li>
            <li>Pulsa el bot√≥n <b>Compartir</b> (cuadrado con flecha ‚Üë).</li>
            <li>Elige <b>A√±adir a pantalla de inicio</b>.</li>
          </ol>
          <p style="margin-top:10px"><b>Android/PC (Chrome/Edge):</b> usa el bot√≥n <b>Instalar</b> cuando aparezca.</p>
        </div>
        <div class="row">
          <button id="closeInstallHelp">Cerrar</button>
        </div>
      </div>
    </div>

    <div id="helpDialog" role="dialog" aria-modal="true" aria-label="Ayuda VRM">
      <div class="panel">
        <div class="helpHeader">
          <h3 id="helpTitle">Ayuda</h3>
          <div class="helpControls">
            <label class="helpLangLabel" title="Idioma">
              <span>üåê</span>
              <select id="helpLangSelect" aria-label="Idioma de ayuda">
                <option value="es">ES</option>
                <option value="ca">CA</option>
                <option value="en">EN</option>
                <option value="fr">FR</option>
              </select>
            </label>
            <button id="closeHelpBtn" class="helpClose" aria-label="Cerrar ayuda">Cerrar</button>
          </div>
        </div>

        <div id="helpBody" class="helpBody">
          <div class="helpLoading">Cargando ayuda‚Ä¶</div>
        </div>
      </div>
    </div>

  </div>

  <div id="layout">

    <!-- CONTROLS -->
    <div id="controls">

            <label title="Selecciona carpeta (mp4 + gpx + kmz/kml + xlsx)">
        üìÅ Carpeta
        <input id="dirInput" type="file" webkitdirectory hidden>
      </label>

      <label title="Selecciona el MP4 dentro de la carpeta">
        üé¨ MP4
        <select id="mp4Select">
          <option value="">(elige carpeta primero)</option>
        </select>
      </label>

<label title="Capa base del mapa">
        üó∫Ô∏è Mapa
        <select id="baseMapSelect">

          <option value="osm">OSM (tiles)</option>
          <option value="icgc_topo">ICGC Topo (WMS 3857)</option>
          <option value="icgc_orto">ICGC Orto (WMS 3857)</option>

          <option value="google_road">Google Road (XYZ)</option>
          <option value="google_terrain">Google Terrain (XYZ)</option>
          <option value="google_sat">Google Sat (XYZ)</option>

          <option value="ign_base_todo">IGN BaseTodo (WMS)</option>
          <option value="esri_topo">ESRI World Topo (XYZ)</option>
          <option value="waze">Waze (XYZ)</option>
        

      <optgroup label="Offline (carpeta 'mapas offline')">
        <option value="OFFLINE_ICGC_TOPO">ICGC Topo (offline)</option>
        <option value="OFFLINE_ICGC_ORTO">ICGC Orto (offline)</option>
      </optgroup>
    </select> <span id="offlineHelp" title="Mapas offline ICGC: crea tiles en PC/Mac y copia a la carpeta 'mapas offline' (ver instrucciones al final del HTML).">‚ÑπÔ∏è</span>
      </label>

      <button id="fitBtn" title="Ajustar mapa al track">Ajustar</button>
      <label id="gpsFollowLabel"
            class="checkIcon"
            title="Seguir GPS del dispositivo: al activarlo, mover√° la bici a tu posici√≥n actual y se actualizar√° cada segundo (mapa, v√≠deo, tabla y perfil).">
        <input id="gpsFollowChk" type="checkbox">
        <span class="gpsIcon" aria-hidden="true"></span>
        <span>GPS</span>
      </label>


      <label title="Velocidad de reproducci√≥n">
        ‚è© Velocidad
        <select id="rateSelect">
          <option value="1">1x</option>
          <option value="2">2x</option>
          <option value="8">8x</option>
          <option value="16">16x</option>
        </select>
      </label>

      <label title="Importar KML o KMZ manualmente (opcional)">
        üß© KML/KMZ
        <input id="kmlKmzInput" type="file" accept=".kml,.kmz" hidden>
      </label>

      <label title="Cargar rut√≥metro desde Excel manualmente (opcional)">
        <img alt="Excel" style="height:18px;width:18px;display:block"
             src='data:image/svg+xml;utf8,
             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
               <path fill="%23107C41" d="M19 2H8c-1.1 0-2 .9-2 2v4H4v8h2v4c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 18H8v-4h11v4zm0-6H8V4h11v10z"/>
               <path fill="%23107C41" d="M10.6 17l-1.6-2.6L7.4 17H6l2.4-4L6 9h1.4l1.6 2.6L10.6 9H12l-2.4 4 2.4 4z"/>
             </svg>'/>
        Excel
        <input id="excelInput" type="file" accept=".xlsx" hidden>
      </label>

      

      <span id="status">Esperando carpeta‚Ä¶</span>
    </div>

    <!-- MAIN 2x2 -->
    <div id="main">
      <!-- ZONA 1: VIDEO -->
      <div class="panel" id="videoWrap">
        <div id="hud">‚Äî</div>

        <div id="videoTools">
          <div class="iconBtn" id="btnGoogleMaps" title="Abrir en Google Maps">
            <img alt="Google Maps"
                 src='data:image/svg+xml;utf8,
                 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                   <path fill="white" d="M12 2C8.1 2 5 5.1 5 9c0 5.2 7 13 7 13s7-7.8 7-13c0-3.9-3.1-7-7-7zm0 9.5c-1.4 0-2.5-1.1-2.5-2.5S10.6 6.5 12 6.5s2.5 1.1 2.5 2.5S13.4 11.5 12 11.5z"/>
                 </svg>'/>
          </div>

          <div class="iconBtn" id="btnStreetView" title="Abrir en Street View">
            <img alt="Street View"
                 src='data:image/svg+xml;utf8,
                 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                   <path fill="white" d="M12 2a4 4 0 100 8 4 4 0 000-8zm0 9c-4.4 0-8 2.2-8 5v4h16v-4c0-2.8-3.6-5-8-5z"/>
                 </svg>'/>
          </div>

          <div class="iconBtn" id="btnSnapshot" title="Capturar frame (PNG)">
            <img alt="Snapshot"
                 src='data:image/svg+xml;utf8,
                 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                   <path fill="white" d="M9 2l1.8 2H15l1.8-2H20c1.1 0 2 .9 2 2v16c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h5zm3 6a6 6 0 100 12 6 6 0 000-12zm0 2a4 4 0 110 8 4 4 0 010-8z"/>
                 </svg>'/>
          </div>
        </div>

        <video id="video" controls playsinline></video>
      </div>

      <!-- V splitter -->
      <div id="vSplit" class="splitter"></div>

      <!-- ZONA 2: MAPA -->
      <div class="panel" id="mapPanel">
        <div id="map"></div>
      </div>

      <!-- H splitter -->
      <div id="hSplit" class="splitter"></div>

      <!-- ZONA 3: TABLA -->
      <div class="panel" id="tablePanel">
        <div id="tableWrap">
          <div id="tableHeader">
            <span class="pill" id="rutometreInfo">Rut√≥metro: ‚Äî</span>
            <span class="pill" id="rutometreSyncInfo">Sync: ‚Äî</span>
          </div>

          <div id="rutometreTableContainer">
            <table id="rutometreTable">
              <thead>
                <tr id="rutometreHeaderRow">
                  <th class="col-desc">Describe_Es</th>
                  <th class="td-num">Km_Etapa</th>
                  <th class="td-num">Km_Faltan</th>
                  <th class="td-small">Horario_1</th>
                  <th class="td-small">Horario_2</th>
                  <th class="td-small">Horario_3</th>
                  <th class="td-small">codi picto</th>
                  <th class="td-small">Coordenada_X</th>
                  <th class="td-small">Coordenada_Y</th>
                  <th class="td-small">Coordenades_GPS</th>
                </tr>
              </thead>
              <tbody id="rutometreTbody">
                <tr><td colspan="10" style="padding:10px;opacity:.7;">Carga el Excel para ver el rut√≥metro‚Ä¶</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- ZONA 4: PERFIL -->
      <div class="panel" id="profilePanel">
        <div id="profileWrap">
          <canvas id="elevCanvas"></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- LIBS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://unpkg.com/@tmcw/togeojson@5.8.1/dist/togeojson.umd.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <script>
  /* ============================================================
     UI / HELPERS
     ============================================================ */
  const dirInput      = document.getElementById("dirInput");
  const mp4Select     = document.getElementById("mp4Select");
  const baseMapSelect = document.getElementById("baseMapSelect");
  const fitBtn        = document.getElementById("fitBtn");
  const rateSelect    = document.getElementById("rateSelect");
  const statusEl      = document.getElementById("status");
  const raceNameEl   = document.getElementById("raceName");

  const kmlKmzInput   = document.getElementById("kmlKmzInput");
  const excelInput    = document.getElementById("excelInput");

  const video         = document.getElementById("video");
  const hud           = document.getElementById("hud");

  // Evita romper si en esta versi√≥n no existe resetVideoSync()
  function maybeResetVideoSync(){
    if (typeof resetVideoSync === "function") resetVideoSync();
  }


  const elevCanvas    = document.getElementById("elevCanvas");
  const ctx           = elevCanvas.getContext("2d");

  const btnGoogleMaps = document.getElementById("btnGoogleMaps");
  const btnStreetView = document.getElementById("btnStreetView");
  const btnSnapshot   = document.getElementById("btnSnapshot");

  const rutometreTbody     = document.getElementById("rutometreTbody");
  const rutometreInfo      = document.getElementById("rutometreInfo");
  const rutometreSyncInfo  = document.getElementById("rutometreSyncInfo");
  const rutometreTableContainer = document.getElementById("rutometreTableContainer");

  const mainEl        = document.getElementById("main");
  const vSplit        = document.getElementById("vSplit");
  const hSplit        = document.getElementById("hSplit");

  // ============================================================
  // CARRERA CONFIG (data/carrera.js) - compatible file://
  // ============================================================
  window.carreraVideoOrder = null;

  (function loadCarreraConfig(){
    const script = document.createElement("script");
    script.src = "data/carrera.js";
    script.defer = true;

    script.onload = () => {
      const cfg = window.CARRERA_CONFIG;
      if (!cfg) return;

      if (cfg.nombre){
        const nameEl = document.querySelector("#appHeader .appName");
        if (nameEl) nameEl.textContent = cfg.nombre;
        document.title = cfg.nombre;
      }

      if (cfg.logo){
        const logoEl = document.querySelector("#appHeader img");
        if (logoEl) logoEl.src = "data/" + cfg.logo;
      }

      if (Array.isArray(cfg.videos)){
        window.carreraVideoOrder = cfg.videos
          .map(v => String(v || "").trim().toLowerCase())
          .filter(Boolean);
      }
    };

    script.onerror = () => {};
    document.head.appendChild(script);
  })();


  function setStatus(msg){ statusEl.textContent = msg; }

    function normKey(s){
    return String(s ?? "")
      .trim()
      .toLowerCase()
      .replace(/\s+/g, "_")
      .replace(/[^\w]/g, "_");
  }

  function getField(obj, wanted){
    if (!obj) return "";
    const w = normKey(wanted);
    if (Object.prototype.hasOwnProperty.call(obj, wanted)) return obj[wanted];
    const keys = Object.keys(obj);
    for (const k of keys){
      if (normKey(k) === w) return obj[k];
    }
    return "";
  }

  function fmtMaybe(x){
    if (x === null || x === undefined) return "";
    return String(x).trim();
  }

  function setNeutralizedKmOffset(v){
    const n = parseFloat(String(v ?? "").replace(",", "."));
    neutralizedKmOffset = Number.isFinite(n) ? n : 0;
  }

  function updateRaceHeaderFromExcel(){
    if (!stageHeader) return false;

    const codi = fmtMaybe(getField(stageHeader, "Codi_Num_Etapa"));
    const nom  = fmtMaybe(getField(stageHeader, "Nom_Etapa"));
    const km   = fmtMaybe(getField(stageHeader, "km"));
    const nkm  = fmtMaybe(getField(stageHeader, "Sortida_Neutralitzada_Km"));
    const nh   = fmtMaybe(getField(stageHeader, "Sortida_Neutralitzada_Hora"));
    const rh   = fmtMaybe(getField(stageHeader, "Sortida_Real_Hora"));
    const vel  = fmtMaybe(getField(stageHeader, "Velocitat_2"));

    const anyData = [codi, nom, km, nkm, nh, rh, vel].some(x => String(x||'').trim() !== '');
    if (!anyData) return false;

    const el = (raceNameEl || document.getElementById("raceName"));
    el.textContent =
      `Carrera: ${codi}¬™ Etapa - ${nom} (${km}km) - (Neutralizada: ${nkm}) - ` +
      `Salida: ${nh} / ${rh} - Promedio Previsto: ${vel}km/h`;

    return true;
  }

  function neutralizedOffsetEffectiveKm(){
    const off = (typeof neutralizedKmOffset === "number") ? neutralizedKmOffset : 0;
    return neutralizedKmHandledByGpx ? 0 : off;
  }

  function adjustedDistKm(meters){
    const km = (meters || 0) / 1000;
    return km - neutralizedOffsetEffectiveKm();
  }

  function adjustedDistMeters(meters){
    return (meters || 0) - neutralizedOffsetEffectiveKm() * 1000;
  }



  const controlsEl    = document.getElementById("controls");
  const toggleOpsBtn  = document.getElementById("toggleOpsBtn");
  const toggleOpsIcon = document.getElementById("toggleOpsIcon");

  if (toggleOpsBtn && controlsEl){
      toggleOpsBtn.addEventListener("click", () => {
      controlsEl.classList.toggle("collapsed");
      toggleOpsIcon.textContent = controlsEl.classList.contains("collapsed") ? "‚ñ∏" : "‚ñæ";

      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          try{ map.invalidateSize(false); }catch(_){}
          drawElevationProfile(video.currentTime);
        });
      });
    });
  }
  // ============================================================
  // HELP (external i18n file: help_i18n.json)
  // ============================================================
  const helpBtn        = document.getElementById("helpBtn");
  const helpDialog     = document.getElementById("helpDialog");
  const helpBody       = document.getElementById("helpBody");
  const helpTitleEl    = document.getElementById("helpTitle");
  const helpLangSelect = document.getElementById("helpLangSelect");
  const closeHelpBtn   = document.getElementById("closeHelpBtn");

  let helpData = null;

  function normLang(lang){
    const l = String(lang || "").toLowerCase();
    if (l.startsWith("ca")) return "ca";
    if (l.startsWith("es")) return "es";
    if (l.startsWith("fr")) return "fr";
    if (l.startsWith("en")) return "en";
    return "es";
  }

  function escapeHtml2(str){
    return String(str)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;");
  }

  function openHelp(){
    if (!helpDialog) return;
    helpDialog.style.display = "flex";
    // focus the close button for accessibility
    setTimeout(() => { try{ closeHelpBtn?.focus(); }catch(_){ } }, 0);
  }

  function closeHelp(){
    if (!helpDialog) return;
    helpDialog.style.display = "none";
    try{ helpBtn?.focus(); }catch(_){}
  }

  function renderHelp(lang){
    if (!helpBody) return;
    if (!helpData){
      helpBody.innerHTML = '<div class="helpLoading">Cargando ayuda‚Ä¶</div>';
      return;
    }

    const pack = helpData[lang] || helpData.es || Object.values(helpData)[0];
    if (!pack){
      helpBody.innerHTML = '<div class="helpLoading">No se ha podido cargar la ayuda.</div>';
      return;
    }

    helpTitleEl.textContent = pack.title || "Ayuda";

    const sections = Array.isArray(pack.sections) ? pack.sections : [];
    let html = "";

    for (const s of sections){
      html += '<section class="helpSection">';
      if (s.h) html += `<h4>${escapeHtml2(s.h)}</h4>`;
      if (Array.isArray(s.items) && s.items.length){
        html += "<ol>";
        for (const it of s.items){
          html += `<li>${escapeHtml2(it)
            .replaceAll("[", "<span class=\"kbd\">")
            .replaceAll("]", "</span>")}</li>`;
        }
        html += "</ol>";
      }
      if (s.tip){
        html += `<div class="tip">${escapeHtml2(s.tip)
          .replaceAll("[", "<span class=\"kbd\">")
          .replaceAll("]", "</span>")}</div>`;
      }
      html += "</section>";
    }

    helpBody.innerHTML = html || '<div class="helpLoading">Sin contenido.</div>';
  }

  async function loadHelpOnce(){
    if (helpData) return helpData;

    // 1) Prefer external JS-loaded data for file:// compatibility
    if (window.HELP_I18N){
      helpData = window.HELP_I18N;
      return helpData;
    }

    // 2) Try fetching JSON (works when served over http/https)
    try{
      const res = await fetch("help_i18n.json", { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      helpData = await res.json();
      return helpData;
    }catch(err){
      console.warn("No se pudo cargar help_i18n.json (¬øabierto como file://?). Usando fallback si existe help_i18n.js.", err);
      helpData = window.HELP_I18N || null;
      return helpData;
    }
  }

  if (helpLangSelect){
    const saved = localStorage.getItem("vrm_help_lang");
    const initial = normLang(saved || document.documentElement.lang || navigator.language);
    helpLangSelect.value = initial;
  }

  if (helpBtn && helpDialog){
    helpBtn.addEventListener("click", async () => {
      openHelp();
      await loadHelpOnce();
      const lang = helpLangSelect ? normLang(helpLangSelect.value) : "es";
      renderHelp(lang);
    });
  }

  if (helpLangSelect){
    helpLangSelect.addEventListener("change", async () => {
      const lang = normLang(helpLangSelect.value);
      localStorage.setItem("vrm_help_lang", lang);
      await loadHelpOnce();
      renderHelp(lang);
    });
  }

  closeHelpBtn?.addEventListener("click", closeHelp);

  // close on backdrop click
  helpDialog?.addEventListener("click", (e) => {
    if (e.target === helpDialog) closeHelp();
  });

  // close on Escape
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && helpDialog && helpDialog.style.display === "flex"){
      closeHelp();
    }
  });





  function basenameNoExt(name){ return name.replace(/\.[^.]+$/, ""); }
  function pad2(n){ return String(n).padStart(2,"0"); }
  function fmtTimeHMS(seconds){
    if (!Number.isFinite(seconds)) return "‚Äî";
    seconds = Math.max(0, seconds);
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);
    return `${h}:${pad2(m)}:${pad2(s)}`;
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function escapeHtml(str){
    return String(str)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;");
  }
  function readFileAsText(file){
    return new Promise((resolve, reject) => {
      const r = new FileReader();
      r.onload = () => resolve(String(r.result));
      r.onerror = reject;
      r.readAsText(file);
    });
  }

  // ============================================================
  // MP4: embedded GPS (Dashcam_App.js) support
  // Looks for a JSON blob appended at the end of the MP4:
  //   GPXMETADATA:{ ... "track":[{lat,lon,ele,time,...}, ...] }
  // If present, we build VRM "points" from it and use it instead of the GPX file.
  // ============================================================
  async function extractEmbeddedGpsFromMp4(file){
    try{
      if (!file || !Number.isFinite(file.size) || file.size <= 0) return null;

      // Read only the tail to avoid loading the whole MP4 into memory.
      const TAIL_BYTES = 512 * 1024; // 512 KB
      const start = Math.max(0, file.size - TAIL_BYTES);
      const ab = await file.slice(start, file.size).arrayBuffer();

      // The payload is ASCII/UTF-8 JSON; decoding the tail is enough.
      const txt = new TextDecoder("utf-8", { fatal:false }).decode(ab);

      const marker = "GPXMETADATA:";
      const idx = txt.lastIndexOf(marker);
      if (idx === -1) return null;

      const jsonStart = txt.indexOf("{", idx + marker.length);
      if (jsonStart === -1) return null;

      // The JSON ends at the last closing brace in the tail.
      const jsonEnd = txt.lastIndexOf("}");
      if (jsonEnd === -1 || jsonEnd <= jsonStart) return null;

      const jsonStr = txt.slice(jsonStart, jsonEnd + 1).trim();
      const meta = JSON.parse(jsonStr);

      if (!meta || !Array.isArray(meta.track) || !meta.track.length) return null;

      const pts = meta.track.map(p => {
        const lat = +p.lat, lon = +p.lon;
        const tAbs = +p.time;
        const ele = (p.ele === null || p.ele === undefined || p.ele === "") ? null : +p.ele;
        if (!Number.isFinite(lat) || !Number.isFinite(lon) || !Number.isFinite(tAbs)) return null;
        return { lat, lon, ele: (Number.isFinite(ele) ? ele : null), tAbs, tOffset:0, dist:0 };
      }).filter(Boolean);

      pts.sort((a,b)=>a.tAbs - b.tAbs);
      if (!pts.length) return null;

      return { meta, points: pts };
    } catch(e){
      console.warn("No se pudo leer GPS embebido del MP4:", e);
      return null;
    }
  }

  function haversineMeters(a, b){
    const R = 6371000;
    const toRad = x => x * Math.PI / 180;
    const dLat = toRad(b.lat - a.lat);
    const dLon = toRad(b.lon - a.lon);
    const s1 = Math.sin(dLat/2), s2 = Math.sin(dLon/2);
    const q = s1*s1 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2;
    return 2 * R * Math.asin(Math.sqrt(q));
  }
  function computeBearingDeg(a, b){
    const toRad = x => x * Math.PI/180;
    const toDeg = x => x * 180/Math.PI;
    const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
    const dLon = toRad(b.lon - a.lon);
    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
    let brng = toDeg(Math.atan2(y, x));
    return (brng + 360) % 360;
  }

  /* ============================================================
     MAP
     ============================================================ */
  const map = L.map("map", { zoomControl:true }).setView([0,0], 2);

      
  // ============================================================
  // Basemap helper (XYZ)
  // ============================================================
  function setBasemapXYZ(urlTemplate, options){
    try{
      if (window._vrmBaseLayer){
        map.removeLayer(window._vrmBaseLayer);
      }
    }catch(e){}
    window._vrmBaseLayer = L.tileLayer(urlTemplate, options || {});
    window._vrmBaseLayer.addTo(map);
  }
const baseLayers = {
    // OpenStreetMap
    osm: L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "¬© OpenStreetMap",
      maxZoom: 19
    }),

    // ICGC / ICGC BaseMap (WMS) - EPSG:3857 (recommended)
    icgc_topo: L.tileLayer.wms("https://geoserveis.icgc.cat/icc_mapesmultibase/noutm/wms/service", {
      layers: "topo",
      format: "image/png",
      transparent: false,
      attribution: "ICGC BaseMap topo (WMS)",
      uppercase: true
    }),
    icgc_orto: L.tileLayer.wms("https://geoserveis.icgc.cat/icc_mapesmultibase/noutm/wms/service", {
      layers: "orto",
      format: "image/jpeg",
      transparent: false,
      attribution: "ICGC BaseMap orto (WMS)",
      uppercase: true
    }),

    // Google (unofficial tiles; may be rate-limited)
    google_road: L.tileLayer("https://mt1.google.com/vt/lyrs=r&x={x}&y={y}&z={z}", {
      attribution: "¬© Google",
      maxZoom: 20
    }),
    google_terrain: L.tileLayer("https://mt1.google.com/vt/lyrs=p&x={x}&y={y}&z={z}", {
      attribution: "¬© Google",
      maxZoom: 20
    }),
    google_sat: L.tileLayer("https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}", {
      attribution: "¬© Google",
      maxZoom: 20
    }),

    // IGN Espa√±a
    ign_base_todo: L.tileLayer.wms("https://www.ign.es/wms-inspire/ign-base", {
      layers: "IGNBaseTodo",
      format: "image/png",
      transparent: false,
      attribution: "IGN (WMS)"
    }),

    // ESRI
    esri_topo: L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}", {
      attribution: "¬© Esri",
      maxZoom: 18
    }),

    // Waze (unofficial tiles; availability may change)
    waze: L.tileLayer("https://worldtiles3.waze.com/tiles/{z}/{x}/{y}.png", {
      attribution: "¬© Waze",
      maxZoom: 20
    }),
    
    OFFLINE_ICGC_TOPO:  L.tileLayer("./mapas%20offline/icgc_topo/{z}/{x}/{y}.png", { maxZoom: 19 }),
    
    OFFLINE_ICGC_ORTO: L.tileLayer("./mapas%20offline/icgc_orto/{z}/{x}/{y}.jpg", { maxZoom: 19 })

  };

  let currentBaseLayer = baseLayers.osm;

  
  currentBaseLayer.addTo(map);

  

  // Red dot icon (HTML) to ensure visibility in all browsers
  let redDotIcon = L.divIcon({
    className: "red-dot-icon",
    html: '<div class="dot"></div>',
    iconSize: [14,14],
    iconAnchor: [7,7]
  });


      
  // Bike icon for current video position (animated cyclist with rider)
  const bikeIcon = L.divIcon({
    className: "",
    html:
      '<div class="bike-marker" aria-hidden="true">' +
        "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><g fill='none' stroke='#1f3a8a' stroke-width='2'><circle class='wheel-anim' cx='18' cy='46' r='9'/><circle class='wheel-anim' cx='46' cy='46' r='9'/></g><g fill='none' stroke='#16a34a' stroke-width='2.2' stroke-linecap='round' stroke-linejoin='round'><path d='M18 46l10-16 12 0 6 16' /><path d='M28 30l6 16' /><path d='M40 30l-6 0' /></g><g class='crank' fill='none' stroke='#111' stroke-width='2'><circle cx='32' cy='46' r='2' fill='#111'/><path d='M32 46l6 4' /><path d='M32 46l-6 -4' /></g><g fill='none' stroke='#111' stroke-width='2' stroke-linecap='round'><circle cx='30' cy='22' r='3' fill='#111'/><path d='M30 25l2 5' /><path d='M32 30l4 6' /><path d='M32 30l-6 6' /><path d='M30 25l-6 4' /></g></svg>" +
      '</div>',
    iconSize: [36,36],
    iconAnchor: [18,18]
  });

baseMapSelect.addEventListener("change", () => {
    const key = baseMapSelect.value;
    if (!baseLayers[key]) return;
    if (currentBaseLayer) map.removeLayer(currentBaseLayer);
    currentBaseLayer = baseLayers[key];
    currentBaseLayer.addTo(map);
    setStatus(`Mapa base: ${baseMapSelect.options[baseMapSelect.selectedIndex].text}`);
  });

  /* ============================================================
     FILE INDEX (folder) + AUTOLOAD per video basename
     ============================================================ */
  const mp4Files = new Map();   // filename -> File
  const gpxFiles = new Map();   // base -> File
  const kmzFiles = new Map();   // base -> File (.kmz)
  const kmlFiles = new Map();   // base -> File (.kml)
  const xlsxFiles= new Map();   // base -> File (.xlsx)

  /* ============================================================
     TRACK / VIDEO STATE
     ============================================================ */
  let overlayLayer = null;

  let points = [];
  let visualTracks = []; // [{name,color,segments:[[ [lat,lon],... ], ...]}] from GPX (trk/trkseg)
  let firstAbsTime = null;
  let hasEle = false;

  let polyline = null;
  let marker = null;
  let lastCenterTs = 0;
  let lastSeekTs = 0;
  let lastBearingDeg = 0;

  /* ============================================================
     RUT√ìMETRO STATE
     ============================================================ */
  let rutometreRows = [];
  let rutometreWpts = [];  // [{rowIndex, tOffset, dist, Describe_Es}]
  let stageHeader = null;
  let neutralizedKmOffset = 0; // km to subtract from track distance (neutralized segment)
  let activeRutometreIndex = -1;
  let neutralizedKmHandledByGpx = false; // si el GPX ya separa el tramo neutralizado



  // ===== LIVE GPS FOLLOW =====
  let liveGpsWatchId = null;
  let liveGpsTimerId = null;
  let lastGpsFix = null;

  function stopLiveGps(){
    if (liveGpsTimerId){
      clearInterval(liveGpsTimerId);
      liveGpsTimerId = null;
    }
    if (liveGpsWatchId !== null && navigator.geolocation){
      try { navigator.geolocation.clearWatch(liveGpsWatchId); } catch(e) {}
      liveGpsWatchId = null;
    }
    lastGpsFix = null;
  }

  function startLiveGps(){
    if (!navigator.geolocation){
      setStatus("GPS no disponible en este navegador");
      return;
    }

    // Primer fix ‚Üí pide permiso
    navigator.geolocation.getCurrentPosition(
      (pos) => { lastGpsFix = pos; },
      (err) => {
        console.warn(err);
        setStatus("No se pudo acceder al GPS");
        stopLiveGps();
        gpsFollowChk.checked = false;
      },
      { enableHighAccuracy:true, timeout: 12000, maximumAge: 0 }
    );

    // Lectura continua
    liveGpsWatchId = navigator.geolocation.watchPosition(
      (pos) => { lastGpsFix = pos; },
      (err) => { console.warn(err); },
      { enableHighAccuracy:true, maximumAge: 0, timeout: 20000 }
    );

    // Cada segundo ‚Üí mover bici + sincronizar TODO
    liveGpsTimerId = setInterval(() => {
      if (!lastGpsFix) return;

      const lat = lastGpsFix.coords.latitude;
      const lon = lastGpsFix.coords.longitude;
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;

      // ===== Caso 1: HAY GPX ‚Üí snap al track y sincroniza todo (como antes)
      if (points.length){
        if (!marker) return; // el marker lo crea drawTrack()
        const p = nearestPoint(lat, lon);
        if (!p) return;

        syncToPoint(p, { seekVideo:true, centerMap:true, redrawProfile:true });
        return;
      }

      // ===== Caso 2: NO hay GPX ‚Üí modo GPS libre (solo bici+mapa)
      if (!marker){
        // crea marker temporal si no existe (usa el mismo icono de bici)
        marker = L.marker([lat, lon], {
          icon: bikeIcon,
          interactive: false,
          keyboard: false,
          zIndexOffset: 1000
        }).addTo(map);

        try { marker.setZIndexOffset(1000); } catch(_) {}
      } else {
        marker.setLatLng([lat, lon]);
      }

      // centra el mapa (sin animaci√≥n)
      map.panTo([lat, lon], { animate:false });

      // HUD m√≠nimo (sin tocar v√≠deo/perfil/rut√≥metro)
      hud.textContent = `GPS libre ¬∑ lat=${lat.toFixed(5)} lon=${lon.toFixed(5)}`;

    }, 1000);
  }

  function fileFromBase64(name, mime, b64){
    const bin = atob(b64);
    const len = bin.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++){
      bytes[i] = bin.charCodeAt(i);
    }
    return new File([bytes], name, { type: mime || "application/octet-stream" });
  }



  /* ============================================================
     GPX
     ============================================================ */
  
  function gpxDisplayColorToHex(name){
  const n = String(name||"").trim().toLowerCase();
  const map = {
    black:"#000000", darkgray:"#444444", darkgrey:"#444444", gray:"#808080", grey:"#808080",
    white:"#ffffff",
    red:"#e53935", darkred:"#b71c1c",
    green:"#43a047", darkgreen:"#1b5e20",
    blue:"#1e88e5", darkblue:"#0d47a1",
    cyan:"#00bcd4",
    magenta:"#e91e63",
    yellow:"#fdd835",
    orange:"#fb8c00",
    purple:"#8e24aa",
    brown:"#6d4c41"
  };
  return map[n] || null;
}

function parseGpx(xmlText){
  const xml = new DOMParser().parseFromString(xmlText, "application/xml");

  // Reset visual tracks
  visualTracks = [];

  // Get tracks (<trk>) and segments (<trkseg>) preserving order
  let trks = Array.from(xml.getElementsByTagNameNS("*", "trk"));
  if (!trks.length) trks = Array.from(xml.getElementsByTagName("trk"));

  const out = [];
  let firstPoint = true;

  for (const trk of trks){
    // Track name (optional)
    let nameNode = trk.getElementsByTagNameNS("*","name")[0];
    if (!nameNode) nameNode = trk.getElementsByTagName("name")[0];
    const trkName = nameNode ? (nameNode.textContent||"").trim() : "";

    // Garmin DisplayColor inside gpxx:TrackExtension
    let colorNode = trk.getElementsByTagNameNS("*","DisplayColor")[0];
    if (!colorNode) colorNode = trk.getElementsByTagName("gpxx:DisplayColor")[0];
    const trkColor = gpxDisplayColorToHex(colorNode ? colorNode.textContent : null) || "blue";

    // Segments
    let segs = Array.from(trk.getElementsByTagNameNS("*","trkseg"));
    if (!segs.length) segs = Array.from(trk.getElementsByTagName("trkseg"));

    const trkVis = { name: trkName || "Track", color: trkColor, segments: [] };

    for (const seg of segs){
      let pts = Array.from(seg.getElementsByTagNameNS("*","trkpt"));
      if (!pts.length) pts = Array.from(seg.getElementsByTagName("trkpt"));

      const segLatLngs = [];

      let segFirst = true;
      for (const pt of pts){
        const latAttr = pt.getAttribute("lat");
        const lonAttr = pt.getAttribute("lon");
        const lat = latAttr != null ? +latAttr : NaN;
        const lon = lonAttr != null ? +lonAttr : NaN;

        let tNode = pt.getElementsByTagNameNS("*", "time")[0];
        if (!tNode) tNode = pt.getElementsByTagName("time")[0];
        if (!tNode || !tNode.textContent) continue;

        let eleNode = pt.getElementsByTagNameNS("*", "ele")[0];
        if (!eleNode) eleNode = pt.getElementsByTagName("ele")[0];
        const ele = (eleNode && eleNode.textContent !== "") ? +eleNode.textContent : null;

        const t = new Date(tNode.textContent.trim());
        if (!Number.isFinite(t.getTime())) continue;
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;

        const p = { lat, lon, ele, tAbs: t.getTime(), tOffset:0, dist:0 };

        // Mark segment breaks so we DON'T draw a straight line across segments/tracks
        if (!firstPoint && segFirst){
          p.break = true; // used in distance calc + drawing
        }

        out.push(p);
        segLatLngs.push([lat, lon]);

        firstPoint = false;
        segFirst = false;
      }

      if (segLatLngs.length) trkVis.segments.push(segLatLngs);
    }

    if (trkVis.segments.length) visualTracks.push(trkVis);
  }

  // If GPX has no <trk> (rare), fall back to all <trkpt> flat
  if (!out.length){
    let trkpts = Array.from(xml.getElementsByTagNameNS("*", "trkpt"));
    if (!trkpts.length) trkpts = Array.from(xml.getElementsByTagName("trkpt"));

    for (const pt of trkpts){
      const latAttr = pt.getAttribute("lat");
      const lonAttr = pt.getAttribute("lon");
      const lat = latAttr != null ? +latAttr : NaN;
      const lon = lonAttr != null ? +lonAttr : NaN;

      let tNode = pt.getElementsByTagNameNS("*", "time")[0];
      if (!tNode) tNode = pt.getElementsByTagName("time")[0];
      if (!tNode || !tNode.textContent) continue;

      let eleNode = pt.getElementsByTagNameNS("*", "ele")[0];
      if (!eleNode) eleNode = pt.getElementsByTagName("ele")[0];
      const ele = (eleNode && eleNode.textContent !== "") ? +eleNode.textContent : null;

      const t = new Date(tNode.textContent.trim());
      if (!Number.isFinite(t.getTime())) continue;
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;

      out.push({ lat, lon, ele, tAbs: t.getTime(), tOffset:0, dist:0 });
    }

    if (out.length){
      visualTracks = [{ name:"Track", color:"blue", segments:[ out.map(p=>[p.lat,p.lon]) ] }];
    }
  }

  // Ensure time order (Garmin is already ordered); keep stable if equal
  out.sort((a,b)=>a.tAbs - b.tAbs);

  // NOTE: sorting may move break markers slightly, but for Garmin exports it's safe.
  // If you ever import mixed-order tracks, distance will still be safe across breaks.

  return out;
}


  function computeOffsetsAndDist(){
    if (!points.length) return;

    for (const p of points){
      p.tOffset = (p.tAbs - firstAbsTime) / 1000;
    }

    // Distancia absoluta (para perfil/orden) y distancia por tramo (contador que se reinicia)
    let dAbs = 0;
    let dSeg = 0;
    let segId = 0;

    points[0].distAbs = 0;
    points[0].distSeg = 0;
    points[0].segId = 0;
    points[0].dist = 0; // compat: dist = distancia absoluta

    for (let i=1;i<points.length;i++){
      // Si este punto marca inicio de un nuevo tramo, reiniciamos el contador del tramo
      if (points[i].break){
        segId += 1;
        dSeg = 0;
      } else {
        const inc = haversineMeters(points[i-1], points[i]);
        dAbs += inc;
        dSeg += inc;
      }

      points[i].segId = segId;
      points[i].distAbs = dAbs;
      points[i].distSeg = dSeg;

      // compat: dist se usa en varias rutinas como "distancia para ordenar/perfil"
      points[i].dist = dAbs;
    }

    hasEle = points.some(p => Number.isFinite(p.ele));
  }

  function detectNeutralizedSegmentInGpx(){
    // Reset
    neutralizedKmHandledByGpx = false;

    // Solo aplica si Excel tiene km neutralizada
    const off = (typeof neutralizedKmOffset === "number") ? neutralizedKmOffset : 0;
    if (!points.length || off <= 0) return;

    // 1) Garmin t√≠pico: tramo neutralizado como OTRO <trk> con name "Neutra"
    // parseGpx() ya rellena visualTracks con {name,color,segments:[]}
    if (Array.isArray(visualTracks) && visualTracks.length){
      const re = /\b(neutra|neutral|neutraliz|neutralizad|neutralized)\b/i;
      const hasNeutralTrack = visualTracks.some(t => re.test(String(t?.name || "")));
      if (hasNeutralTrack){
        neutralizedKmHandledByGpx = true;
        return;
      }
    }

    // 2) Fallback (tu l√≥gica anterior): por segmentos y distancia del primer tramo
    //    √ötil cuando no hay nombre pero s√≠ separaci√≥n por trkseg.
    const maxSegId = Math.max(...points.map(p => p.segId ?? 0));
    if (maxSegId < 1) return;

    let seg0MaxMeters = 0;
    for (const p of points){
      if ((p.segId ?? 0) === 0){
        const d = (p.distSeg ?? 0);
        if (d > seg0MaxMeters) seg0MaxMeters = d;
      }
    }

    const seg0Km = seg0MaxMeters / 1000;
    const tol = Math.max(0.25, off * 0.10);

    if (Math.abs(seg0Km - off) <= tol){
      neutralizedKmHandledByGpx = true;
    }
  }


  function clearTrack(){
    stopLiveGps();
    if (polyline) map.removeLayer(polyline);
    if (marker) map.removeLayer(marker);
    polyline = null;
    marker = null;

    points = [];
    visualTracks = [];
    firstAbsTime = null;
    hasEle = false;

    drawElevationProfile(null);
    hud.textContent = "‚Äî";
    lastBearingDeg = 0;

    rutometreWpts = [];
    activeRutometreIndex = -1;
    updateRutometreActive(-1);
  }

  function clearOverlay(){
    if (overlayLayer){
      map.removeLayer(overlayLayer);
      overlayLayer = null;
    }
  }

  function clearRutometre(){
    rutometreRows = [];
    rutometreWpts = [];
    activeRutometreIndex = -1;
    rutometreInfo.textContent = "Rut√≥metro: ‚Äî";
    rutometreSyncInfo.textContent = "Sync: ‚Äî";
    rutometreTbody.innerHTML = `<tr><td colspan="10" style="padding:10px;opacity:.7;">Carga el Excel para ver el rut√≥metro‚Ä¶</td></tr>`;
  }

  function drawTrack(){
    computeOffsetsAndDist();
    detectNeutralizedSegmentInGpx();


    // Remove previous polylines
    if (polyline){
      try { map.removeLayer(polyline); } catch(_) {}
      polyline = null;
    }

    // Build colored multi-segment polylines from GPX tracks (if any)
    const layers = [];
    const clickHandler = (e) => {
      const p = nearestPoint(e.latlng.lat, e.latlng.lng);
      if (p) syncToPoint(p, { seekVideo:true, centerMap:true, redrawProfile:true });
    };

    if (visualTracks && visualTracks.length){
      for (const trk of visualTracks){
        const color = trk.color || "blue";
        for (const seg of (trk.segments || [])){
          if (!seg || seg.length < 2) continue;
          const pl = L.polyline(seg, { color, weight:4, opacity:0.95 });
          pl.on("click", clickHandler);
          layers.push(pl);
        }
      }
    } else {
      // Fallback
      const pl = L.polyline(points.map(p => [p.lat, p.lon]), { color:"blue", weight:4 });
      pl.on("click", clickHandler);
      layers.push(pl);
    }

    // Group reference (for clearTrack compatibility)
    polyline = L.featureGroup(layers).addTo(map);

    if (polyline && polyline.bringToBack) polyline.bringToBack();

    marker = L.marker([points[0].lat, points[0].lon], {
      icon: bikeIcon,
      interactive: false,
      keyboard: false,
      zIndexOffset: 1000
    }).addTo(map);

    // keep marker above everything
    try { marker.setZIndexOffset(1000); } catch(_) {}

    // Fit bounds safely
    try {
      const b = polyline.getBounds();
      if (b && b.isValid && b.isValid()) map.fitBounds(b, { padding:[20,20] });
    } catch(_) {}

    enableMarkerDragScrub();

    computeRutometreSync();
    drawElevationProfile(0);
  }

  function nearestPoint(lat, lon){
    let best=null, bestDist=Infinity;
    for (const p of points){
      const d = (p.lat-lat)**2 + (p.lon-lon)**2;
      if (d < bestDist){ bestDist=d; best=p; }
    }
    return best;
  }

  function pointAtTime(t){
    let p = points[0];
    for (const q of points){
      if (q.tOffset <= t) p = q;
      else break;
    }
    return p;
  }

  function findPointIndex(p){
    for (let i=0;i<points.length;i++) if (points[i] === p) return i;
    return -1;
  }

  async function safeSeek(targetTime){
    if (!Number.isFinite(targetTime)) return;

    const now = performance.now();
    if (now - lastSeekTs < 35) return;
    lastSeekTs = now;

    targetTime = Math.max(0, targetTime);
    if (Math.abs(video.currentTime - targetTime) < 0.04) return;

    video.currentTime = targetTime;

    if (typeof video.requestVideoFrameCallback === "function"){
      await new Promise(resolve => video.requestVideoFrameCallback(() => resolve()));
    } else {
      await new Promise(resolve => {
        const onSeeked = () => { video.removeEventListener("seeked", onSeeked); resolve(); };
        video.addEventListener("seeked", onSeeked, { once:true });
      });
    }

    drawElevationProfile(video.currentTime);

    if (rutometreWpts.length){
      updateRutometreActive(rutometreActiveIndexForTime(video.currentTime));
    }
  }

  function syncToPoint(p, opts){
    const { seekVideo=false, centerMap=true, redrawProfile=true } = (opts||{});
    if (!p || !marker) return;

    marker.setLatLng([p.lat, p.lon]);

    
    if (marker && marker.bringToFront) marker.bringToFront();
const idx = findPointIndex(p);
    if (idx !== -1){
      const a = points[Math.max(0, idx-1)];
      const b = points[Math.min(points.length-1, idx+1)];
      if (a && b && a !== b) lastBearingDeg = computeBearingDeg(a, b);
    }

    if (centerMap){
      const now = performance.now();
      if (now - lastCenterTs > 60){
        lastCenterTs = now;
        map.panTo([p.lat, p.lon], { animate:false });
      }
    }

    if (seekVideo) safeSeek(p.tOffset);
    if (redrawProfile) drawElevationProfile(video.currentTime);

    const distKm = adjustedDistKm((p.distSeg ?? p.dist) || 0);
    hud.classList.toggle('km-negative', distKm < 0);
    const negFlag = distKm < 0 ? `<span class="km-neg-flag">N</span>` : ``;
    hud.innerHTML = `t=${fmtTimeHMS(p.tOffset)} ¬∑ ${negFlag}${distKm.toFixed(2)} km ¬∑ lat=${p.lat.toFixed(5)} lon=${p.lon.toFixed(5)}`;

    if (rutometreWpts.length){
      updateRutometreActive(rutometreActiveIndexForTime(video.currentTime));
    }
  }

  /* ============================================================
     VIDEO EVENTS
     ============================================================ */
  rateSelect.addEventListener("change", () => {
    const r = +rateSelect.value;
    video.playbackRate = r;
    setStatus(`Velocidad: ${r}x`);
  });
  video.playbackRate = +rateSelect.value;

  video.addEventListener("loadedmetadata", () => {
    video.playbackRate = +rateSelect.value;
  });

  video.addEventListener("timeupdate", () => {
    if (!points.length) return;
    const p = pointAtTime(video.currentTime);
    syncToPoint(p, { seekVideo:false, centerMap:true, redrawProfile:true });
  });

  video.addEventListener("wheel", (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    const step = (delta > 0) ? +1 : -1;
    video.currentTime = Math.max(0, video.currentTime + step);
  }, { passive:false });

  video.addEventListener("click", () => video.focus());
  document.addEventListener("keydown", (e) => {
    if (document.activeElement !== video) return;
    if (e.key === "ArrowLeft"){
      e.preventDefault();
      video.currentTime = Math.max(0, video.currentTime - 1);
    } else if (e.key === "ArrowRight"){
      e.preventDefault();
      video.currentTime = Math.max(0, video.currentTime + 1);
    }
  });

  /* ============================================================
     MAP EVENTS
     ============================================================ */
  map.on("click", (e) => {
    if (!points.length) return;
    const p = nearestPoint(e.latlng.lat, e.latlng.lng);
    if (p) syncToPoint(p, { seekVideo:true, centerMap:true, redrawProfile:true });
  });

  fitBtn.addEventListener("click", () => {
    if (polyline) map.fitBounds(polyline.getBounds(), { padding:[20,20] });
  });

  function enableMarkerDragScrub(){
    let dragging = false;

    function distPx(a,b){
      const pa = map.latLngToContainerPoint(a);
      const pb = map.latLngToContainerPoint(b);
      return pa.distanceTo(pb);
    }

    map.on("mousedown", (e) => {
      if (!marker) return;
      if (distPx(marker.getLatLng(), e.latlng) < 18){
        dragging = true;
        map.dragging.disable();
      }
    });

    map.on("mousemove", (e) => {
      if (!dragging) return;
      const p = nearestPoint(e.latlng.lat, e.latlng.lng);
      if (p) syncToPoint(p, { seekVideo:true, centerMap:true, redrawProfile:true });
    });

    function stop(){
      if (!dragging) return;
      dragging = false;
      map.dragging.enable();
    }
    map.on("mouseup", stop);
    map.on("mouseleave", stop);
  }

  /* ============================================================
     PROFILE (canvas)
     ============================================================ */
  function resizeCanvasToCSS(){
    const r = elevCanvas.getBoundingClientRect();
    const w = Math.max(1, Math.round(r.width));
    const h = Math.max(1, Math.round(r.height));
    if (elevCanvas.width !== w) elevCanvas.width = w;
    if (elevCanvas.height !== h) elevCanvas.height = h;
  }

  window.addEventListener("resize", () => {
    resizeCanvasToCSS();
    drawElevationProfile(video.currentTime);
  });

  function drawElevationProfile(cursorTime){
    resizeCanvasToCSS();
    const W = elevCanvas.width, H = elevCanvas.height;
    ctx.clearRect(0,0,W,H);

    ctx.font = "14px system-ui";
    ctx.fillStyle = "#000";

    if (!points.length){
      ctx.fillText("Carga un MP4 con su GPX (misma base)", 10, 24);
      return;
    }
    if (!hasEle){
      ctx.fillText("GPX sin <ele> (sin perfil)", 10, 24);
      return;
    }

    const pad = 14;
    const distMax = points[points.length-1].dist || 1;
    const eles = points.filter(p=>Number.isFinite(p.ele)).map(p=>p.ele);
    const eMin = Math.min(...eles), eMax = Math.max(...eles);
    const eSpan = (eMax-eMin) || 1;

    const linePts = [];
    for (const p of points){
      if (!Number.isFinite(p.ele)) continue;
      const x = pad + (p.dist/distMax)*(W - pad*2);
      const y = pad + (1 - (p.ele-eMin)/eSpan)*(H - pad*2);
      linePts.push({x,y,p});
    }
    if (linePts.length < 2) return;

    ctx.beginPath();
    ctx.moveTo(linePts[0].x, linePts[0].y);
    for (let i=1;i<linePts.length;i++) ctx.lineTo(linePts[i].x, linePts[i].y);
    ctx.lineTo(linePts[linePts.length-1].x, H - pad);
    ctx.lineTo(linePts[0].x, H - pad);
    ctx.closePath();

    const grad = ctx.createLinearGradient(0, pad, 0, H - pad);
    grad.addColorStop(0.0, "rgba(255, 0, 0, 0.45)");
    grad.addColorStop(1.0, "rgba(255, 140, 0, 0.25)");
    ctx.fillStyle = grad;
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(linePts[0].x, linePts[0].y);
    for (let i=1;i<linePts.length;i++) ctx.lineTo(linePts[i].x, linePts[i].y);
    ctx.strokeStyle = "rgba(120,0,0,0.9)";
    ctx.lineWidth = 2;
    ctx.stroke();

    if (Number.isFinite(cursorTime)){
      const p = pointAtTime(cursorTime);
      const x = pad + (p.dist/distMax)*(W - pad*2);

      ctx.strokeStyle = "rgba(0,0,0,0.75)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(x, pad);
      ctx.lineTo(x, H - pad);
      ctx.stroke();

      const distKmCur = adjustedDistKm((p.distSeg ?? p.dist) || 0);
      const eleTxt = Number.isFinite(p.ele) ? `${Math.round(p.ele)} m` : "‚Äî";
      const label = `${fmtTimeHMS(p.tOffset)} ¬∑ ${distKmCur.toFixed(2)} km ¬∑ ${eleTxt}`;

      ctx.font = "12px system-ui";
      const wasFill = ctx.fillStyle;
      ctx.fillStyle = (distKmCur < 0) ? "#b00020" : wasFill;
      const tw = ctx.measureText(label).width;
      const bx = clamp(x - tw/2 - 6, pad, W - pad - tw - 12);
      const by = pad;

      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.fillRect(bx, by, tw + 12, 18);
      ctx.fillStyle = "#fff";
      ctx.fillText(label, bx + 6, by + 13);
    }
  }

  function nearestPointByDist(targetDist){
    let best = points[0], bestD = Infinity;
    for (const p of points){
      const d = Math.abs((p.distAbs ?? p.dist) - targetDist);
      if (d < bestD){ bestD = d; best = p; }
    }
    return best;
  }
  let draggingProfile = false;
  function scrubFromCanvas(clientX){
    if (!points.length) return;
    const rect = elevCanvas.getBoundingClientRect();
    const xCss = clientX - rect.left;

    const pad = 14;
    const W = elevCanvas.width;
    const usable = Math.max(1, W - pad*2);

    const f = clamp((xCss - pad)/usable, 0, 1);
    const distMax = points[points.length-1].dist || 1;
    const targetDist = f * distMax;

    const p = nearestPointByDist(targetDist);
    syncToPoint(p, { seekVideo:true, centerMap:true, redrawProfile:true });
  }
  elevCanvas.addEventListener("mousedown", (e) => { draggingProfile = true; scrubFromCanvas(e.clientX); });
  window.addEventListener("mousemove", (e) => { if (draggingProfile) scrubFromCanvas(e.clientX); });
  window.addEventListener("mouseup", () => { draggingProfile = false; });
  elevCanvas.addEventListener("click", (e) => scrubFromCanvas(e.clientX));

  /* ============================================================
     FOLDER LOAD
     ============================================================ */
  dirInput.addEventListener("change", () => {
    mp4Files.clear(); gpxFiles.clear(); kmzFiles.clear(); kmlFiles.clear(); xlsxFiles.clear();
    mp4Select.innerHTML = `<option value="">(elige MP4)</option>`;

    for (const f of dirInput.files){
      const low = f.name.toLowerCase();
      const base = basenameNoExt(f.name);
      if (low.endsWith(".mp4")) mp4Files.set(f.name, f);
      if (low.endsWith(".gpx")) gpxFiles.set(base.toLowerCase(), f);
      if (low.endsWith(".kmz")) kmzFiles.set(base.toLowerCase(), f);
      if (low.endsWith(".kml")) kmlFiles.set(base.toLowerCase(), f);
      if (low.endsWith(".xlsx")) xlsxFiles.set(base.toLowerCase(), f);
    }

    
    let names = [...mp4Files.keys()];

    if (Array.isArray(window.carreraVideoOrder) && window.carreraVideoOrder.length){
      const ord = window.carreraVideoOrder;
      const idx = (n) => {
        const p = ord.indexOf(String(n).toLowerCase());
        return p === -1 ? 999999 : p;
      };
      names.sort((a,b) => idx(a) - idx(b) || a.localeCompare(b, "es", { numeric:true }));
    } else {
      names.sort((a,b)=>a.localeCompare(b, "es", { numeric:true }));
    }


    for (const name of names){
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      mp4Select.appendChild(opt);
    }

    if (raceNameEl) raceNameEl.textContent = "Video: ‚Äî";
    setStatus(`Carpeta cargada: ${mp4Files.size} mp4, ${gpxFiles.size} gpx, ${kmzFiles.size} kmz, ${xlsxFiles.size} xlsx`);
  });


  mp4Select.addEventListener("change", async () => {

    const name = mp4Select.value;
    if (!name) return;

    clearTrack();
    clearOverlay();
    clearRutometre();

    const base = basenameNoExt(name);
    const baseKey = base.toLowerCase();
    if (raceNameEl) raceNameEl.textContent = `Video: ${base}`;

    // =========================================================
    // CASO A: MODO PAQUETE (carrera.js con Base64)
    // =========================================================
    if (window.carreraEtapasByVideo){
      const etapa = window.carreraEtapasByVideo.get(String(name).toLowerCase());
      if (etapa && (etapa.gpx_b64 || etapa.xlsx_b64 || etapa.kmz_b64 || etapa.kml_b64)){

        currentVideoName = name;
        currentVideoFile = null;

        // V√≠deo: en modo paquete se sirve desde data/
        video.src = "data/" + name;
        video.load();
        maybeResetVideoSync();

        // GPX
        if (etapa.gpx_b64){
          const gpxFile = fileFromBase64(
            etapa.gpx_name || baseKey + ".gpx",
            etapa.gpx_mime,
            etapa.gpx_b64
          );
          const text = await gpxFile.text();
          points = parseGpx(text);
          if (points.length){
            firstAbsTime = points[0].tAbs;
            drawTrack();
          }
        }

        // KMZ / KML
        if (etapa.kmz_b64){
          const kmzFile = fileFromBase64(
            etapa.kmz_name || baseKey + ".kmz",
            etapa.kmz_mime,
            etapa.kmz_b64
          );
          await loadKmzFile(kmzFile, { fit:false });
        } else if (etapa.kml_b64){
          const kmlFile = fileFromBase64(
            etapa.kml_name || baseKey + ".kml",
            etapa.kml_mime,
            etapa.kml_b64
          );
          await loadKmlFile(kmlFile, { fit:false });
        }

        // Excel
        if (etapa.xlsx_b64){
          const xlsxFile = fileFromBase64(
            etapa.xlsx_name || baseKey + ".xlsx",
            etapa.xlsx_mime,
            etapa.xlsx_b64
          );
          await loadExcelFile(xlsxFile);
        } else if (etapa.xls_b64){
          const xlsFile = fileFromBase64(
            etapa.xls_name || baseKey + ".xls",
            etapa.xls_mime,
            etapa.xls_b64
          );
          await loadExcelFile(xlsFile);
        }

        setStatus(`Listo (paquete): ${name}`);
        return; // ‚úÖ no seguir al modo carpeta
      }
    }

    // =========================================================
    // CASO B: MODO CARPETA (antiguo) ‚Äî RESTAURADO
    // =========================================================
    const mp4 = mp4Files.get(name);
    if (!mp4){
      setStatus("No existe ese MP4 en la carpeta cargada");
      return;
    }

    currentVideoFile = mp4;
    currentVideoName = mp4.name;

    video.src = URL.createObjectURL(mp4);
    video.load();
    maybeResetVideoSync();

    // 1) GPS embebido en MP4
    const embedded = await extractEmbeddedGpsFromMp4(mp4);
    if (embedded){
      points = embedded.points;
      firstAbsTime = points[0].tAbs;
      drawTrack();
      setStatus(`MP4 con GPS embebido: ${points.length} puntos`);
    } else {
      // 2) GPX con mismo base
      const gpx = gpxFiles.get(baseKey);
      if (gpx){
        const text = await readFileAsText(gpx);
        points = parseGpx(text);
        if (points.length){
          firstAbsTime = points[0].tAbs;
          drawTrack();
        } else {
          setStatus("GPX vac√≠o o sin puntos v√°lidos");
        }
      } else {
        setStatus("MP4 cargado (sin GPS embebido y sin GPX con mismo nombre)");
      }
    }

    // KMZ / KML
    const kmz = kmzFiles.get(baseKey);
    const kml = kmlFiles.get(baseKey);
    if (kmz){
      try { await loadKmzFile(kmz, { fit:false }); } catch(e){ console.error(e); }
    } else if (kml){
      try { await loadKmlFile(kml, { fit:false }); } catch(e){ console.error(e); }
    }

    // Excel
    const xlsx = xlsxFiles.get(baseKey);
    if (xlsx){
      try { await loadExcelFile(xlsx); } catch(e){ console.error(e); }
    }

    if (points.length){
      setStatus(`Listo (carpeta): ${name} (GPX${(kmz||kml)?", KMZ/KML":""}${xlsx?", Excel":""})`);
    } else {
      setStatus(`Listo (carpeta): ${name}`);
    }
  });




  /* ============================================================
     MANUAL IMPORTS
     ============================================================ */
  kmlKmzInput.addEventListener("change", async () => {
    const f = kmlKmzInput.files && kmlKmzInput.files[0];
    if (!f) return;
    try{
      if (f.name.toLowerCase().endsWith(".kmz")) await loadKmzFile(f, { fit:true });
      else await loadKmlFile(f, { fit:true });
    } finally { kmlKmzInput.value = ""; }
  });

  excelInput.addEventListener("change", async () => {
    const f = excelInput.files && excelInput.files[0];
    if (!f) return;
    try{ await loadExcelFile(f); } finally { excelInput.value = ""; }
  });

  const gpsFollowChk = document.getElementById("gpsFollowChk");

  gpsFollowChk.addEventListener("change", () => {
    if (gpsFollowChk.checked){
      try { video.pause(); } catch(e) {}
      startLiveGps();
      setStatus("GPS activado");
    } else {
      stopLiveGps();
      setStatus("GPS desactivado");
    }
  });





  /* ============================================================
     EXCEL: header + render + sync
     ============================================================ */
  async function loadExcelFile(file){
    const ab = await file.arrayBuffer();
    const wb = XLSX.read(ab, { type:"array" });

        // --- CABECERA sheet (race metadata) ---
    // Supports 2 formats:
    //  A) header row + one data row (columns are field names)
    //  B) two-column key/value list (field name in col A, value in col B)
    try{
      const cabName = wb.SheetNames.find(n => String(n||"").trim().toLowerCase().includes("cabecera"));
      if (cabName){
        const wsC = wb.Sheets[cabName];
        const gridC = XLSX.utils.sheet_to_json(wsC, { header:1, defval:"" });

        let obj = null;

        // Format B: key/value list (first column are keys)
        const nonEmptyRows = gridC.filter(r => r && r.some(v => String(v||"").trim() !== ""));
        const looksLikeKV = nonEmptyRows.length >= 3 && nonEmptyRows.every(r => String((r||[])[0]||"").trim() !== "" && (r.length <= 2 || String((r||[])[2]||"").trim()===""));
        if (looksLikeKV){
          const kv = {};
          for (const r of nonEmptyRows){
            const k = String(r[0] ?? "").trim();
            const v = r.length > 1 ? r[1] : "";
            if (k) kv[k] = v;
          }
          obj = kv;
        } else {
          // Format A: header row + first data row
          const objs = gridToObjects(gridC, 0);
          obj = objs.find(o => Object.values(o).some(v => String(v||"").trim() !== "")) || null;
        }

        if (obj){
          stageHeader = obj;
          setNeutralizedKmOffset(getField(obj, 'Sortida_Neutralitzada_Km'));
          if (points.length) detectNeutralizedSegmentInGpx();
          updateRaceHeaderFromExcel();
        }
      }
    } catch(e){
      console.warn("No se pudo leer hoja cabecera", e);
    }

    let chosen = null;
    for (const shName of wb.SheetNames){
      const ws = wb.Sheets[shName];
      const grid = XLSX.utils.sheet_to_json(ws, { header:1, defval:"" });
      const headerRow = findHeaderRowIndex(grid);
      if (headerRow !== -1){
        chosen = { shName, grid, headerRow };
        break;
      }
    }
    if (!chosen){
      const shName = wb.SheetNames[0];
      const ws = wb.Sheets[shName];
      chosen = { shName, grid: XLSX.utils.sheet_to_json(ws, { header:1, defval:"" }), headerRow:0 };
    }

    const rows = gridToObjects(chosen.grid, chosen.headerRow);

    rutometreRows = rows
      .map(r => normalizeRutometreRow(r))
      .filter(r => {
        const hasAny = String(r.Describe_Es||"").trim()
          || String(r.Coordenades_GPS||"").trim()
          || String(r.Coordenada_X||"").trim()
          || String(r.Coordenada_Y||"").trim();
        return !!hasAny;
      });

    renderRutometreTable();
    rutometreInfo.textContent = `Rut√≥metro: ${rutometreRows.length} filas`;
    setStatus(`Excel cargado: ${file.name} (${rutometreRows.length} filas)`);

    computeRutometreSync();
    // Ensure active row matches current video position after import
    try{ updateRutometreActive(rutometreActiveIndexForTime(video.currentTime)); }catch(_){ }
  }

  function findHeaderRowIndex(grid){
    for (let i=0;i<Math.min(grid.length, 50);i++){
      const row = grid[i] || [];
      const norm = row.map(x => String(x||"").trim().toLowerCase());
      if (norm.includes("describe_es")) return i;
    }
    return -1;
  }

  function gridToObjects(grid, headerRowIndex){
    const header = (grid[headerRowIndex] || []).map(x => String(x||"").trim());
    const out = [];
    for (let i=headerRowIndex+1;i<grid.length;i++){
      const row = grid[i] || [];
      const any = row.some(v => String(v||"").trim() !== "");
      if (!any) continue;

      const obj = {};
      for (let c=0;c<header.length;c++){
        const key = header[c] || `COL_${c+1}`;
        obj[key] = row[c] ?? "";
      }
      out.push(obj);
    }
    return out;
  }

  function normalizeRutometreRow(r){
    const pick = (obj, ...keys) => {
      for (const k of keys){
        if (k in obj) return obj[k];
        const kk = Object.keys(obj).find(x => x.trim().toLowerCase() === k.trim().toLowerCase());
        if (kk) return obj[kk];
      }
      return "";
    };

    return {
      Describe_Es:      pick(r, "Describe_Es"),
      Km_Etapa:        pick(r, "Km_Etapa"),
      Km_Faltan:       pick(r, "Km_Faltan"),
      Horario_1:       pick(r, "Horario_1"),
      Horario_2:       pick(r, "Horario_2"),
      Horario_3:       pick(r, "Horario_3"),
      codi_picto:      pick(r, "codi picto", "codi_picto"),
      Coordenada_X:    pick(r, "Coordenada_X"),
      Coordenada_Y:    pick(r, "Coordenada_Y"),
      Coordenades_GPS: pick(r, "Coordenades_GPS", "Coordenades GPS"),
    };
  }

  function renderRutometreTable(){
    if (!rutometreRows.length){
      rutometreTbody.innerHTML = `<tr><td colspan="10" style="padding:10px;opacity:.7;">Excel vac√≠o‚Ä¶</td></tr>`;
      return;
    }

    rutometreTbody.innerHTML = rutometreRows.map((r, idx) => `
      <tr data-idx="${idx}">
        <td class="col-desc">${escapeHtml(r.Describe_Es||"")}</td>
        <td class="td-num">${escapeHtml(r.Km_Etapa||"")}</td>
        <td class="td-num">${escapeHtml(r.Km_Faltan||"")}</td>
        <td class="td-small">${escapeHtml(r.Horario_1||"")}</td>
        <td class="td-small">${escapeHtml(r.Horario_2||"")}</td>
        <td class="td-small">${escapeHtml(r.Horario_3||"")}</td>
        <td class="td-small">${escapeHtml(r.codi_picto||"")}</td>
        <td class="td-small">${escapeHtml(r.Coordenada_X||"")}</td>
        <td class="td-small">${escapeHtml(r.Coordenada_Y||"")}</td>
        <td class="td-small">${escapeHtml(r.Coordenades_GPS||"")}</td>
      </tr>
    `).join("");

    rutometreTbody.querySelectorAll("tr[data-idx]").forEach(tr => {
      tr.addEventListener("click", () => {
        const idx = +tr.dataset.idx;
        const wp = rutometreWpts.find(w => w.rowIndex === idx);
        if (wp && Number.isFinite(wp.tOffset) && points.length){
          video.currentTime = wp.tOffset;
          const p = pointAtTime(wp.tOffset);
          syncToPoint(p, { seekVideo:true, centerMap:true, redrawProfile:true });
        } else {
          const ll = parseGpsLatLonFromRow(rutometreRows[idx]);
          if (ll){
            map.panTo([ll.lat, ll.lon], { animate:false });
            if (points.length){
              const p = nearestPoint(ll.lat, ll.lon);
              if (p) syncToPoint(p, { seekVideo:true, centerMap:true, redrawProfile:true });
            }
          } else {
            setStatus("Fila sin coordenadas/sync");
          }
        }
      });
    });

    ensureTableColumnWidths();
    makeTableResizable(document.getElementById("rutometreTable"));
  }

  function parseGpsLatLonFromRow(row){
    const s = String(row.Coordenades_GPS||"").trim();
    if (s){
      const cleaned = s.replaceAll(";", ",").replaceAll("|", ",").replaceAll("\\t", " ");
      let parts = cleaned.split(",").map(x=>x.trim()).filter(Boolean);
      if (parts.length < 2){
        parts = cleaned.split(/\\s+/).map(x=>x.trim()).filter(Boolean);
      }
      if (parts.length >= 2){
        const a = parseFloat(parts[0]);
        const b = parseFloat(parts[1]);
        if (Number.isFinite(a) && Number.isFinite(b)){
          if (Math.abs(a) <= 90 && Math.abs(b) <= 180) return { lat:a, lon:b };
          if (Math.abs(a) <= 180 && Math.abs(b) <= 90) return { lat:b, lon:a };
        }
      }
    }

    const x = parseFloat(String(row.Coordenada_X||"").replace(",", "."));
    const y = parseFloat(String(row.Coordenada_Y||"").replace(",", "."));
    if (Number.isFinite(x) && Number.isFinite(y)){
      if (Math.abs(x) <= 180 && Math.abs(y) <= 90) return { lat:y, lon:x };
      if (Math.abs(x) <= 90 && Math.abs(y) <= 180) return { lat:x, lon:y };
    }
    return null;
  }

  function computeRutometreSync(){
    if (!rutometreRows.length){
      rutometreSyncInfo.textContent = "Sync: ‚Äî";
      rutometreWpts = [];
      updateRutometreActive(-1);
      return;
    }
    if (!points.length){
      rutometreSyncInfo.textContent = "Sync: falta GPX";
      rutometreWpts = [];
      updateRutometreActive(-1);
      return;
    }

    const wpts = [];
    let ok = 0;

    for (let i=0;i<rutometreRows.length;i++){
      const row = rutometreRows[i];
      const ll = parseGpsLatLonFromRow(row);
      if (!ll) continue;

      const near = nearestPoint(ll.lat, ll.lon);
      if (!near) continue;

      wpts.push({
        rowIndex: i,
        tOffset: near.tOffset,
        dist: adjustedDistMeters((near.distSeg ?? near.dist)),
        Describe_Es: row.Describe_Es || ""
      });
      ok++;
    }

    wpts.sort((a,b)=>a.tOffset - b.tOffset);
    rutometreWpts = wpts;

    rutometreSyncInfo.textContent = `Sync: ${ok} filas enlazadas`;
    updateRutometreActive(rutometreActiveIndexForTime(video.currentTime));
  }

  function rutometreActiveIndexForTime(t){
    if (!rutometreWpts.length || !Number.isFinite(t)) return -1;
    let active = -1;
    for (let i=0;i<rutometreWpts.length;i++){
      if (rutometreWpts[i].tOffset <= t) active = i;
      else break;
    }
    return active;
  }

  function scrollRutometreRowToMiddle(tr){
    if (!rutometreTableContainer || !tr) return;

    const cont = rutometreTableContainer;
    const contRect = cont.getBoundingClientRect();
    const rowRect  = tr.getBoundingClientRect();

    // If the row is already comfortably visible, do nothing.
    const pad = Math.min(80, cont.clientHeight * 0.15); // small comfort margin
    const topLimit = contRect.top + pad;
    const botLimit = contRect.bottom - pad;

    const rowTop = rowRect.top;
    const rowBot = rowRect.bottom;

    if (rowTop >= topLimit && rowBot <= botLimit) return;

    // Scroll so the row center is the container center
    const rowCenter = rowTop + rowRect.height / 2;
    const contCenter = contRect.top + contRect.height / 2;
    const delta = rowCenter - contCenter;

    const target = cont.scrollTop + delta;

    // Clamp to valid scroll range
    const maxScroll = cont.scrollHeight - cont.clientHeight;
    const clamped = Math.max(0, Math.min(maxScroll, target));

    cont.scrollTo({ top: clamped, behavior: "smooth" });
  }

  function updateRutometreActive(wptIndex){
    if (activeRutometreIndex === wptIndex) return;

    if (activeRutometreIndex !== -1){
      const prevRowIndex = rutometreWpts[activeRutometreIndex]?.rowIndex;
      if (Number.isFinite(prevRowIndex)){
        const prevTr = rutometreTbody.querySelector(`tr[data-idx="${prevRowIndex}"]`);
        if (prevTr) prevTr.classList.remove("active");
      }
    }

    activeRutometreIndex = wptIndex;

    if (activeRutometreIndex === -1) return;

    const rowIndex = rutometreWpts[activeRutometreIndex].rowIndex;
    const tr = rutometreTbody.querySelector(`tr[data-idx="${rowIndex}"]`);
    if (tr){
      tr.classList.add("active");
      scrollRutometreRowToMiddle(tr);
    }

    const label = rutometreWpts[activeRutometreIndex].Describe_Es || "";
    rutometreSyncInfo.textContent = `Sync: #${activeRutometreIndex+1}/${rutometreWpts.length} ¬∑ ${label}`;
  }

  /* ============================================================
     TABLE: min widths + Describe 10x others + resizable columns
     ============================================================ */
  const COLS = [
    { min:220, init:520 },  // Describe_Es (10x)
    { min:70,  init:90  },  // Km_Etapa
    { min:70,  init:90  },  // Km_Faltan
    { min:80,  init:95  },  // Horario_1
    { min:80,  init:95  },  // Horario_2
    { min:80,  init:95  },  // Horario_3
    { min:80,  init:95  },  // codi picto
    { min:95,  init:120 },  // Coordenada_X
    { min:95,  init:120 },  // Coordenada_Y
    { min:110, init:170 },  // Coordenades_GPS
  ];

  function ensureTableColumnWidths(){
    const table = document.getElementById("rutometreTable");
    if (!table) return;

    let colgroup = table.querySelector("colgroup");
    if (colgroup) colgroup.remove();
    colgroup = document.createElement("colgroup");

    for (const c of COLS){
      const col = document.createElement("col");
      col.style.width = c.init + "px";
      col.style.minWidth = c.min + "px";
      colgroup.appendChild(col);
    }
    table.insertBefore(colgroup, table.firstChild);
  }

  function makeTableResizable(table){
    if (!table) return;
    table.querySelectorAll(".col-resizer").forEach(x => x.remove());

    const ths = table.querySelectorAll("thead th");
    const colgroup = table.querySelector("colgroup");
    if (!colgroup) return;
    const cols = colgroup.querySelectorAll("col");

    ths.forEach((th, colIndex) => {
      const resizer = document.createElement("div");
      resizer.className = "col-resizer";
      th.appendChild(resizer);

      let startX = 0;
      let startW = 0;

      const onMove = (e) => {
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const dx = clientX - startX;
        const minW = COLS[colIndex]?.min ?? 40;
        const newW = Math.max(minW, startW + dx);
        cols[colIndex].style.width = newW + "px";
      };

      const onUp = () => {
        document.removeEventListener("mousemove", onMove);
        document.removeEventListener("mouseup", onUp);
        document.removeEventListener("touchmove", onMove);
        document.removeEventListener("touchend", onUp);
        document.body.style.cursor = "";
      };

      const onDown = (e) => {
        e.preventDefault();
        startX = e.touches ? e.touches[0].clientX : e.clientX;
        startW = cols[colIndex].getBoundingClientRect().width;
        document.body.style.cursor = "col-resize";

        document.addEventListener("mousemove", onMove);
        document.addEventListener("mouseup", onUp);
        document.addEventListener("touchmove", onMove, { passive:false });
        document.addEventListener("touchend", onUp);
      };

      resizer.addEventListener("mousedown", onDown);
      resizer.addEventListener("touchstart", onDown, { passive:false });
    });
  }

  ensureTableColumnWidths();
  makeTableResizable(document.getElementById("rutometreTable"));

  /* ============================================================
     KMZ/KML with icons + name/description
     ============================================================ */
  async function loadKmlFile(file, opts){
    clearOverlay();
    const txt = await readFileAsText(file);
    overlayLayer = kmlToLeafletLayer(txt);
    overlayLayer.addTo(map);
    if (opts?.fit){
      try{ map.fitBounds(overlayLayer.getBounds(), { padding:[20,20] }); } catch(_){}
    }
    setStatus(`Overlay cargado: ${file.name}`);
  }

  function kmlToLeafletLayer(kmlText){
    const xml = new DOMParser().parseFromString(kmlText, "application/xml");
    const gj = toGeoJSON.kml(xml);
    return L.geoJSON(gj, {
      style: () => ({ color:"#cc00cc", weight:3, opacity:0.85 }),
      pointToLayer: (feature, latlng) => {
        const name = feature?.properties?.name || "";
        const desc = feature?.properties?.description || "";
        return L.circleMarker(latlng, {
          radius: 5,
          color: "#cc00cc",
          fillColor: "#cc00cc",
          fillOpacity: 0.8,
          weight: 1
        }).bindPopup(`<b>${escapeHtml(name)}</b><br>${desc}`);
      }
    });
  }

  
  async function loadKmzFile(file){
    const ab = await file.arrayBuffer();
    const zip = await JSZip.loadAsync(ab);

    // ---- extract icons from KMZ (keep multiple normalized keys) ----
    const iconBlobs = {}; // key -> objectURL
    const iconExts = [".png",".jpg",".jpeg",".gif",".svg",".webp"];

    function normPath(p){
      if (!p) return "";
      let s = String(p).trim();
      try { s = decodeURIComponent(s); } catch(_){}
      s = s.replaceAll("\\\\","/").replace(/^\.\/+/, "").replace(/^\/+/, "");
      return s.toLowerCase();
    }
    function addIconKey(key, url){
      const k = normPath(key);
      if (!k) return;
      iconBlobs[k] = url;
      const base = k.split("/").pop();
      if (base) iconBlobs[base] = url;
      // common "files/" prefix variants
      if (k.startsWith("files/")) iconBlobs[k.slice(6)] = url;
    }

    for (const relPath of Object.keys(zip.files)){
      const pl = normPath(relPath);
      if (!iconExts.some(ext => pl.endsWith(ext))) continue;
      const blob = await zip.files[relPath].async("blob");
      const url = URL.createObjectURL(blob);
      addIconKey(relPath, url);
    }

    // ---- find first KML (doc.kml typically) ----
    let kmlRel = null;
    for (const relPath of Object.keys(zip.files)){
      if (normPath(relPath).endsWith(".kml")) { kmlRel = relPath; break; }
    }
    if (!kmlRel){
      setStatus("KMZ sin .kml");
      return;
    }

    const kmlText = await zip.files[kmlRel].async("text");
    overlayLayer = loadKmzKmlDirect(kmlText, iconBlobs, file.name);
    overlayLayer.addTo(map);
    try { map.fitBounds(overlayLayer.getBounds(), { padding:[20,20] }); } catch(_){}
    setStatus(`Overlay KMZ cargado (pictos): ${file.name}`);
  }

  function bindPopupIfAny(layer, name, descriptionHtml){
    const title = name ? `<b>${escapeHtml(name)}</b>` : "";
    const desc  = descriptionHtml ? `<div style="max-width:360px">${descriptionHtml}</div>` : "";
    if (title || desc){
      layer.bindPopup(`${title}${desc ? "<br/>"+desc : ""}`);
    }
  }

  function parseKmlCoordinates(text){
    // "lon,lat,alt lon,lat,alt ..."
    const parts = String(text||"").trim().split(/\s+/).filter(Boolean);
    const out = [];
    for (const p of parts){
      const [lonS, latS] = p.split(",");
      const lat = parseFloat(latS), lon = parseFloat(lonS);
      if (Number.isFinite(lat) && Number.isFinite(lon)) out.push([lat, lon]);
    }
    return out;
  }

  function resolveKmzIconUrl(href, iconBlobs){
    if (!href) return "";
    const isHttp = /^https?:\/\//i.test(href.trim());
    if (isHttp) return href.trim();

    // normalize
    let key = String(href).trim();
    try { key = decodeURIComponent(key); } catch(_){}
    key = key.replaceAll("\\\\","/").replace(/^\.\/+/, "").replace(/^\/+/, "");
    const kLow = key.toLowerCase();
    const base = kLow.split("/").pop();

    if (iconBlobs[kLow]) return iconBlobs[kLow];
    if (iconBlobs[base]) return iconBlobs[base];

    // try stripping "files/"
    if (kLow.startsWith("files/") && iconBlobs[kLow.slice(6)]) return iconBlobs[kLow.slice(6)];

    // suffix match
    const candidates = Object.keys(iconBlobs).filter(k => k.endsWith("/"+kLow) || k.endsWith(kLow) || k.endsWith("/"+base) || k.endsWith(base));
    if (candidates.length) return iconBlobs[candidates[0]];

    return "";
  }

  // KMZ: parse KML directly for styleUrl + IconStyle href + Point/Line/Polygon
  function loadKmzKmlDirect(kmlText, iconBlobs, filename){
    const xml = new DOMParser().parseFromString(kmlText, "application/xml");

    const qAll = (tag) => [...xml.getElementsByTagName(tag)];

    // 1) Style id => href (IconStyle/href)
    const styleHref = new Map(); // "#id" => "files/icon.png"
    for (const st of qAll("Style")){
      const id = st.getAttribute("id");
      if (!id) continue;
      const hrefEl = st.getElementsByTagName("href")[0];
      if (hrefEl && hrefEl.textContent){
        styleHref.set("#"+id, hrefEl.textContent.trim());
      }
    }

    // 2) StyleMap id => normal styleUrl
    const styleMap = new Map(); // "#id" => "#styleId"
    for (const sm of qAll("StyleMap")){
      const id = sm.getAttribute("id");
      if (!id) continue;
      const pairs = [...sm.getElementsByTagName("Pair")];
      let url = "";
      for (const pair of pairs){
        const keyEl = pair.getElementsByTagName("key")[0];
        const urlEl = pair.getElementsByTagName("styleUrl")[0];
        const key = keyEl ? keyEl.textContent.trim() : "";
        if ((key === "normal" || key === "") && urlEl && urlEl.textContent){
          url = urlEl.textContent.trim();
          if (key === "normal") break;
        }
      }
      if (url) styleMap.set("#"+id, url);
    }

    const group = L.featureGroup();
    const placemarks = qAll("Placemark");

    for (const pm of placemarks){
      const name = pm.getElementsByTagName("name")[0]?.textContent?.trim() || "";
      const desc = pm.getElementsByTagName("description")[0]?.textContent || "";
      let styleUrl = pm.getElementsByTagName("styleUrl")[0]?.textContent?.trim() || "";

      // resolve styleMap indirection
      if (styleMap.has(styleUrl)) styleUrl = styleMap.get(styleUrl);

      // inline Style inside Placemark
      let href = "";
      const inlineStyle = pm.getElementsByTagName("Style")[0];
      if (inlineStyle){
        const hrefEl = inlineStyle.getElementsByTagName("href")[0];
        if (hrefEl && hrefEl.textContent) href = hrefEl.textContent.trim();
      }
      if (!href && styleUrl) href = styleHref.get(styleUrl) || "";

      // geometry
      const pointEl = pm.getElementsByTagName("Point")[0];
      const lineEl  = pm.getElementsByTagName("LineString")[0];
      const polyEl  = pm.getElementsByTagName("Polygon")[0];

      if (pointEl){
        const coordText = pointEl.getElementsByTagName("coordinates")[0]?.textContent?.trim() || "";
        const [lon, lat] = coordText.split(",").map(v => parseFloat(v));
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;

        const iconUrl = resolveKmzIconUrl(href, iconBlobs);
        let m;
        if (iconUrl){
          const icon = L.icon({ iconUrl, iconSize:[32,32], iconAnchor:[16,32], popupAnchor:[0,-28] });
          m = L.marker([lat, lon], { icon });
        } else {
          m = L.circleMarker([lat, lon], { radius:5, color:"#cc00cc", fillColor:"#cc00cc", fillOpacity:.8, weight:1 });
        }
        bindPopupIfAny(m, name, desc);
        group.addLayer(m);
        continue;
      }

      if (lineEl){
        const coords = parseKmlCoordinates(lineEl.getElementsByTagName("coordinates")[0]?.textContent || "");
        if (coords.length >= 2){
          const pl = L.polyline(coords, { color:"#cc00cc", weight:3, opacity:0.85 });
          bindPopupIfAny(pl, name, desc);
          group.addLayer(pl);
        }
        continue;
      }

      if (polyEl){
        const outer = polyEl.getElementsByTagName("outerBoundaryIs")[0];
        const coordsText = outer?.getElementsByTagName("coordinates")[0]?.textContent || "";
        const coords = parseKmlCoordinates(coordsText);
        if (coords.length >= 3){
          const pg = L.polygon(coords, { color:"#cc00cc", weight:2, opacity:0.85, fillOpacity:0.15 });
          bindPopupIfAny(pg, name, desc);
          group.addLayer(pg);
        }
        continue;
      }
    }

    return group;
  }
/* ============================================================
     GOOGLE + SNAPSHOT
     ============================================================ */
  function getCurrentLatLon(){
    if (!points.length || !marker) return null;
    const ll = marker.getLatLng();
    return { lat: ll.lat, lon: ll.lng };
  }

  btnGoogleMaps.addEventListener("click", () => {
    const pos = getCurrentLatLon();
    if (!pos) return;
    window.open(`https://www.google.com/maps?q=${pos.lat},${pos.lon}&z=18`, "_blank", "noopener");
  });

  btnStreetView.addEventListener("click", () => {
    const pos = getCurrentLatLon();
    if (!pos) return;
    const heading = Number.isFinite(lastBearingDeg) ? lastBearingDeg : 0;
    const url = `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${pos.lat},${pos.lon}&heading=${heading}&pitch=0`;
    window.open(url, "_blank", "noopener");
  });

  btnSnapshot.addEventListener("click", () => {
    if (!video.videoWidth || !video.videoHeight){
      setStatus("No hay frame para capturar (reproduce el v√≠deo un momento)");
      return;
    }
    const c = document.createElement("canvas");
    c.width = video.videoWidth;
    c.height = video.videoHeight;
    c.getContext("2d").drawImage(video, 0, 0, c.width, c.height);

    const pos = getCurrentLatLon();
    const t = fmtTimeHMS(video.currentTime).replaceAll(":","-");
    const lat = pos ? pos.lat.toFixed(5) : "NA";
    const lon = pos ? pos.lon.toFixed(5) : "NA";

    c.toBlob((blob) => {
      if (!blob) return;
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = `frame_${t}_${lat}_${lon}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setStatus("Snapshot descargado (PNG)");
    }, "image/png");
  });

  /* ============================================================
     SPLITTERS: resize the 2x2 panels (vertical + horizontal)
     ============================================================ */
  function invalidateAfterResize(){
    if (typeof map.invalidateSize === "function") map.invalidateSize(false);
    drawElevationProfile(video.currentTime);
  }

  function enableSplitters(){
    // Vertical splitter -> --colLeft
    (function(){
      let startX=0, startLeftPx=0, totalW=0;
      const minCol = 260;

      function down(e){
        e.preventDefault();
        const rect = mainEl.getBoundingClientRect();
        totalW = rect.width;

        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        startX = clientX - rect.left;

        const cs = getComputedStyle(mainEl).gridTemplateColumns.split(" ");
        startLeftPx = parseFloat(cs[0]) || (totalW/2);

        document.body.style.cursor = "col-resize";
        document.addEventListener("mousemove", move);
        document.addEventListener("mouseup", up);
        document.addEventListener("touchmove", move, { passive:false });
        document.addEventListener("touchend", up);
      }

      function move(e){
        e.preventDefault();
        const rect = mainEl.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const x = clientX - rect.left;
        const dx = x - startX;

        const splitW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--splitter")) || 8;
        const newLeft = clamp(startLeftPx + dx, minCol, totalW - splitW - minCol);

        const pct = (newLeft / totalW) * 100;
        document.documentElement.style.setProperty("--colLeft", pct.toFixed(3) + "%");
        invalidateAfterResize();
      }

      function up(){
        document.body.style.cursor = "";
        document.removeEventListener("mousemove", move);
        document.removeEventListener("mouseup", up);
        document.removeEventListener("touchmove", move);
        document.removeEventListener("touchend", up);
      }

      vSplit.addEventListener("mousedown", down);
      vSplit.addEventListener("touchstart", down, { passive:false });
    })();

    // Horizontal splitter -> --rowTop
    (function(){
      let startY=0, startTopPx=0, totalH=0;
      const minRow = 220;

      function down(e){
        e.preventDefault();
        const rect = mainEl.getBoundingClientRect();
        totalH = rect.height;

        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        startY = clientY - rect.top;

        const rs = getComputedStyle(mainEl).gridTemplateRows.split(" ");
        startTopPx = parseFloat(rs[0]) || (totalH/2);

        document.body.style.cursor = "row-resize";
        document.addEventListener("mousemove", move);
        document.addEventListener("mouseup", up);
        document.addEventListener("touchmove", move, { passive:false });
        document.addEventListener("touchend", up);
      }

      function move(e){
        e.preventDefault();
        const rect = mainEl.getBoundingClientRect();
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const y = clientY - rect.top;
        const dy = y - startY;

        const splitH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--splitter")) || 8;
        const newTop = clamp(startTopPx + dy, minRow, totalH - splitH - minRow);

        const pct = (newTop / totalH) * 100;
        document.documentElement.style.setProperty("--rowTop", pct.toFixed(3) + "%");
        invalidateAfterResize();
      }

      function up(){
        document.body.style.cursor = "";
        document.removeEventListener("mousemove", move);
        document.removeEventListener("mouseup", up);
        document.removeEventListener("touchmove", move);
        document.removeEventListener("touchend", up);
      }

      hSplit.addEventListener("mousedown", down);
      hSplit.addEventListener("touchstart", down, { passive:false });
    })();
  }

  enableSplitters();

  /* ============================================================
     INIT
     ============================================================ */
  setStatus("Esperando carpeta‚Ä¶");
  resizeCanvasToCSS();
  drawElevationProfile(null);
  </script>

  <div id="appFooter">¬© 2026 Roberto Benet - rbenet71@gmail.com</div>
<!--
====================================================================
ICGC OFFLINE MAPS (VRM 2.4) - PASO A PASO
====================================================================

OBJETIVO
--------
Crear tiles offline de ICGC (Topo y Orto) y copiarlos a la carpeta:

  ./mapas offline/

De este modo VRM puede cargar los mapas offline (sin internet) usando
las opciones del selector:
  - ICGC Topo (offline)
  - ICGC Orto (offline)

IMPORTANTE (iOS / iPad)
-----------------------
- Esta modalidad NO usa Service Worker ni servidor local.
- VRM carga las teselas como im√°genes relativas dentro de la carpeta.
- Abre el HTML desde "Archivos" (Files) en iOS. Si Safari no carga rutas
  relativas en tu caso concreto, usa una app tipo "Documents by Readdle"
  que abre el HTML en un WebView con acceso local.

HERRAMIENTAS NECESARIAS (PC/Mac)
--------------------------------
1) GDAL (incluye gdal2tiles.py)
   - Windows: OSGeo4W (recomendado) o instalador GDAL
   - macOS: Homebrew:  brew install gdal
   - Linux: apt/yum/pacman (gdal-bin)

2) (Opcional) QGIS (√∫til para verificar WMS y CRS, pero no obligatorio).

ESTRUCTURA DE CARPETAS
----------------------
Dentro de la carpeta donde est√° este HTML:

  mapas offline/
    icgc_topo/
      {z}/{x}/{y}.png
    icgc_orto/
      {z}/{x}/{y}.jpg

PASO A PASO (CATALUNYA COMPLETA, M√ÅXIMO DETALLE)
------------------------------------------------
A) Crear TOPO (PNG)  Zoom 6-18
    1) Crea/entra en la carpeta del proyecto VRM
    2) Ejecuta:

    gdal2tiles.py -z 6-18 -r bilinear -w none \
      "https://geoserveis.icgc.cat/icc_mapesmultibase/utm/wms/service?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=topo&CRS=EPSG:3857&FORMAT=image/png" \
      "mapas offline/icgc_topo"

B) Crear ORTO (JPG)  Zoom 6-19
    1) Ejecuta:

    gdal2tiles.py -z 6-19 -r bilinear -w none \
      "https://geoserveis.icgc.cat/icc_mapesmultibase/utm/wms/service?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&LAYERS=orto&CRS=EPSG:3857&FORMAT=image/jpeg" \
      "mapas offline/icgc_orto"

RECOMENDACIONES
---------------
- Ejecuta por la noche: Catalu√±a completa puede tardar horas y ocupar decenas de GB.
- Asegura espacio en disco (Topo ~5GB; Orto ~15-20GB aprox, seg√∫n zoom y compresi√≥n).
- Para reducir tama√±o, baja el zoom m√°ximo (Topo 17 / Orto 18).

VERIFICACI√ìN
------------
Comprueba que existen archivos como:
  mapas offline/icgc_topo/12/2068/1521.png
  mapas offline/icgc_orto/12/2068/1521.jpg

Luego abre VRM y selecciona:
  Offline -> ICGC Topo (offline) / ICGC Orto (offline)

====================================================================
-->

<script>
/* ===========================
   PWA install/update (VRM)
   =========================== */
(function(){
  const installBtn = document.getElementById('pwaInstallBtn');
  const updateBtn  = document.getElementById('pwaUpdateBtn');
  const installHelp = document.getElementById('installHelp');
  const closeInstallHelp = document.getElementById('closeInstallHelp');

  const isIOS = /iphone|ipad|ipod/i.test(navigator.userAgent);
  const isStandalone = () =>
    (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) ||
    (window.navigator && window.navigator.standalone === true);

  function showInstallHelp(){
    if (installHelp) installHelp.style.display = 'flex';
  }
  function hideInstallHelp(){
    if (installHelp) installHelp.style.display = 'none';
  }
  if (closeInstallHelp) closeInstallHelp.addEventListener('click', hideInstallHelp);
  if (installHelp) installHelp.addEventListener('click', (ev)=>{ if (ev.target === installHelp) hideInstallHelp(); });

  // If already installed, hide install button.
  function refreshInstallVisibility(){
    if (!installBtn) return;
    if (isStandalone()){
      installBtn.style.display = 'none';
      return;
    }
    // iOS: always show install button (it opens help)
    if (isIOS){
      installBtn.style.display = '';
      installBtn.onclick = showInstallHelp;
    }
  }
  refreshInstallVisibility();

  // Chromium install prompt
  let deferredPrompt = null;
  window.addEventListener('beforeinstallprompt', (e)=>{
    e.preventDefault();
    deferredPrompt = e;
    if (!installBtn) return;
    if (isStandalone()) return;
    installBtn.style.display = '';
    installBtn.onclick = async ()=>{
      if (!deferredPrompt){
        showInstallHelp();
        return;
      }
      deferredPrompt.prompt();
      try { await deferredPrompt.userChoice; } catch(_){}
      deferredPrompt = null;
      installBtn.style.display = 'none';
    };
  });

(function loadCarreraConfig(){
  const script = document.createElement("script");
  script.src = "data/carrera.js";
  script.defer = true;

  script.onload = () => {
    const cfg = window.CARRERA_CONFIG;
    if (!cfg) return;

    // Cambiar nombre cabecera + title
    if (cfg.nombre){
      const nameEl = document.querySelector("#appHeader .appName");
      if (nameEl) nameEl.textContent = cfg.nombre;
      document.title = cfg.nombre;
    }

    // Cambiar logo (dentro de /data)
    if (cfg.logo){
      const logoEl = document.querySelector("#appHeader img");
      if (logoEl) logoEl.src = "data/" + cfg.logo;
    }

    // Index por v√≠deo (para autocarga GPX/KMZ/XLSX cuando el usuario elija mp4)
    window.carreraEtapasByVideo = null;
    if (Array.isArray(cfg.etapas)){
      window.carreraEtapasByVideo = new Map();
      for (const e of cfg.etapas){
        if (e && e.video){
          window.carreraEtapasByVideo.set(String(e.video).toLowerCase(), e);
        }
      }
    }

    // Orden recomendado (para cuando el usuario cargue carpeta)
    window.carreraVideoOrder = null;
    if (Array.isArray(cfg.videos)){
      window.carreraVideoOrder = cfg.videos
        .map(v => String(v || "").trim().toLowerCase())
        .filter(Boolean);
    } else if (Array.isArray(cfg.etapas)){
      window.carreraVideoOrder = cfg.etapas
        .map(e => String(e?.video || "").trim().toLowerCase())
        .filter(Boolean);
    }

    // Rellenar selector de v√≠deos SIN carpeta (e1..e7) + "Elige MP4"
    if (typeof mp4Select !== "undefined" && mp4Select){
      let list = [];
      if (Array.isArray(cfg.etapas) && cfg.etapas.length){
        list = cfg.etapas.map(e => e.video).filter(Boolean);
      } else if (Array.isArray(cfg.videos) && cfg.videos.length){
        list = cfg.videos.slice();
      }

      if (list.length){
        mp4Select.innerHTML = "";

        const opt0 = document.createElement("option");
        opt0.value = "";
        opt0.textContent = "Elige MP4";
        opt0.disabled = true;
        opt0.selected = true;
        mp4Select.appendChild(opt0);

        for (let i = 0; i < list.length; i++){
          const opt = document.createElement("option");
          opt.value = list[i];
          opt.textContent = list[i];
          mp4Select.appendChild(opt);
        }
      }
    }
  };

  script.onerror = () => {}; // si no existe, no pasa nada
  document.head.appendChild(script);
})();


  // Service worker (optional). If a SW exists, we can offer an update button when a new one is waiting.
  if ('serviceWorker' in navigator && location.protocol !== 'file:'){
    window.addEventListener('load', async ()=>{
      try{
        // Try register in same folder (recommended). If your SW lives elsewhere, adjust the path.
        //const reg = await navigator.serviceWorker.register('vrm_sw.js');
        const reg = await navigator.serviceWorker.register('./vrm_sw.js', { scope: './' });

        function showUpdate(){
          if (!updateBtn) return;
          updateBtn.style.display = '';
          updateBtn.onclick = ()=>{
            if (reg.waiting) reg.waiting.postMessage({ type:'SKIP_WAITING' });
          };
        }
        if (reg.waiting) showUpdate();
        reg.addEventListener('updatefound', ()=>{
          const sw = reg.installing;
          if (!sw) return;
          sw.addEventListener('statechange', ()=>{
            if (sw.state === 'installed' && navigator.serviceWorker.controller){
              showUpdate();
            }
          });
        });
        navigator.serviceWorker.addEventListener('controllerchange', ()=>{
          // Reload so the new version takes effect.
          window.location.reload();
        });
      }catch(e){
        // SW not available in this path; ignore.
        console.debug('SW register failed', e);
      }
    });
  }
})();
</script>
</body>
</html>