<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Crono Cuenta Atrás - Control de Salidas para Carreras</title>
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-CV925PMBQV"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-CV925PMBQV');
    </script>

    <!-- Iconos -->
    <link rel="icon" type="image/png" href="https://rbenet71.github.io/Web/Árbitro/crono_cuenta_atras/Crono_cuenta_atras_192_192.png">
    <link rel="apple-touch-icon" href="https://rbenet71.github.io/Web/Árbitro/crono_cuenta_atras/Crono_cuenta_atras_192_192.png">
    
    <!-- PWA -->
    <meta name="theme-color" content="#FF0000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Crono Cuenta Atrás">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #FF0000;
            --success: #2ecc71;
            --warning: #f39c12;
            --danger: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
            --gray: #95a5a6;
            --light-gray: #f8f9fa;
            --border-radius: 8px;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 8px 20px rgba(0, 0, 0, 0.15);
            --red-bg: #FF0000;
            --orange-bg: #FFFF00;
            --green-bg: #00FF00;
            --black-transparent: rgba(0, 0, 0, 0.7);
            --white: #FFFFFF;
        }

        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
            transition: background-color 0.5s ease;
        }

        /* Estados de cuenta atrás con colores PUROS y fondo uniforme */
        body.countdown-normal {
            background-color: var(--red-bg) !important;
            background: var(--red-bg) !important;
        }

        body.countdown-warning {
            background-color: var(--orange-bg) !important;
            background: var(--orange-bg) !important;
        }

        body.countdown-critical {
            background-color: var(--orange-bg) !important;
            background: var(--orange-bg) !important;
            animation: pulse-orange 1s infinite;
        }

        body.countdown-salida {
            background-color: var(--green-bg) !important;
            background: var(--green-bg) !important;
        }

        @keyframes pulse-orange {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        /* ANIMACIÓN AGRESIVA para últimos 5 segundos - VERSIÓN ORIGINAL */
        @keyframes aggressive-pulse {
            0%, 100% { 
                transform: scale(1);
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            }
            25% { 
                transform: scale(1.1);
                text-shadow: 0 0 30px rgba(255, 255, 255, 1);
            }
            50% { 
                transform: scale(1.05);
                text-shadow: 0 0 40px rgba(255, 255, 255, 1);
            }
            75% { 
                transform: scale(1.15);
                text-shadow: 0 0 50px rgba(255, 0, 0, 1);
            }
        }

        /* Clase para números agresivos en últimos 5 segundos - VERSIÓN ORIGINAL */
        .aggressive-numbers .countdown-display {
            animation: aggressive-pulse 0.5s infinite ;
            font-size: 35vw !important;
            color: #ff0000 !important;
            text-shadow: 0 0 30px rgba(255, 0, 0, 0.9);
            transition: all 0.3s ease !important;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 15px;
        }

        /* =========================================== */
        /* HEADER REDISEÑADO - MÁS ELEGANTE */
        /* =========================================== */
        .app-header {
            background: linear-gradient(135deg, var(--primary) 0%, #1a2530 100%);
            color: white;
            padding: 12px 0;
            box-shadow: var(--shadow);
            position: relative;
            overflow: hidden;
        }

        .app-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--secondary), var(--success), var(--warning), var(--danger));
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        .app-title {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px 0;
        }

        .app-logo {
            width: 42px;
            height: 42px;
            border-radius: 10px;
            object-fit: cover;
            border: 3px solid var(--secondary);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.4);
            transition: transform 0.3s ease;
        }

        .app-logo:hover {
            transform: rotate(10deg);
        }

        .app-title h1 {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(90deg, #fff, var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .language-selector {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .languages-label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.85rem;
            font-weight: 500;
            white-space: nowrap;
        }

        .flag {
            width: 32px;
            height: 22px;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.3s;
            border: 2px solid transparent;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .flag:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        .flag.active {
            opacity: 1;
            border: 2px solid var(--secondary);
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.6);
        }

        .flag-catalunya {
            background: linear-gradient(
                to bottom,
                #ffcd00 0%, #ffcd00 10%,
                #da121a 10%, #da121a 20%,
                #ffcd00 20%, #ffcd00 30%,
                #da121a 30%, #da121a 40%,
                #ffcd00 40%, #ffcd00 50%,
                #da121a 50%, #da121a 60%,
                #ffcd00 60%, #ffcd00 70%,
                #da121a 70%, #da121a 80%,
                #ffcd00 80%, #ffcd00 90%,
                #da121a 90%, #da121a 100%
            );
        }

        .help-icon {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
            padding: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
        }

        .help-icon:hover {
            color: var(--secondary);
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(15deg);
        }

        /* =========================================== */
        /* CONTENIDO PRINCIPAL - REDISEÑADO COMPLETO */
        /* =========================================== */
        .main-content {
            padding: 10px 0;
            min-height: calc(100vh - 200px);
        }

        .app-card {
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            overflow: hidden;
            margin-bottom: 10px;
            border: 1px solid rgba(0, 0, 0, 0.08);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .app-card:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-5px);
        }

        .card-header {
            padding: 2px 10px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-bottom: 1px solid #e9ecef;
        }

        .card-header h2 {
            color: var(--primary);
            font-size: 1.2rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 0;
        }

        .card-header h2 i {
            color: var(--secondary);
            font-size: 1.2rem;
        }

        .card-body {
            padding: 30px;
        }

        /* =========================================== */
        /* SECCIONES DE CONFIGURACIÓN - ORGANIZADAS */
        /* =========================================== */
        .config-section {
            margin-bottom: 10px;
        }

        .section-title {
            font-size: 1.2rem;
            color: var(--primary);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--light);
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
        }

        .section-title i {
            color: var(--secondary);
        }

        /* Formularios mejorados */
        .form-group {
            margin-bottom: 25px;
        }

        .form-row {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--dark);
            font-size: 1rem;
            min-width: 180px;
        }

        .form-control {
            width: 100%;
            padding: 14px 18px;
            border: 2px solid #e0e0e0;
            border-radius: var(--border-radius);
            font-size: 1rem;
            transition: all 0.3s ease;
            background: #fff;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--secondary);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }

        .form-control-sm {
            padding: 10px 14px;
            font-size: 0.95rem;
        }

        .form-inline-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-with-unit {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .input-with-unit input {
            width: 80px;
            text-align: center;
        }

        .unit {
            color: var(--gray);
            font-weight: 500;
            min-width: 70px;
        }

        /* =========================================== */
        /* BOTONES REDISEÑADOS - CONSISTENTES */
        /* =========================================== */
        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s ease;
            font-size: 1rem;
            text-decoration: none;
            position: relative;
            overflow: hidden;
            min-height: 50px;
        }

        .btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%);
            transform-origin: 50% 50%;
        }

        .btn:focus:not(:active)::after {
            animation: ripple 1s ease-out;
        }

        @keyframes ripple {
            0% {
                transform: scale(0, 0);
                opacity: 0.5;
            }
            100% {
                transform: scale(20, 20);
                opacity: 0;
            }
        }

        .btn-sm {
            padding: 10px 20px;
            font-size: 0.9rem;
            min-height: 42px;
        }

        .btn-lg {
            padding: 18px 40px;
            font-size: 1.2rem;
            min-height: 60px;
        }

        .btn-block {
            width: 100%;
            display: flex;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--secondary) 0%, #2980b9 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #2980b9 0%, #1c5a7a 100%);
            transform: translateY(-3px);
            box-shadow: 0 6px 18px rgba(52, 152, 219, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success) 0%, #27ae60 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(46, 204, 113, 0.3);
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #27ae60 0%, #1e8449 100%);
            transform: translateY(-3px);
            box-shadow: 0 6px 18px rgba(46, 204, 113, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, var(--warning) 0%, #d68910 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(243, 156, 18, 0.3);
        }

        .btn-warning:hover {
            background: linear-gradient(135deg, #d68910 0%, #a8640a 100%);
            transform: translateY(-3px);
            box-shadow: 0 6px 18px rgba(243, 156, 18, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--danger) 0%, #c0392b 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #c0392b 0%, #922b21 100%);
            transform: translateY(-3px);
            box-shadow: 0 6px 18px rgba(231, 76, 60, 0.4);
        }

        .btn-outline {
            background: transparent;
            border: 2px solid #e0e0e0;
            color: var(--dark);
        }

        .btn-outline:hover {
            background: #f8f9fa;
            border-color: var(--secondary);
            color: var(--secondary);
        }

        /* =========================================== */
        /* ESTILOS UNIFICADOS PARA BOTONES RESPONSIVE */
        /* =========================================== */

        /* Contenedores de botones en grid - estilo unificado */
        .buttons-responsive-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            width: 100%;
        }

        /* Botón responsive - estilo similar a footer-btn pero con colores variables */
        .responsive-btn {
            width: 100%;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            white-space: nowrap;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-decoration: none;
            gap: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .responsive-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%);
            transform-origin: 50% 50%;
        }

        .responsive-btn:focus:not(:active)::after {
            animation: ripple 1s ease-out;
        }

        .responsive-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.3);
        }

        .responsive-btn:active {
            transform: translateY(-1px);
        }

        .responsive-btn i {
            font-size: 1.1rem;
        }

        /* Variantes de color para responsive-btn */
        .responsive-btn.btn-primary {
            background: linear-gradient(135deg, var(--secondary) 0%, #2980b9 100%);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .responsive-btn.btn-primary:hover {
            background: linear-gradient(135deg, #2980b9 0%, #1c5a7a 100%);
            box-shadow: 0 6px 18px rgba(52, 152, 219, 0.4);
        }

        .responsive-btn.btn-success {
            background: linear-gradient(135deg, var(--success) 0%, #27ae60 100%);
            box-shadow: 0 4px 12px rgba(46, 204, 113, 0.3);
        }

        .responsive-btn.btn-success:hover {
            background: linear-gradient(135deg, #27ae60 0%, #1e8449 100%);
            box-shadow: 0 6px 18px rgba(46, 204, 113, 0.4);
        }

        .responsive-btn.btn-warning {
            background: linear-gradient(135deg, var(--warning) 0%, #d68910 100%);
            box-shadow: 0 4px 12px rgba(243, 156, 18, 0.3);
        }

        .responsive-btn.btn-warning:hover {
            background: linear-gradient(135deg, #d68910 0%, #a8640a 100%);
            box-shadow: 0 6px 18px rgba(243, 156, 18, 0.4);
        }

        .responsive-btn.btn-danger {
            background: linear-gradient(135deg, var(--danger) 0%, #c0392b 100%);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }

        .responsive-btn.btn-danger:hover {
            background: linear-gradient(135deg, #c0392b 0%, #922b21 100%);
            box-shadow: 0 6px 18px rgba(231, 76, 60, 0.4);
        }

        /* =========================================== */
        /* ACTUALIZAR SELECTORES EXISTENTES */
        /* =========================================== */

        /* Botones de gestión de carrera - REEMPLAZADO POR GRID */
        .race-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background-color: var(--light-gray);
            border-radius: 8px;
        }

        /* El select en grid */
        .race-selector select {
            grid-column: 1 / -1;
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            width: 100%;
        }

        /* Botones en el selector de carrera como responsive-btn */
        .race-selector .btn {
            width: 100%;
            min-height: 48px;
            margin: 0;
        }

        /* =========================================== */
        /* TARJETA DE CONFIGURACIÓN DE TIEMPOS - ACTUALIZADO */
        /* =========================================== */

        .time-config-card {
            border-left: 5px solid var(--success); 
        }

        /* Selector de modo de tiempo como grid */
        .time-mode-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            align-items: center;
            padding: 10px 0;
            margin-bottom: 20px;
        }

        /* Botones de modo como responsive-btn */
        .mode-btn {
            width: 100%;
            min-height: 48px;
            margin: 0;
            font-size: clamp(0.8rem, 2vw, 1rem);
            padding: 12px 15px;
            text-align: center;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, var(--primary) 0%, #1a2530 100%) !important;
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.5) !important;
            transform: scale(1.05);
        }

        /* Contenedor de botones en departures-header como grid */
        .departures-header .btn-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            width: 100%;
        }

        /* Los botones dentro de departures-header como responsive-btn */
        .departures-header .btn {
            width: 100%;
            min-height: 48px;
            margin: 0;
        }

        /* =========================================== */
        /* BOTÓN DE INICIO PRINCIPAL - DESTACADO */
        /* =========================================== */
        .start-main-btn-container {
            text-align: center;
            margin: 40px 0;
            padding: 30px;
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.1) 0%, rgba(52, 152, 219, 0.1) 100%);
            border-radius: var(--border-radius);
            border: 2px dashed var(--success);
        }

        .start-main-btn {
            min-width: 300px;
            padding: 22px 50px;
            font-size: 1.2rem;
            background: linear-gradient(135deg, var(--success) 0%, var(--secondary) 100%);
            position: relative;
            overflow: hidden;
        }

        .start-main-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.7s ease;
        }

        .start-main-btn:hover::before {
            left: 100%;
        }

        /* Botón de reinicio/salida en grid */
        #exit-complete-btn {
            width: 100%;
            max-width: 400px;
            margin: 20px auto 0;
            min-height: 48px;
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            border: none;
        }

        #exit-complete-btn:hover {
            background: linear-gradient(135deg, #8e44ad 0%, #732d91 100%);
            transform: translateY(-3px);
        }

        /* =========================================== */
        /* TABLA DE SALIDAS REGISTRADAS */
        /* =========================================== */
        .departures-card {
            border-left: 5px solid var(--danger);
        }

        .departures-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .departures-table-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
            border-radius: var(--border-radius);
        }

        .departures-table {
            width: 100%;
            border-collapse: collapse;
        }

        .departures-table th {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: var(--primary);
            font-weight: 600;
            padding: 15px 12px;
            text-align: left;
            border-bottom: 2px solid #dee2e6;
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: pointer;
            user-select: none;
        }

        .departures-table th:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
        }

        .departures-table th.sortable {
            position: relative;
            padding-right: 30px;
        }

        .departures-table th.sortable::after {
            content: '↕';
            position: absolute;
            right: 10px;
            opacity: 0.5;
            font-size: 12px;
        }

        .departures-table th.sortable.asc::after {
            content: '↑';
            opacity: 1;
        }

        .departures-table th.sortable.desc::after {
            content: '↓';
            opacity: 1;
        }

        .departures-table td {
            padding: 12px;
            border-bottom: 1px solid #f1f1f1;
            font-variant-numeric: tabular-nums;
            transition: background 0.2s ease;
        }

        .departures-table tr:last-child td {
            border-bottom: none;
        }

        .departures-table tr:hover td {
            background: #f8fafc;
        }

        .departure-number-cell {
            font-weight: 600;
            color: var(--primary);
            width: 120px;
        }

        .departure-time-cell {
            color: var(--dark);
            width: 160px;
        }

        .departure-notes-cell {
            color: var(--gray);
            min-width: 200px;
        }

        .departure-notes-input {
            width: 100%;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 14px;
            font-family: inherit;
            background: #fff;
            transition: all 0.3s;
        }

        .departure-notes-input:focus {
            outline: none;
            border-color: var(--secondary);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.1);
        }

        .departure-notes-display {
            padding: 8px 0;
            min-height: 36px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .departure-notes-display:hover {
            background: rgba(0, 0, 0, 0.03);
        }

        .departure-notes-display.empty {
            color: #aaa;
            font-style: italic;
        }

        .save-notes-btn {
            margin-top: 5px;
            padding: 6px 12px;
            font-size: 12px;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .save-notes-btn:hover {
            background: #27ae60;
        }

        .cancel-notes-btn {
            margin-top: 5px;
            margin-left: 5px;
            padding: 6px 12px;
            font-size: 12px;
            background: var(--danger);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .cancel-notes-btn:hover {
            background: #c0392b;
        }

        /* Estado vacío */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--gray);
            grid-column: 1 / -1;
        }

        .empty-state i {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        /* ================================================ */
        /* PANTALLA DE EJECUCIÓN - CON ELEMENTOS PEGADOS A ESQUINAS */
        /* ================================================ */

        .countdown-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1000;
            transition: background-color 0.5s ease;
        }

        .countdown-screen.active {
            display: block;
        }

        /* Contenedor principal que centra el número */
        .countdown-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            position: relative;
        }

        /* Display principal de cuenta atrás - CENTRADO VERTICALMENTE */
        .countdown-display {
            font-size: 30vw;
            font-weight: 900;
            color: white;
            text-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            font-variant-numeric: tabular-nums;
            margin: 0;
            line-height: 1;
            text-align: center;
            transition: all 0.3s ease;
        }

        /* Texto "Próxima salida en" - CENTRADO EN ESPACIO DISPONIBLE */
        .countdown-label {
            color: white;
            text-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            text-align: center;
            font-weight: 600;
            box-sizing: border-box;
            transition: opacity 0.3s ease;
            position: absolute;
            top: 10px; /* PEGADO AL EXTREMO SUPERIOR */
            left: 0;
            right: 0;
            z-index: 10;
            margin: 0;
            padding: 0 120px; /* ESPACIO REDUCIDO para esquinas pegadas */
            line-height: 50px; 
            height: 50px; 
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4vw;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        /* Elementos de información en pantalla - PEGADOS A ESQUINAS CON TAMAÑO DINÁMICO */
        .info-corner {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px 12px;
            border-radius: 0; /* SIN BORDES REDONDEADOS para esquinas */
            text-align: center;
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid rgba(255, 255, 255, 0.2);
            min-width: 160px;
            min-height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            /* TAMAÑO DINÁMICO BASADO EN PANTALLA */
            width: auto;
            max-width: 25vw;
            padding: 0.8vw 1.2vw;
        }

        .info-corner:hover {
            background-color: rgba(0, 0, 0, 0.8);
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, 0.4);
        }

        /* ESQUINA SUPERIOR IZQUIERDA - PEGADA AL EXTREMO */
        .top-left {
            top: 0;
            left: 0;
            border-top-left-radius: 0;
            border-bottom-right-radius: 10px;
        }

        /* ESQUINA INFERIOR IZQUIERDA - PEGADA AL EXTREMO */
        .bottom-left {
            bottom: 0;
            left: 0;
            border-bottom-left-radius: 0;
            border-top-right-radius: 10px;
        }

        /* ESQUINA INFERIOR DERECHA - PEGADA AL EXTREMO */
        .bottom-right {
            bottom: 0;
            right: 0;
            border-bottom-right-radius: 0;
            border-top-left-radius: 10px;
        }

        .info-label {
            font-size: clamp(10px, 1.2vw, 16px);
            opacity: 0.8;
            margin-bottom: 2px;
            display: block;
            line-height: 1.1;
        }

        .info-value {
            font-size: clamp(14px, 2vw, 24px);
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            line-height: 1.2;
            word-break: break-all;
            overflow-wrap: break-word;
            max-width: 100%;
        }

        /* ESTILO ESPECIAL PARA HORA ACTUAL */
        #current-time-value {
            font-size: clamp(12px, 1.8vw, 22px);
            color: #4CAF50;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            line-height: 1.2;
        }

        /* Icono de configuración - ESQUINA SUPERIOR DERECHA PEGADA */
        .config-toggle {
            position: absolute;
            top: 0; /* PEGADO AL EXTREMO SUPERIOR */
            right: 0; /* PEGADO AL EXTREMO DERECHO */
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            width: clamp(40px, 5vw, 50px);
            height: clamp(40px, 5vw, 50px);
            border-radius: 0; /* SIN BORDES REDONDEADOS */
            border-bottom-left-radius: 10px; /* Solo esquina inferior izquierda redondeada */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(16px, 2vw, 20px);
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 1002;
        }

        .config-toggle:hover {
            background-color: rgba(0, 0, 0, 0.8);
            transform: scale(1.1) rotate(90deg);
            border-color: rgba(255, 255, 255, 0.4);
        }

        /* Display de SALIDA - AJUSTADO AUTOMÁTICAMENTE A LA PANTALLA */
        .salida-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: 900;
            color: white;
            text-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1003;
            animation: salida-pulse 0.5s infinite alternate;
            text-align: center;
            line-height: 1.1;
            margin: 0;
            padding: 0;
            /* TAMAÑO DINÁMICO que se ajusta automáticamente */
            font-size: 20vw; /* Tamaño base */
            max-width: 90%; /* Nunca más del 90% del ancho */
            max-height: 90%; /* Nunca más del 90% del alto */
            overflow: hidden;
            word-wrap: break-word;
            white-space: normal;
            display: flex;
            align-items: center;
            justify-content: center;
            width: auto;
        }

        /* Clase para calcular tamaño óptimo - se añadirá con JavaScript */
        .salida-display.auto-size {
            font-size: min(20vw, 20vh); /* Usa el menor entre ancho y alto */
            padding: 0 5%;
        }

        @keyframes salida-pulse {
            from {
                transform: translate(-50%, -50%) scale(1);
                text-shadow: 0 0 30px rgba(255, 255, 255, 0.8);
            }
            to {
                transform: translate(-50%, -50%) scale(1.1);
                text-shadow: 0 0 60px rgba(255, 255, 255, 1);
            }
        }

        .salida-display.show {
            opacity: 1;
        }

        /* Ajuste para cuando se muestra SALIDA */
        .countdown-screen.countdown-salida-active .countdown-container {
            justify-content: center; /* Mantiene centrado verticalmente */
        }

        .countdown-screen.countdown-salida-active .countdown-label {
            opacity: 0 !important;
            visibility: hidden !important;
        }

        /* CORRECCIÓN: Ocultar número detrás de SALIDA */
        .countdown-screen.countdown-salida-active .countdown-display {
            display: none !important;
        }

        .countdown-screen.countdown-salida-active .salida-display.show {
            display: flex !important;
            opacity: 1 !important;
        }

        /* =========================================== */
        /* FOOTER REDISEÑADO */
        /* =========================================== */
        .app-footer {
            background: linear-gradient(135deg, var(--primary) 0%, #1a2530 100%);
            color: white;
            padding: 30px 0;
            margin-top: 40px;
            border-top: 4px solid var(--secondary);
        }

        .footer-content {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 25px;
        }

        .footer-left {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); /* Ajusta automáticamente */
            gap: 10px;
            width: 100%;
        }

        /* =========================================== */
        /* BOTONES DEL FOOTER - ESTILO UNIFICADO */
        /* =========================================== */
        .footer-btn {
            width: 100%;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            white-space: nowrap;
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); /* Color morado elegante */
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-decoration: none;
            gap: 10px;
            box-shadow: 0 4px 12px rgba(155, 89, 182, 0.3);
        }

        .footer-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%);
            transform-origin: 50% 50%;
        }

        .footer-btn:focus:not(:active)::after {
            animation: ripple 1s ease-out;
        }

        .footer-btn:hover {
            background: linear-gradient(135deg, #8e44ad 0%, #732d91 100%);
            transform: translateY(-3px);
            box-shadow: 0 6px 18px rgba(155, 89, 182, 0.4);
        }

        .footer-btn:active {
            transform: translateY(-1px);
        }

        .footer-btn i {
            font-size: 1.1rem;
        }

        /* Para mantener la disposición grid del footer */
        .footer-left {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            width: 100%;
        }

        /* =========================================== */
        /* MODALES (ESTILOS MEJORADOS) */
        /* =========================================== */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .modal.active {
            display: flex;
            animation: modalFadeIn 0.3s ease;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from { transform: translateY(-30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-header {
            padding: 25px 30px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, var(--primary) 0%, #1a2530 100%);
            color: white;
            border-radius: 15px 15px 0 0;
        }

        .modal-header h3 {
            color: white;
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0;
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: white;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(90deg);
        }

        .modal-body {
            padding: 30px;
        }

        .modal-footer {
            padding: 20px 30px;
            border-top: 1px solid #eee;
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            background: #f8f9fa;
            border-radius: 0 0 15px 15px;
        }

        /* Config modal durante cuenta atrás */
        .config-modal-during-countdown {
            background-color: rgba(0, 0, 0, 0.85) !important;
        }

        .config-modal-during-countdown .modal-content {
            background: var(--primary) !important;
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        /* CONTENEDOR */
        .modal-buttons-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
        }

        /* BOTONES */
        .modal-buttons-container .btn {
            width: 100% !important; /* Ocupa todo el ancho */
            min-height: 55px;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            justify-content: flex-start; /* Texto a la izquierda */
            text-align: left;
            font-size: 1rem;
            border-radius: 8px;
        }

        /* ÍCONOS */
        .modal-buttons-container .btn i {
            margin-right: 12px;
            min-width: 24px;
            font-size: 1.1rem;
        }

        /* =========================================== */
        /* ESTILOS PARA EL MODAL DE NUEVA CARRERA */
        /* =========================================== */
        .config-input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: var(--border-radius);
            font-size: 1rem;
            transition: all 0.3s ease;
            background: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .config-input:focus {
            outline: none;
            border-color: var(--secondary);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }

        .config-line {
            margin-bottom: 20px;
            width: 100%;
        }

        .config-line label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--dark);
            font-size: 1rem;
        }

        .config-input::placeholder {
            color: #aaa;
            opacity: 0.7;
        }

        textarea.config-input {
            min-height: 100px;
            resize: vertical;
            font-family: inherit;
            line-height: 1.5;
        }

        /* Estilos específicos para el modal de nueva carrera */
        #new-race-modal .modal-content {
            max-width: 500px;
        }

        #new-race-name-label,
        #new-race-desc-label {
            color: var(--dark);
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
        }

        #new-race-name,
        #new-race-description {
            width: 100%;
            margin-bottom: 15px;
        }

        #new-race-description {
            min-height: 100px;
            resize: vertical;
        }

        /* Ajustes responsivos */
        @media (max-width: 768px) {
            .config-input {
                padding: 10px 12px;
                font-size: 0.95rem;
            }
            
            #new-race-modal .modal-content {
                width: 95%;
                max-width: 95%;
            }
        }

        @media (max-width: 480px) {
            .config-input {
                padding: 8px 10px;
                font-size: 0.9rem;
            }
            
            #new-race-modal .modal-content {
                width: 98%;
                max-width: 98%;
            }
        }


        /* =========================================== */
        /* MENSAJES DE ESTADO */
        /* =========================================== */
        .message {
            position: fixed;
            top: 30px;
            right: 30px;
            padding: 18px 24px;
            border-radius: var(--border-radius);
            color: white;
            font-weight: 600;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            display: none;
            z-index: 3000;
            max-width: 400px;
            animation: slideIn 0.3s ease;
            backdrop-filter: blur(10px);
            border-left: 5px solid;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .message.success {
            background: rgba(46, 204, 113, 0.95);
            border-left-color: #27ae60;
        }

        .message.error {
            background: rgba(231, 76, 60, 0.95);
            border-left-color: #c0392b;
        }

        .message.warning {
            background: rgba(243, 156, 18, 0.95);
            border-left-color: #d68910;
            color: #333;
        }

        .message.info {
            background: rgba(52, 152, 219, 0.95);
            border-left-color: #2980b9;
        }

        /* =========================================== */
        /* EDITORES INLINE */
        /* =========================================== */
        .inline-edit {
            cursor: pointer;
            padding: 0px;
            border-radius: 6px;
            transition: background-color 0.3s;
        }

        .inline-edit:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .inline-edit-input {
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: inherit;
            font-weight: inherit;
            text-align: center;
            width: 100%;
            padding: 8px;
            border-radius: 6px;
        }

        /* =========================================== */
        /* OCULTAR ELEMENTOS EN EJECUCIÓN */
        /* =========================================== */
        .hide-on-countdown {
            transition: opacity 0.3s;
        }

        .countdown-screen.active ~ .hide-on-countdown {
            opacity: 0;
            pointer-events: none;
        }

        /* =========================================== */
        /* PUNTO DE INICIO SIMPLIFICADO */
        /* =========================================== */
        .start-point-simple {
            background: #f8f9fa;
            padding: 15px;
            border-radius: var(--border-radius);
            border: 1px solid #e9ecef;
            margin-top: 20px;
            text-align: center;
        }

        .start-point-simple .form-inline-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .start-point-simple input {
            font-weight: 600;
            color: var(--primary);
            width: 100px;
            text-align: center;
        }

        /* =========================================== */
        /* TIME INPUTS PARA INTERVALOS */
        /* =========================================== */
        .time-inputs {
            background: #f8f9fa;
            padding: 2px;
            border-radius: var(--border-radius);
            border: 1px dashed #dee2e6;
        }

        .interval-row {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: white;
            border-radius: var(--border-radius);
            margin-bottom: 12px;
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
        }

        .interval-row:hover {
            border-color: var(--secondary);
            background: #f8fafc;
        }

        .interval-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .interval-range {
            font-weight: 600;
            color: var(--primary);
            min-width: 140px;
        }

        .interval-time {
            color: var(--secondary);
            font-weight: 600;
        }

        /* Añade esto en la sección CSS */
        .notes-edit-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .notes-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .departure-notes-input {
            width: 100%;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 14px;
            font-family: inherit;
            background: #fff;
            transition: all 0.3s;
            resize: vertical;
            min-height: 60px;
            max-height: 120px;
        }

        .departure-notes-input:focus {
            outline: none;
            border-color: var(--secondary);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.1);
        }

        .save-notes-btn {
            padding: 6px 12px;
            font-size: 12px;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
            min-width: 70px;
        }

        .save-notes-btn:hover {
            background: #27ae60;
        }

        .cancel-notes-btn {
            padding: 6px 12px;
            font-size: 12px;
            background: var(--danger);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
            min-width: 70px;
        }

        .cancel-notes-btn:hover {
            background: #c0392b;
        }

        .departure-notes-display {
            padding: 8px;
            min-height: 36px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
            border: 1px solid transparent;
        }

        .departure-notes-display:hover {
            background: rgba(0, 0, 0, 0.03);
            border: 1px dashed #ddd;
        }

        .departure-notes-display.empty {
            color: #aaa;
            font-style: italic;
        }

        /* =========================================== */
        /* RESPONSIVE */
        /* =========================================== */
        @media (max-width: 992px) {
            .form-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .form-label {
                min-width: 100%;
                margin-bottom: 5px;
            }
            
            .btn-group {
                flex-direction: column;
            }
            
            .mode-btn {
                min-width: 100%;
            }
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 20px;
                text-align: center;
            }
            
            .app-title h1 {
                font-size: 24px;
            }
            
            .language-selector {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .card-body {
                padding: 10px;
            }
            
            .modal-content {
                width: 95%;
            }
            
            .footer-content {
                flex-direction: column;
                text-align: center;
                gap: 20px;
            }
            
            .footer-left {
                justify-content: center;
            }
            
            .copyright {
                font-size: 14px;
                text-align: center;
                margin-top: 20px;
            }

            .copyright a {
                color: var(--secondary);
                text-decoration: none;
                transition: color 0.3s;
            }

            .copyright a:hover {
                color: white;
                text-decoration: underline;
            }
            
            .start-main-btn {
                min-width: 100%;
                padding: 18px 30px;
            }
            
            /* Responsive para pantalla de ejecución */
            .countdown-display {
                font-size: 40vw;
            }
            
            .aggressive-numbers .countdown-display {
                font-size: 45vw !important;
            }
            
            /* Texto "Próxima salida en" en móviles */
            .countdown-label {
                top: 0;
                height: 45px;
                line-height: 45px;
                padding: 0 100px; /* Espacio reducido */
                font-size: 5vw;
            }
            
            /* Ajustes para info-corner en móviles */
            .info-corner {
                min-width: 140px;
                min-height: 45px;
                padding: 6px 10px;
                max-width: 30vw;
            }
            
            .config-toggle {
                width: 45px;
                height: 45px;
                font-size: 18px;
            }
            
            .info-label {
                font-size: 10px;
            }
            
            .info-value {
                font-size: 16px;
            }
            
            #current-time-value {
                font-size: 14px;
            }
            
            /* SALIDA ajustado automáticamente para móviles */
            .salida-display {
                font-size: min(18vw, 18vh); /* Se ajusta al menor dimension */
                max-width: 95%;
                max-height: 95%;
            }
            
            /* Ajustes tabla de salidas en móviles */
            .departures-table th,
            .departures-table td {
                padding: 8px 6px;
                font-size: 0.9rem;
            }
            
            .departure-number-cell {
                width: 80px;
            }
            
            .departure-time-cell {
                width: 130px;
            }
            
            .departure-notes-cell {
                min-width: 150px;
            }
            
            .departures-table th.sortable::after {
                right: 5px;
                font-size: 10px;
            }
            
            /* Botones responsive en móviles */
            .buttons-responsive-container,
            .race-selector,
            .time-mode-selector,
            .departures-header .btn-group,
            .footer-left {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
            }
            
            .responsive-btn,
            .footer-btn {
                padding: 10px 15px;
                font-size: 0.9rem;
                min-height: 44px;
            }
        }

        @media (max-width: 480px) {
            .app-title {
                flex-direction: column;
                text-align: center;
                gap: 10px;
            }
            
            .app-logo {
                width: 60px;
                height: 60px;
            }
            
            .btn {
                padding: 12px 20px;
                font-size: 0.95rem;
            }
            
            .btn-lg {
                padding: 16px 30px;
                font-size: 1.1rem;
            }
            
            .interval-info {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }
            
            .departures-header {
                flex-direction: column;
                gap: 15px;
                align-items: flex-start;
            }
            
            .message {
                left: 15px;
                right: 15px;
                max-width: none;
            }
            
            .start-options {
                flex-direction: column;
                align-items: flex-start;
            }
            
            /* Responsive para pantalla de ejecución - móviles pequeños */
            .countdown-display {
                font-size: 50vw;
            }
            
            .aggressive-numbers .countdown-display {
                font-size: 55vw !important;
            }
            
            /* Texto "Próxima salida en" en móviles pequeños */
            .countdown-label {
                top: 0;
                height: 40px;
                line-height: 40px;
                padding: 0 80px; /* Espacio mínimo */
                font-size: 6vw;
            }
            
            /* Ajustes para info-corner en móviles pequeños */
            .info-corner {
                min-width: 120px;
                min-height: 40px;
                padding: 4px 8px;
                max-width: 35vw;
            }
            
            .config-toggle {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
            
            .info-label {
                font-size: 9px;
                margin-bottom: 1px;
            }
            
            .info-value {
                font-size: 14px;
            }
            
            #current-time-value {
                font-size: 12px;
            }
            
            /* SALIDA en móviles pequeños - ajuste más agresivo */
            .salida-display {
                font-size: min(16vw, 16vh);
                max-width: 98%;
                max-height: 98%;
                padding: 0 3%;
            }
            
            /* Ajustes tabla de salidas en móviles pequeños */
            .departures-table {
                font-size: 12px !important; /* Tamaño de fuente fijo */
            }

            .departures-table th {
                font-size: 12px;
                padding: 10px 8px;
            }

            .departures-table td {
                font-size: 12px;
                padding: 8px 6px;
            }
            
            .departure-dorsal-cell {
                font-weight: 600;
                color: var(--primary);
                width: 100px;
            }

            .departure-time-value-cell {
                color: var(--dark);
                width: 120px;
                font-variant-numeric: tabular-nums;
            }

            .departure-notes-cell {
                color: var(--gray);
                min-width: 200px;
            }

            .departure-date-cell {
                color: var(--secondary);
                width: 150px;
                font-size: 11px;
            }
            
            /* Botones responsive en móviles pequeños */
            .buttons-responsive-container,
            .race-selector,
            .time-mode-selector,
            .departures-header .btn-group,
            .footer-left {
                grid-template-columns: 1fr;
                gap: 8px;
            }
            
            .responsive-btn,
            .footer-btn {
                padding: 8px 12px;
                font-size: 0.85rem;
                min-height: 40px;
            }
            
            /* Ocultar texto si no cabe en pantallas muy pequeñas */
            @media (max-width: 360px) {
                .countdown-label {
                    font-size: 5.5vw;
                    padding: 0 70px;
                }
                
                .info-corner {
                    min-width: 110px;
                    min-height: 35px;
                    padding: 3px 6px;
                    max-width: 40vw;
                }
                
                .config-toggle {
                    width: 35px;
                    height: 35px;
                    font-size: 14px;
                }
                
                .salida-display {
                    font-size: min(14vw, 14vh);
                    max-width: 99%;
                }
                
                .departures-table {
                    font-size: 0.75rem;
                }
                
                .departure-notes-input {
                    font-size: 0.75rem;
                    padding: 6px 8px;
                }
                
                .save-notes-btn,
                .cancel-notes-btn {
                    font-size: 10px;
                    padding: 4px 8px;
                }
            }
        }

        /* Orientación horizontal específica */
        @media (max-height: 500px) and (orientation: landscape) {
            .salida-display {
                font-size: min(15vw, 15vh); /* Más pequeño en landscape */
                max-width: 85%;
            }
            
            .countdown-label {
                height: 35px;
                line-height: 35px;
                font-size: 4vw;
            }
            
            .info-corner {
                min-height: 35px;
            }
            
            .config-toggle {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
            
            .departures-table-container {
                max-height: 250px;
            }
        }

        /* =========================================== */
        /* ESTILOS PARA TRAMOS - ACTUALIZADOS */
        /* =========================================== */
        .interval-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 15px;
            min-width: 0; /* Permite que se comprima */
        }

        .interval-range {
            font-weight: 600;
            color: var(--primary);
            min-width: 120px; /* Reducido */
            white-space: nowrap;
        }

        .interval-time {
            color: var(--secondary);
            font-weight: 600;
            white-space: nowrap;
        }

        /* Eliminar los elementos que ya no queremos */
        .interval-status,
        .interval-corredors {
            display: none !important;
        }

        /* Contenedor de acciones de intervalo - AHORA RESPONSIVE */
        .interval-actions {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap; /* Permite que los botones bajen */
            justify-content: flex-end;
            min-width: 140px; /* Ancho mínimo para dos botones */
        }

        /* Botones de intervalo más compactos */
        .edit-interval-btn,
        .remove-interval-btn {
            padding: 6px 10px !important;
            font-size: 12px !important;
            min-width: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        /* Ocultar texto del botón en pantallas pequeñas */
        .edit-interval-btn .btn-text,
        .remove-interval-btn .btn-text {
            display: inline;
        }

        /* En pantallas muy pequeñas, mostrar solo iconos */
        @media (max-width: 480px) {
            .edit-interval-btn .btn-text,
            .remove-interval-btn .btn-text {
                display: none;
            }
            
            .edit-interval-btn,
            .remove-interval-btn {
                min-width: 40px;
                padding: 6px 8px !important;
            }
            
            .edit-interval-btn i,
            .remove-interval-btn i {
                margin: 0;
            }
        }

        /* Para pantallas medianas donde el espacio es limitado */
        @media (max-width: 768px) {
            .interval-row {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            
            .interval-info {
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .interval-range {
                min-width: 100px;
            }
            
            .interval-actions {
                width: 100%;
                justify-content: flex-start;
                margin-top: 5px;
            }
        }

        /* Para pantallas muy estrechas */
        @media (max-width: 360px) {
            .interval-info {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .interval-range,
            .interval-time {
                width: 100%;
            }
        }

    /* =========================================== */
    /* NUEVOS ESTILOS PARA CONFIGURACIÓN DE AUDIO - SIMPLIFICADO */
    /* =========================================== */
    .audio-config-section {
        background: #f8f9fa;
        border-radius: var(--border-radius);
        padding: 15px;
        margin-top: 15px;
        border: 1px solid #e9ecef;
    }

    .audio-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 12px;
        margin-top: 10px;
    }

    .audio-option {
        background: white;
        border: 2px solid #e0e0e0;  
        border-radius: var(--border-radius);
        padding: 15px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        position: relative;
    }

    .audio-option:hover {
        border-color: var(--secondary);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.1);
    }

    .audio-option.active {
        border-color: var(--success);
        background: linear-gradient(135deg, rgba(46, 204, 113, 0.1) 0%, rgba(52, 152, 219, 0.1) 100%);
        box-shadow: 0 4px 12px rgba(46, 204, 113, 0.15);
    }

    .audio-option i {
        font-size: 1.5rem;
        color: var(--primary);
    }

    .audio-option.active i {
        color: var(--success);
    }

    .audio-option .option-title {
        font-weight: 600;
        font-size: 1rem;
        color: var(--dark);
        line-height: 1.2;
    }

    /* Texto de descripción oculto por defecto, mostrado en tooltip */
    .audio-option .option-desc {
        display: none;
    }

    /* Tooltip al pasar el cursor */
    .audio-option:hover::after {
        content: attr(title);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 0.85rem;
        white-space: nowrap;
        z-index: 1000;
        margin-bottom: 8px;
        pointer-events: none;
    }

    .audio-option:hover::before {
        content: '';
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 6px solid transparent;
        border-top-color: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        margin-bottom: -4px;
        pointer-events: none;
    }

    .audio-test-btn {
        margin-top: 15px;
        padding: 8px 16px;
        background: var(--secondary);
        color: white;
        border: none;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
        justify-content: center;
        transition: all 0.3s;
        font-size: 0.95rem;
    }

    .audio-test-btn:hover {
        background: #2980b9;
        transform: translateY(-2px);
    }

    /* Responsive para configuración de audio */
    @media (max-width: 768px) {
        .audio-options {
            grid-template-columns: 1fr;
        }
        
        .audio-option {
            padding: 12px;
        }
        
        .audio-option i {
            font-size: 1.3rem;
        }
    }
    </style>
</head>
<body>
    <!-- =========================================== -->
    <!-- HEADER -->
    <!-- =========================================== -->
    <header class="app-header hide-on-countdown">
        <div class="container">
            <div class="header-content">
                <div class="app-title">
                    <img src="https://rbenet71.github.io/Web/Árbitro/crono_cuenta_atras/Crono_cuenta_atras_192_192.png" 
                         alt="Logo Crono Cuenta Atrás" 
                         class="app-logo">
                    <h1 id="app-title-text">Crono Cuenta Atrás</h1>
                </div>
                <div class="header-controls">
                    <div class="language-selector">
                        <div class="languages-label" id="languages-label">Idioma / Language</div>
                        <img src="https://flagcdn.com/w40/es.png" class="flag active" id="flag-es" data-lang="es">
                        <div class="flag flag-catalunya" id="flag-ca" data-lang="ca"></div>
                        <img src="https://flagcdn.com/w40/gb.png" class="flag" id="flag-en" data-lang="en">
                        <img src="https://flagcdn.com/w40/fr.png" class="flag" id="flag-fr" data-lang="fr">
                        <i class="fas fa-question-circle help-icon" id="help-icon-header" title="Ayuda"></i>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- =========================================== -->
    <!-- CONTENIDO PRINCIPAL - CONFIGURACIÓN -->
    <!-- =========================================== -->
    <main class="main-content hide-on-countdown">
        <div class="container">
            <!-- Tarjeta 1: Gestión de carrera -->
            <div class="app-card race-management-card">
                <div class="card-header">
                    <h2><i class="fas fa-flag-checkered"></i> <span id="card-race-title">Gestión de Carrera</span></h2>
                </div>
                <div class="race-selector">
                    <select id="race-select" class="form-control">
                        <option value="">-- Selecciona una carrera --</option>
                    </select>
                    <button class="btn btn-primary responsive-btn" id="new-race-btn">
                        <i class="fas fa-plus"></i>
                        <span id="new-race-text">Nueva</span>
                    </button>
                    <button class="btn btn-danger responsive-btn" id="delete-race-btn">
                        <i class="fas fa-trash"></i>
                        <span id="delete-race-text">Eliminar</span>
                    </button>
                </div>
            </div>
            <!-- =========================================== -->
            <!-- NUEVA TARJETA: CONFIGURACIÓN DE AUDIO -->
            <!-- =========================================== -->
            <div class="app-card audio-config-card">
                <div class="card-header">
                    <h2><i class="fas fa-volume-up"></i> <span id="audio-config-title">Configuración de Audio</span></h2>
                </div>
                <div class="card-body">
                    <div class="config-section">
                        <div class="audio-config-section">
                            <div class="audio-options" id="audio-options">
                                <div class="audio-option active" 
                                    data-audio-type="beep"
                                    title="Beeps electrónicos para cada segundo">
                                    <i class="fas fa-bell"></i>
                                    <div class="option-title" id="beep-option-title">Sonidos Beep</div>
                                </div>
                                
                                <div class="audio-option" 
                                    data-audio-type="voice"
                                    title="Voz humana contando en tu idioma">
                                    <i class="fas fa-microphone-alt"></i>
                                    <div class="option-title" id="voice-option-title">Voz grabada</div>
                                </div>
                                
                                <div class="audio-option" 
                                    data-audio-type="none"
                                    title="Solo efectos visuales">
                                    <i class="fas fa-volume-mute"></i>
                                    <div class="option-title" id="mute-option-title">Sin sonido</div>
                                </div>
                            </div>
                            
                            <div style="text-align: center; margin-top: 15px;">
                                <button class="audio-test-btn" id="test-audio-btn">
                                    <i class="fas fa-play-circle"></i>
                                    <span id="test-audio-text">Probar sonido actual</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tarjeta 2: Configuración de tiempos -->
            <div class="app-card time-config-card">
                <div class="card-header">
                    <h2><i class="fas fa-clock"></i> <span id="card-time-title">Configuración de Tiempos</span></h2>
                </div>
                <div class="card-body">
                    <div class="config-section">
                        <div class="time-mode-selector">
                            <button class="btn btn-primary responsive-btn mode-btn" id="same-interval-btn">
                                <i class="fas fa-equals"></i>
                                <span id="same-interval-text">Siempre igual</span>
                            </button>
                            <button class="btn btn-warning responsive-btn mode-btn" id="variable-interval-btn">
                                <i class="fas fa-list-ol"></i>
                                <span id="variable-interval-text">Varios tramos</span>
                            </button>
                        </div>
                        <!-- Configuración de intervalo único -->
                        <div id="single-interval-config" class="time-inputs">
                            <div class="form-group">
                                <div class="section-title">
                                    <i class="fas fa-stopwatch"></i>
                                    <span id="interval-time-label">Tiempo entre salidas</span>
                                </div>
                                <div class="form-row">
                                    <div class="input-with-unit">
                                        <input type="number" id="interval-minutes" class="form-control form-control-sm" min="0" value="1">
                                        <span class="unit" id="minutes-text">minutos</span>
                                    </div>
                                    <div class="input-with-unit">
                                        <input type="number" id="interval-seconds" class="form-control form-control-sm" min="0" max="59" value="0">
                                        <span class="unit" id="seconds-text">segundos</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Configuración de intervalos variables -->
                        <div id="variable-interval-config" class="time-inputs" style="display: none;">
                            <div class="form-group">
                                <div class="section-title">
                                    <i class="fas fa-plus-circle"></i>
                                    <span id="add-interval-label">Añadir nuevo tramo</span>
                                </div>
                                <div class="form-row">
                                    <div class="input-with-unit">
                                        <input type="number" id="from-corredor" class="form-control form-control-sm" min="1" value="1">
                                        <span class="unit">desde</span>
                                    </div>
                                    <div class="input-with-unit">
                                        <input type="number" id="to-corredor" class="form-control form-control-sm" min="1" value="10">
                                        <span class="unit" id="to-text">hasta</span>
                                    </div>
                                    <div class="input-with-unit">
                                        <input type="number" id="var-minutes" class="form-control form-control-sm" min="0" value="1">
                                        <span class="unit">min</span>
                                    </div>
                                    <div class="input-with-unit">
                                        <input type="number" id="var-seconds" class="form-control form-control-sm" min="0" max="59" value="0">
                                        <span class="unit">seg</span>
                                    </div>
                                    <button class="btn btn-success responsive-btn" id="add-interval-btn">
                                        <i class="fas fa-plus"></i>
                                        <span id="add-interval-text">Añadir</span>
                                    </button>
                                </div>
                            </div>
                            <div class="form-group">
                                <div class="section-title" >
                                    <i class="fas fa-list-ul"></i>
                                    <span  id="configured-sections-label">Tramos configurados</span>
                                </div>
                                <div id="intervals-list">
                                    <!-- Los intervalos se agregarán aquí dinámicamente -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Botón principal de inicio -->
            <div class="start-main-btn-container">
                <button class="btn btn-success btn-lg start-main-btn" id="start-countdown-btn">
                    <i class="fas fa-rocket"></i>
                    <span id="start-countdown-text">INICIAR CUENTA ATRÁS</span>
                </button>
                
                <!-- =========================================== -->
                <!-- PUNTO DE INICIO SIMPLIFICADO -->
                <!-- =========================================== -->
                <div class="start-point-simple">
                    <div class="form-inline-group">
                        <span id="start-from-x-text">Posición actual:</span>
                        <input type="number" id="start-position" class="form-control form-control-sm" min="1" value="1">
                    </div>
                </div>
                
                <button class="btn btn-danger responsive-btn btn-block" id="exit-complete-btn" style="max-width: 400px; margin: 20px auto 0;">
                    <i class="fas fa-sign-out-alt"></i>
                    <span id="exit-complete-text">REINICIAR</span>
                </button>
            </div>

            <!-- Tarjeta 4: Salidas registradas -->
            <div class="app-card departures-card">
                <div class="card-header">
                    <h2><i class="fas fa-history"></i> <span id="card-departures-title">Salidas Registradas</span></h2>
                </div>
                <div class="card-body">
                    <div class="config-section">
                        <div class="departures-header">
                            <div class="btn-group">
                                <button class="btn btn-danger responsive-btn" id="clear-departures-btn">
                                    <i class="fas fa-broom"></i>
                                    <span id="clear-departures-text">Limpiar lista</span>
                                </button>
                                <button class="btn btn-success responsive-btn" id="export-excel-btn">
                                    <i class="fas fa-file-excel"></i>
                                    <span id="export-excel-text">Exportar Excel</span>
                                </button>
                            </div>
                        </div>
                        <div id="departures-table-container" class="departures-table-container">
                            <table class="departures-table" id="departures-table">
                                <thead>
                                    <tr>
                                        <th class="sortable" data-sort="dorsal" id="departure-header-dorsal">Salida</th>
                                        <th class="sortable" data-sort="timeValue" id="departure-header-time">Tiempo</th>
                                        <th class="sortable" data-sort="notes" id="departure-header-notes">Nota</th>
                                        <th class="sortable" data-sort="date" id="departure-header-date">Hora</th>
                                    </tr>
                                </thead>
                                <tbody id="departures-table-body">
                                    <!-- Las filas se agregarán aquí dinámicamente -->
                                </tbody>
                            </table>
                            <div id="departures-empty" class="empty-state" style="display: none;">
                                <i class="fas fa-clock"></i>
                                <p id="no-departures-text">No hay salidas registradas</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </main>

    <!-- =========================================== -->
    <!-- PANTALLA DE EJECUCIÓN (REDISEÑADA) -->
    <!-- =========================================== -->
    <div class="countdown-screen" id="countdown-screen">
        <div class="config-toggle" id="config-toggle">
            <i class="fas fa-cog"></i>
        </div>

        <div class="countdown-container">
            <div class="countdown-label" id="countdown-label">Salida en</div>
            <div class="countdown-display" id="countdown-display">60</div>
        </div>

        <div class="info-corner top-left">
            <span class="info-label" id="total-time-label">Tiempo total</span>
            <div class="info-value" id="total-time-value">00:00:00</div>
            <div class="info-value" id="current-time-value">00:00:00</div>
        </div>
        
        <div class="info-corner bottom-left">
            <span class="info-label" id="next-corredor-label">Próximo sale a</span>
            <div class="info-value inline-edit" id="next-corredor-time">1:00</div>
        </div>
        
        <div class="info-corner bottom-right">
            <span class="info-label" id="departed-label">Salidos</span>
            <div class="info-value inline-edit" id="departed-count">0</div>
        </div>

        <div class="salida-display" id="salida-display">SALIDA</div>
    </div>

    <!-- =========================================== -->
    <!-- FOOTER -->
    <!-- =========================================== -->
    <footer class="app-footer hide-on-countdown">
        <div class="container">
            <div class="footer-content">
                <div class="footer-left">
                    <button class="footer-btn" id="footer-help-btn">
                        <i class="fas fa-question-circle"></i>
                        <span id="help-text">Ayuda</span>
                    </button>
                    <button class="footer-btn" id="suggestions-btn">
                        <i class="fas fa-lightbulb"></i>
                        <span id="suggestions-text">Sugerencias</span>
                    </button>
                    <button class="footer-btn" id="install-btn">
                        <i class="fas fa-download"></i>
                        <span id="install-text">Instalar App</span>
                    </button>
                    <button class="footer-btn" id="update-btn">
                        <i class="fas fa-sync-alt"></i>
                        <span id="update-text">Buscar actualizaciones</span>
                    </button>
                </div>
                <div class="copyright" id="copyright-text">
                    2025 © Copyright 
                    <a href="https://rbenet71.github.io/Web/" target="_blank" id="copyright-link">
                        Roberto Benet - rbenet71@gmail.com - V_17_12_2025
                    </a>
                </div>
            </div>
        </div>
    </footer>

    <!-- =========================================== -->
    <!-- MODALES -->
    <!-- =========================================== -->
    
    <!-- Modal de ayuda -->
    <div class="modal" id="help-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="help-modal-title">Ayuda de Crono Cuenta Atrás</h3>
                <button class="modal-close" id="help-modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <p id="help-modal-text1">Crono Cuenta Atrás es una aplicación para controlar las salidas en carreras con cuenta atrás visual y sonora.</p>
                
                <h4 id="help-modal-subtitle1">Cómo usar:</h4>
                <ul id="help-modal-list">
                    <li><strong>Selecciona una carrera</strong> o crea una nueva</li>
                    <li><strong>Configura la cadencia de salida</strong> (siempre igual o por tramos)</li>
                    <li><strong>Inicia desde el corredor 1</strong> o desde una posición específica</li>
                    <li><strong>Pulsa "INICIAR CUENTA ATRÁS"</strong> para comenzar</li>
                    <li><strong>La pantalla cambiará</strong> mostrando la cuenta atrás grande</li>
                    <li><strong>Cuando llegue a cero</strong> se mostrará "SALIDA" y comenzará la cuenta para el siguiente</li>
                </ul>
                
                <h4 id="help-modal-subtitle2">Indicadores visuales:</h4>
                <ul>
                    <li><strong id="red-background-text">Fondo ROJO:</strong> <span id="countdown-normal-desc">Cuenta atrás normal</span></li>
                    <li><strong id="yellow-background-text">Fondo AMARILLO:</strong> <span id="countdown-warning-desc">Últimos 10 segundos</span></li>
                    <li><strong id="green-background-text">Fondo VERDE:</strong> <span id="countdown-salida-desc">Momento de salida (2 segundos)</span></li>
                    <li><strong id="red-numbers-text">Números ROJOS pulsantes:</strong> <span id="countdown-critical-desc">Últimos 5 segundos</span></li>
                </ul>
                
                <h4 id="help-modal-subtitle3">Sonidos:</h4>
                <ul>
                    <li><strong id="beep-high-text">Beep agudo:</strong> <span id="beep-high-desc">Al llegar a 10 segundos</span></li>
                    <li><strong id="beep-every-second-text">Beep cada segundo:</strong> <span id="beep-every-second-desc">Últimos 5 segundos</span></li>
                    <li><strong id="beep-low-text">Beep grave:</strong> <span id="beep-low-desc">Al llegar a cero</span></li>
                </ul>
                
                <p id="help-modal-text2">Los 2 segundos de "SALIDA" se restan automáticamente del tiempo de la siguiente cuenta atrás.</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="help-modal-ok">Entendido</button>
            </div>
        </div>
    </div>

    <!-- Al final de los modales (después del modal de nueva carrera, línea ~1650) -->
    <!-- Modal de confirmación reiniciar/salir -->
    <div class="modal" id="restart-confirm-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="restart-modal-title">Confirmar reinicio completo</h3>
                <button class="modal-close" id="restart-modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <p id="restart-modal-text">¿Estás seguro de que quieres reiniciar completamente? Esta acción:</p>
                <ul style="margin: 15px 0; padding-left: 20px;">
                    <li>Detendrá la cuenta atrás si está activa</li>
                    <li>Borrará todos los datos de la sesión actual</li>
                    <li>Reiniciará los contadores a cero</li>
                    <li>Volverá a la pantalla de configuración inicial</li>
                </ul>
                <p style="color: var(--danger); font-weight: 600;">
                    Esta acción no se puede deshacer.
                </p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-danger" id="restart-confirm-btn">Sí, reiniciar completamente</button>
                <button class="btn" id="restart-cancel-btn">Cancelar</button>
            </div>
        </div>
    </div>
    <!-- Modal de configuración durante cuenta atrás -->
    <div class="modal" id="config-during-countdown-modal">
        <div class="modal-content config-modal-during-countdown">
            <div class="modal-header">
                <h3>Configuración</h3>
                <button class="modal-close" id="config-during-countdown-close">&times;</button>
            </div>
            <div class="modal-body">
                <p>La cuenta atrás continúa en segundo plano.</p>
                <div class="modal-buttons-container">
                    <button class="btn btn-success" id="resume-countdown-btn">
                        <i class="fas fa-play"></i> Continuar viendo
                    </button>
                    <button class="btn btn-warning" id="stop-countdown-btn">
                        <i class="fas fa-stop"></i> Detener cuenta atrás
                    </button>
                    <button class="btn btn-primary" id="adjust-times-btn">
                        <i class="fas fa-edit"></i> Ajustar tiempos
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de ajuste de tiempos -->
    <div class="modal" id="adjust-times-modal">
        <div class="modal-content config-modal-during-countdown">
            <div class="modal-header">
                <h3>Ajustar Tiempos</h3>
                <button class="modal-close" id="adjust-times-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="config-line" style="flex-direction: column; align-items: stretch;">
                    <label for="adjust-next-time">Próximo tiempo (segundos):</label>
                    <input type="number" id="adjust-next-time" class="config-input" min="1" value="60">
                </div>
                <div class="config-line" style="flex-direction: column; align-items: stretch;">
                    <label for="adjust-departed">Corredores salidos:</label>
                    <input type="number" id="adjust-departed" class="config-input" min="0" value="0">
                </div>
                <!-- ELIMINAR ESTE CAMPO -->
                <!-- <div class="config-line" style="flex-direction: column; align-items: stretch;">
                    <label for="adjust-current-time">Tiempo actual (segundos):</label>
                    <input type="number" id="adjust-current-time" class="config-input" min="0" value="60">
                </div> -->
                <div class="modal-buttons-container">
                    <button class="btn btn-success" id="save-adjustments-btn">
                        <i class="fas fa-save"></i> Guardar ajustes
                    </button>
                    <button class="btn" id="cancel-adjustments-btn">
                        <i class="fas fa-times"></i> Cancelar
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de confirmación eliminar carrera -->
    <div class="modal" id="delete-race-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="delete-race-modal-title">Confirmar eliminación</h3>
                <button class="modal-close" id="delete-race-modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <p id="delete-race-modal-text">¿Estás seguro de que quieres eliminar esta carrera? Todos los datos se perderán.</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-danger" id="delete-race-confirm-btn">Eliminar</button>
                <button class="btn" id="delete-race-cancel-btn">Cancelar</button>
            </div>
        </div>
    </div>
    <!-- Modal de edición de tramo (añadir después del modal de ajuste de tiempos) -->
    <div class="modal" id="edit-interval-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="edit-interval-modal-title">Editar Tiempo por Tramo</h3>
                <button class="modal-close" id="edit-interval-modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <form id="edit-interval-form" class="edit-interval-form">
                    <div class="edit-interval-row">
                        <label class="edit-interval-label" for="edit-from-corredor">Desde:</label>
                        <input type="number" 
                            id="edit-from-corredor" 
                            class="form-control edit-interval-input" 
                            min="1" 
                            required>
                    </div>
                    <div class="edit-interval-row">
                        <label class="edit-interval-label" for="edit-to-corredor">Hasta:</label>
                        <input type="number" 
                            id="edit-to-corredor" 
                            class="form-control edit-interval-input" 
                            min="1" 
                            required>
                    </div>
                    <div class="edit-interval-row">
                        <label class="edit-interval-label" for="edit-interval-minutes">Minutos:</label>
                        <input type="number" 
                            id="edit-interval-minutes" 
                            class="form-control edit-interval-input" 
                            min="0" 
                            required>
                    </div>
                    <div class="edit-interval-row">
                        <label class="edit-interval-label" for="edit-interval-seconds">Segundos:</label>
                        <input type="number" 
                            id="edit-interval-seconds" 
                            class="form-control edit-interval-input" 
                            min="0" 
                            max="59" 
                            required>
                    </div>
                    <div class="edit-interval-buttons">
                        <button type="button" class="btn btn-success" id="save-edit-interval-btn">
                            <i class="fas fa-save"></i> Guardar Cambios
                        </button>
                        <button type="button" class="btn btn-outline" id="cancel-edit-interval-btn">
                            Cancelar
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    <!-- Modal de confirmación limpiar salidas -->
    <div class="modal" id="clear-departures-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="clear-departures-modal-title">Confirmar limpieza</h3>
                <button class="modal-close" id="clear-departures-modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <p id="clear-departures-modal-text">¿Estás seguro de que quieres limpiar la lista de salidas? Esta acción no se puede deshacer.</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-danger" id="clear-departures-confirm-btn">Limpiar</button>
                <button class="btn" id="clear-departures-cancel-btn">Cancelar</button>
            </div>
        </div>
    </div>

    <!-- Modal de sugerencias -->
    <div class="modal" id="suggestions-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="suggestions-modal-title">Enviar sugerencias</h3>
                <button class="modal-close" id="suggestions-modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <form id="suggestion-form">
                    <div class="config-line" style="flex-direction: column; align-items: stretch;">
                        <label for="suggestion-email" id="suggestion-email-label">Email (opcional):</label>
                        <input type="email" id="suggestion-email" class="config-input" placeholder="tu@email.com">
                    </div>
                    <div class="config-line" style="flex-direction: column; align-items: stretch;">
                        <label for="suggestion-text" id="suggestion-text-label">Sugerencias:</label>
                        <textarea id="suggestion-text" class="config-input" rows="5" placeholder="Tus ideas para mejorar la aplicación..."></textarea>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="send-suggestion-btn">Enviar</button>
                <button class="btn" id="cancel-suggestion-btn">Cancelar</button>
            </div>
        </div>
    </div>

    <!-- Modal de nueva carrera -->
    <!-- Modal de nueva carrera -->
    <div class="modal" id="new-race-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="new-race-modal-title">Nueva carrera</h3>
                <button class="modal-close" id="new-race-modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="new-race-name" id="new-race-name-label">Nombre de la carrera:</label>
                    <input type="text" 
                        id="new-race-name" 
                        class="form-control config-input" 
                        placeholder="Ej: Carrera MTB 2025"
                        maxlength="100">
                </div>
                <div class="form-group">
                    <label for="new-race-description" id="new-race-desc-label">Descripción (opcional):</label>
                    <textarea id="new-race-description" 
                            class="form-control config-input" 
                            rows="4" 
                            placeholder="Información adicional sobre la carrera..."
                            maxlength="500"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-success" id="create-race-btn">Crear carrera</button>
                <button class="btn btn-outline" id="cancel-create-race-btn">Cancelar</button>
            </div>
        </div>
    </div>

    <!-- Video oculto para mantener pantalla activa -->
    <video id="keep-alive-video" style="display: none;" muted playsinline>
        <source src="https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4" type="video/mp4">
    </video>

    <!-- Mensajes flotantes -->
    <div id="message" class="message"></div>

    <!-- =========================================== -->
    <!-- SCRIPT JAVASCRIPT CORREGIDO -->
    <!-- =========================================== -->
    <script>
        // ============================================
        // ESTADO DE LA APLICACIÓN
        // ============================================
        const appState = {
            audioType: 'beep', // 'beep', 'voice', o 'none'
    
            // Para almacenar los audios precargados
            voiceAudioCache: {},
            
            // Para el audio de salida
            currentLanguage: 'es',
            currentRace: null,
            races: [],
            countdownActive: false,
            countdownValue: 0,
            countdownInterval: null,
            raceStartTime: null,
            departedCount: 0,
            nextCorredorTime: 60,
            intervals: [],
            currentIntervalIndex: 0,
            departureTimes: [],
            audioContext: null,
            isSalidaShowing: false,
            salidaTimeout: null,
            deferredPrompt: null,
            updateAvailable: false,
            countdownPaused: false,
            accumulatedTime: 0,
            configModalOpen: false,
            variableIntervalConfig: {
                intervals: [],
                saved: false
            },
            soundEnabled: true,
            aggressiveMode: false,
            // NUEVA PROPIEDAD: Para saber si estamos en modo variable
            isVariableMode: false
        };
        window.savingNotesIndex = null;

        // ============================================
        // TRADUCCIONES ACTUALIZADAS COMPLETAS
        // ============================================
        const translations = {
            es: {
                appTitle: "Crono Cuenta Atrás",
                languagesLabel: "Idioma / Language",
                cardRaceTitle: "Gestión de Carrera",
                newRaceText: "Nueva",
                deleteRaceText: "Eliminar",
                cardTimeTitle: "Configuración de Tiempos",
                cadenceTitle: "Cadencia de salida",
                sameIntervalText: "Siempre igual",
                variableIntervalText: "Varios tramos",
                intervalTimeLabel: "Tiempo entre salidas",
                minutesText: "minutos",
                secondsText: "segundos",
                addIntervalLabel: "Añadir nuevo tramo",
                toText: "hasta",
                addIntervalText: "Añadir",
                currentPositionText: "Posición actual:",
                cardStartTitle: "Punto de Inicio",
                startFromLabel: "Iniciar desde",
                startFromZeroText: "Comenzar desde el corredor 1",
                startFromXText: "O desde la posición:",
                cardDeparturesTitle: "Salidas Registradas",
                clearDeparturesText: "Limpiar lista",
                exportExcelText: "Exportar Excel",
                startCountdownText: "INICIAR CUENTA ATRÁS",
                exitCompleteText: "REINICIAR",
                totalTimeLabel: "Tiempo total",
                countdownlabel: "Salida en",
                nextCorredorLabel: "Próximo sale a",
                departedLabel: "Salidos",
                helpText: "Ayuda",
                suggestionsText: "Sugerencias",
                installText: "Instalar App",
                updateText: "Buscar actualizaciones",
                helpModalTitle: "Ayuda de Crono Cuenta Atrás",
                helpModalText1: "Crono Cuenta Atrás es una aplicación para controlar las salidas en carreras con cuenta atrás visual y sonora.",
                helpModalSubtitle1: "Cómo usar:",
                helpModalList: [
                    "Selecciona una carrera o crea una nueva",
                    "Configura la cadencia de salida (siempre igual o por tramos)",
                    "Inicia desde el corredor 1 o desde una posición específica",
                    "Pulsa 'INICIAR CUENTA ATRÁS' para comenzar",
                    "La pantalla cambiará mostrando la cuenta atrás grande",
                    "Cuando llegue a cero se mostrará 'SALIDA' y comenzará la cuenta para el siguiente"
                ],
                helpModalSubtitle2: "Indicadores visuales:",
                helpModalSubtitle3: "Sonidos:",
                helpModalText2: "Los 2 segundos de 'SALIDA' se restan automáticamente del tiempo de la siguiente cuenta atrás.",
                deleteRaceModalTitle: "Confirmar eliminación",
                deleteRaceModalText: "¿Estás seguro de que quieres eliminar esta carrera? Todos los datos se perderán.",
                clearDeparturesModalTitle: "Confirmar limpieza",
                clearDeparturesModalText: "¿Estás seguro de que quieres limpiar la lista de salidas? Esta acción no se puede deshacer.",
                suggestionsModalTitle: "Enviar sugerencias",
                suggestionEmailLabel: "Email (opcional):",
                suggestionTextLabel: "Sugerencias:",
                newRaceModalTitle: "Nueva carrera",
                newRaceNameLabel: "Nombre de la carrera:",
                newRaceDescLabel: "Descripción (opcional):",
                restartModalTitle: "Confirmar reinicio completo",
                restartModalText: "¿Estás seguro de que quieres reiniciar completamente? Esta acción:",
                deleteConfirm: "Eliminar",
                cancel: "Cancelar",
                understood: "Entendido",
                createRace: "Crear carrera",
                sendSuggestion: "Enviar",
                clear: "Limpiar",
                restartConfirm: "Sí, reiniciar completamente",
                selectRaceFirst: "Por favor, selecciona una carrera primero",
                countdownStarted: "Cuenta atrás iniciada",
                countdownStopped: "Cuenta atrás detenida",
                raceCreated: "Carrera creada correctamente",
                raceDeleted: "Carrera eliminada",
                departuresCleared: "Lista de salidas limpiada",
                intervalAdded: "Tramo añadido",
                excelExported: "Excel exportado correctamente",
                suggestionSent: "Sugerencia enviada",
                updateChecked: "Actualización verificada",
                intervalSaved: "Configuración de tramos guardada",
                intervalLoaded: "Configuración de tramos cargada",
                sessionRestarted: "Sesión reiniciada completamente",
                departureHeaderDorsal: "Salida",
                departureHeaderTime: "Tiempo",
                departureHeaderNotes: "Nota",
                departureHeaderDate: "Hora",
                departurePlaceholder: "Dorsal o aclaración",
                noDeparturesText: "No hay salidas registradas",
                saveButtonText: "Guardar",
                cancelButtonText: "Cancelar",
                editIntervalModalTitle: "Editar Tiempo por Tramo",
                salidaText: "SALIDA",
                
                // NUEVAS TRADUCCIONES AÑADIDAS:
                beepHigh: "Beep agudo",
                beepHighDesc: "Al llegar a 10 segundos",
                beepEverySecond: "Beep cada segundo",
                beepEverySecondDesc: "Últimos 5 segundos",
                beepLow: "Beep grave",
                beepLowDesc: "Al llegar a cero",
                configureAtLeastOneInterval: "Debes configurar al menos un tramo para el modo 'Varios tramos'",
                noIntervalsConfigured: "Error: No hay intervalos configurados",
                noDataToExport: "No hay datos para exportar",
                listAlreadyEmpty: "La lista ya está vacía",
                cannotModifyLastSeconds: "No se puede modificar durante los últimos 12 segundos",
                countdownNotActive: "La cuenta atrás no está activa",
                enterValidTime: "Ingresa un tiempo válido (mayor que 0)",
                enterRaceName: "Ingresa un nombre para la carrera",
                fromMustBeLessThanTo: "El corredor 'desde' debe ser menor o igual que 'hasta'",
                enterValidTimeValue: "Ingresa un tiempo válido",
                intervalOverlaps: "Este tramo se solapa con el tramo existente",
                invalidValues: "Valores no válidos",
                adjustmentsSaved: "Ajustes guardados. Tiempo: {seconds}s desde corredor {corredor}",
                waitCountdownEnd: "Espera a que termine la cuenta atrás (menos de 12 segundos)",
                timeUpdated: "Tiempo actualizado a {seconds}s para corredores desde {corredor} en adelante",
                noIntervalSelected: "No hay tramo seleccionado para editar",
                intervalUpdated: "Tramo actualizado correctamente",
                intervalDeleted: "Tramo eliminado correctamente",
                confirmDeleteInterval: "¿Estás seguro de que quieres eliminar el tramo {from}-{to}?",
                redBackground: "Fondo ROJO:",
                yellowBackground: "Fondo AMARILLO:",
                greenBackground: "Fondo VERDE:",
                redNumbers: "Números ROJOS pulsantes:",
                countdownNormalDesc: "Cuenta atrás normal",
                countdownWarningDesc: "Últimos 10 segundos",
                countdownCriticalDesc: "Últimos 5 segundos",
                countdownSalidaDesc: "Momento de salida (2 segundos)",
                configuredSections: "Tramos configurados",        
                audioConfigTitle: "Configuración de Audio",
                audioModeLabel: "Tipo de sonido para cuenta atrás",
                beepOptionTitle: "Sonidos Beep",
                beepOptionDesc: "Beeps electrónicos para cada segundo",
                voiceOptionTitle: "Voz grabada",
                voiceOptionDesc: "Voz humana contando en tu idioma",
                muteOptionTitle: "Sin sonido",
                muteOptionDesc: "Solo efectos visuales",
                testAudioText: "Probar sonido actual"
            },
            ca: {
                appTitle: "Crono Compte Enrere",
                languagesLabel: "Idioma / Language",
                cardRaceTitle: "Gestió de Cursa",
                newRaceText: "Nova",
                deleteRaceText: "Eliminar",
                cardTimeTitle: "Configuració de Temps",
                cadenceTitle: "Cadència de sortida",
                sameIntervalText: "Sempre igual",
                variableIntervalText: "Varis trams",
                intervalTimeLabel: "Temps entre sortides",
                minutesText: "minuts",
                secondsText: "segons",
                addIntervalLabel: "Afegir nou tram",
                toText: "fins a",
                addIntervalText: "Afegir",
                currentPositionText: "Posició actual:",
                cardStartTitle: "Punt d'Inici",
                startFromLabel: "Iniciar des de",
                startFromZeroText: "Començar des del corredor 1",
                startFromXText: "O des de la posició:",
                cardDeparturesTitle: "Sortides Registrades",
                clearDeparturesText: "Netejar llista",
                exportExcelText: "Exportar Excel",
                startCountdownText: "INICIAR COMPTE ENRERE",
                exitCompleteText: "REINICIAR",
                totalTimeLabel: "Temps total",
                countdownlabel: "Sortida en",
                nextCorredorLabel: "Pròxim surt a",
                departedLabel: "Sortits",
                helpText: "Ajuda",
                suggestionsText: "Suggeriments",
                installText: "Instal·lar App",
                updateText: "Cercar actualitzacions",
                helpModalTitle: "Ajuda de Crono Compte Enrere",
                helpModalText1: "Crono Compte Enrere és una aplicació per controlar les sortides en curses amb compte enrere visual i sonor.",
                helpModalSubtitle1: "Com usar:",
                helpModalList: [
                    "Selecciona una cursa o crea'n una de nova",
                    "Configura la cadència de sortida (sempre igual o per trams)",
                    "Inicia des del corredor 1 o des d'una posició específica",
                    "Prem 'INICIAR COMPTE ENRERE' per començar",
                    "La pantalla canviarà mostrant el compte enrere gran",
                    "Quan arribi a zero es mostrarà 'SORTIDA' i començarà el compte per al següent"
                ],
                helpModalSubtitle2: "Indicadors visuals:",
                helpModalSubtitle3: "Sons:",
                helpModalText2: "Els 2 segons de 'SORTIDA' es resten automàticament del temps del compte enrere següent.",
                deleteRaceModalTitle: "Confirmar eliminació",
                deleteRaceModalText: "Estàs segur que vols eliminar aquesta cursa? Totes les dades es perdran.",
                clearDeparturesModalTitle: "Confirmar neteja",
                clearDeparturesModalText: "Estàs segur que vols netejar la llista de sortides? Aquesta acció no es pot desfer.",
                suggestionsModalTitle: "Enviar suggeriments",
                suggestionEmailLabel: "Email (opcional):",
                suggestionTextLabel: "Suggeriments:",
                newRaceModalTitle: "Nova cursa",
                newRaceNameLabel: "Nom de la cursa:",
                newRaceDescLabel: "Descripció (opcional):",
                restartModalTitle: "Confirmar reinici complet",
                restartModalText: "Estàs segur que vols reiniciar completament? Aquesta acció:",
                deleteConfirm: "Eliminar",
                cancel: "Cancel·lar",
                understood: "Entès",
                createRace: "Crear cursa",
                sendSuggestion: "Enviar",
                clear: "Netejar",
                restartConfirm: "Sí, reiniciar completament",
                selectRaceFirst: "Si us plau, selecciona una cursa primer",
                countdownStarted: "Compte enrere iniciat",
                countdownStopped: "Compte enrere aturat",
                raceCreated: "Cursa creada correctament",
                raceDeleted: "Cursa eliminada",
                departuresCleared: "Llista de sortides netejada",
                intervalAdded: "Tram afegit",
                excelExported: "Excel exportat correctament",
                suggestionSent: "Suggeriment enviat",
                updateChecked: "Actualització verificada",
                intervalSaved: "Configuració de trams guardada",
                intervalLoaded: "Configuració de trams carregada",
                sessionRestarted: "Sessió reiniciada completament",
                departureHeaderDorsal: "Sortida",
                departureHeaderTime: "Temps",
                departureHeaderNotes: "Nota",
                departureHeaderDate: "Hora",
                departurePlaceholder: "Dorsal o aclaració",
                noDeparturesText: "No hi ha sortides registrades",
                saveButtonText: "Desar",
                cancelButtonText: "Cancel·lar",
                editIntervalModalTitle: "Editar Temps per Tram",
                salidaText: "SORTIDA",
                
                // NUEVAS TRADUCCIONES AÑADIDAS:
                beepHigh: "Beep agut",
                beepHighDesc: "En arribar a 10 segons",
                beepEverySecond: "Beep cada segon",
                beepEverySecondDesc: "Últims 5 segons",
                beepLow: "Beep greu",
                beepLowDesc: "En arribar a zero",
                configureAtLeastOneInterval: "Has de configurar almenys un tram per al mode 'Varis trams'",
                noIntervalsConfigured: "Error: No hi ha trams configurats",
                noDataToExport: "No hi ha dades per exportar",
                listAlreadyEmpty: "La llista ja està buida",
                cannotModifyLastSeconds: "No es pot modificar durant els últims 12 segons",
                countdownNotActive: "El compte enrere no està actiu",
                enterValidTime: "Introdueix un temps vàlid (major que 0)",
                enterRaceName: "Introdueix un nom per a la cursa",
                fromMustBeLessThanTo: "El corredor 'des de' ha de ser menor o igual que 'fins a'",
                enterValidTimeValue: "Introdueix un temps vàlid",
                intervalOverlaps: "Aquest tram se solapa amb el tram existent",
                invalidValues: "Valors no vàlids",
                adjustmentsSaved: "Ajustos desats. Temps: {seconds}s des del corredor {corredor}",
                waitCountdownEnd: "Espera que acabi el compte enrere (menys de 12 segons)",
                timeUpdated: "Temps actualitzat a {seconds}s per a corredors des del {corredor} en endavant",
                noIntervalSelected: "No hi ha tram seleccionat per editar",
                intervalUpdated: "Tram actualitzat correctament",
                intervalDeleted: "Tram eliminat correctament",
                confirmDeleteInterval: "Estàs segur que vols eliminar el tram {from}-{to}?",
                redBackground: "Fons VERMELL:",
                yellowBackground: "Fons GROC:",
                greenBackground: "Fons VERD:",
                redNumbers: "Números VERMELLS pulsants:",
                countdownNormalDesc: "Compte enrere normal",
                countdownWarningDesc: "Últims 10 segons",
                countdownCriticalDesc: "Últims 5 segons",
                countdownSalidaDesc: "Momento de sortida (2 segons)",
                configuredSections: "Trams configurats",
                audioConfigTitle: "Configuració d'Àudio",
                audioModeLabel: "Tipus de so per al compte enrere",
                beepOptionTitle: "Sons Beep",
                beepOptionDesc: "Beeps electrònics per a cada segon",
                voiceOptionTitle: "Veure enregistrada",
                voiceOptionDesc: "Veure humana comptant en la teva llengua",
                muteOptionTitle: "Sense so",
                muteOptionDesc: "Només efectes visuals",
                testAudioText: "Provar so actual"
            },
            en: {
                appTitle: "Countdown Timer",
                languagesLabel: "Language / Idioma",
                cardRaceTitle: "Race Management",
                newRaceText: "New",
                deleteRaceText: "Delete",
                cardTimeTitle: "Time Configuration",
                cadenceTitle: "Start cadence",
                sameIntervalText: "Always the same",
                variableIntervalText: "Multiple intervals",
                intervalTimeLabel: "Time between starts",
                minutesText: "minutes",
                secondsText: "seconds",
                addIntervalLabel: "Add new interval",
                toText: "to",
                addIntervalText: "Add",
                currentPositionText: "Current position:",
                cardStartTitle: "Starting Point",
                startFromLabel: "Start from",
                startFromZeroText: "Start from racer 1",
                startFromXText: "Or from position:",
                cardDeparturesTitle: "Registered Departures",
                clearDeparturesText: "Clear list",
                exportExcelText: "Export Excel",
                startCountdownText: "START COUNTDOWN",
                exitCompleteText: "RESTART",
                totalTimeLabel: "Total time",
                countdownlabel: "Starts in",
                nextCorredorLabel: "Next starts in",
                departedLabel: "Departed",
                helpText: "Help",
                suggestionsText: "Suggestions",
                installText: "Install App",
                updateText: "Check for updates",
                helpModalTitle: "Countdown Timer Help",
                helpModalText1: "Countdown Timer is an application to control race starts with visual and sound countdown.",
                helpModalSubtitle1: "How to use:",
                helpModalList: [
                    "Select a race or create a new one",
                    "Configure start cadence (same or multiple intervals)",
                    "Start from racer 1 or from specific position",
                    "Press 'START COUNTDOWN' to begin",
                    "Screen will change showing big countdown",
                    "When it reaches zero 'START' will show and countdown for next begins"
                ],
                helpModalSubtitle2: "Visual indicators:",
                helpModalSubtitle3: "Sounds:",
                helpModalText2: "The 2 seconds of 'START' are automatically subtracted from the next countdown time.",
                deleteRaceModalTitle: "Confirm deletion",
                deleteRaceModalText: "Are you sure you want to delete this race? All data will be lost.",
                clearDeparturesModalTitle: "Confirm cleanup",
                clearDeparturesModalText: "Are you sure you want to clear the starts list? This action cannot be undone.",
                suggestionsModalTitle: "Send suggestions",
                suggestionEmailLabel: "Email (optional):",
                suggestionTextLabel: "Suggestions:",
                newRaceModalTitle: "New race",
                newRaceNameLabel: "Race name:",
                newRaceDescLabel: "Description (optional):",
                restartModalTitle: "Confirm complete restart",
                restartModalText: "Are you sure you want to restart completely? This action:",
                deleteConfirm: "Delete",
                cancel: "Cancel",
                understood: "Understood",
                createRace: "Create race",
                sendSuggestion: "Send",
                clear: "Clear",
                restartConfirm: "Yes, restart completely",
                selectRaceFirst: "Please select a race first",
                countdownStarted: "Countdown started",
                countdownStopped: "Countdown stopped",
                raceCreated: "Race created successfully",
                raceDeleted: "Race deleted",
                departuresCleared: "Starts list cleared",
                intervalAdded: "Interval added",
                excelExported: "Excel exported successfully",
                suggestionSent: "Suggestion sent",
                updateChecked: "Update checked",
                intervalSaved: "Interval configuration saved",
                intervalLoaded: "Interval configuration loaded",
                sessionRestarted: "Session restarted completely",
                departureHeaderDorsal: "Start",
                departureHeaderTime: "Time",
                departureHeaderNotes: "Note",
                departureHeaderDate: "Time",
                departurePlaceholder: "Bib number or note",
                noDeparturesText: "No departures recorded",
                saveButtonText: "Save",
                cancelButtonText: "Cancel",
                editIntervalModalTitle: "Edit Time per Interval",
                salidaText: "GO !!!!",
                
                // NUEVAS TRADUCCIONES AÑADIDAS:
                beepHigh: "High beep",
                beepHighDesc: "When reaching 10 seconds",
                beepEverySecond: "Beep every second",
                beepEverySecondDesc: "Last 5 seconds",
                beepLow: "Low beep",
                beepLowDesc: "When reaching zero",
                configureAtLeastOneInterval: "You must configure at least one interval for 'Multiple intervals' mode",
                noIntervalsConfigured: "Error: No intervals configured",
                noDataToExport: "No data to export",
                listAlreadyEmpty: "The list is already empty",
                cannotModifyLastSeconds: "Cannot modify during the last 12 seconds",
                countdownNotActive: "Countdown is not active",
                enterValidTime: "Enter a valid time (greater than 0)",
                enterRaceName: "Enter a race name",
                fromMustBeLessThanTo: "From' corredor must be less than or equal to 'To'",
                enterValidTimeValue: "Enter a valid time",
                intervalOverlaps: "This interval overlaps with existing interval",
                invalidValues: "Invalid values",
                adjustmentsSaved: "Adjustments saved. Time: {seconds}s from corredor {corredor}",
                waitCountdownEnd: "Wait for countdown to end (less than 12 seconds)",
                timeUpdated: "Time updated to {seconds}s for corredors from {corredor} onwards",
                noIntervalSelected: "No interval selected for editing",
                intervalUpdated: "Interval updated successfully",
                intervalDeleted: "Interval deleted successfully",
                confirmDeleteInterval: "Are you sure you want to delete interval {from}-{to}?",
                redBackground: "RED background:",
                yellowBackground: "YELLOW background:",
                greenBackground: "GREEN background:",
                redNumbers: "RED pulsing numbers:",
                countdownNormalDesc: "Normal countdown",
                countdownWarningDesc: "Last 10 seconds",
                countdownCriticalDesc: "Last 5 seconds",
                countdownSalidaDesc: "Start moment (2 seconds)",
                configuredSections: "Configured intervals",
                audioConfigTitle: "Audio Configuration",
                audioModeLabel: "Sound type for countdown",
                beepOptionTitle: "Beep Sounds",
                beepOptionDesc: "Electronic beeps for each second",
                voiceOptionTitle: "Recorded Voice",
                voiceOptionDesc: "Human voice counting in your language",
                muteOptionTitle: "No Sound",
                muteOptionDesc: "Visual effects only",
                testAudioText: "Test current sound"
            },
            fr: {
                appTitle: "Compte à Rebours",
                languagesLabel: "Langue / Language",
                cardRaceTitle: "Gestion de Course",
                newRaceText: "Nouvelle",
                deleteRaceText: "Supprimer",
                cardTimeTitle: "Configuration des Temps",
                cadenceTitle: "Cadence de départ",
                sameIntervalText: "Toujours égal",
                variableIntervalText: "Plusieurs intervalles",
                intervalTimeLabel: "Temps entre départs",
                minutesText: "minutes",
                secondsText: "secondes",
                addIntervalLabel: "Ajouter nouvel intervalle",
                toText: "à",
                addIntervalText: "Ajouter",
                currentPositionText: "Position actuelle:",
                cardStartTitle: "Point de Départ",
                startFromLabel: "Démarrer depuis",
                startFromZeroText: "Démarrer depuis le coureur 1",
                startFromXText: "Ou desde la posición:",
                cardDeparturesTitle: "Départs Enregistrés",
                clearDeparturesText: "Effacer liste",
                exportExcelText: "Exporter Excel",
                startCountdownText: "DÉMARRER COMPTE À REBOURS",
                exitCompleteText: "REDÉMARRER",
                totalTimeLabel: "Temps total",
                countdownlabel: "Départ dans",
                nextCorredorLabel: "Prochain départ dans",
                departedLabel: "Partis",
                helpText: "Aide",
                suggestionsText: "Suggestions",
                installText: "Installer App",
                updateText: "Vérifier mises à jour",
                helpModalTitle: "Aide Compte à Rebours",
                helpModalText1: "Compte à Rebours est une application pour contrôler les départs de course con cuenta atrás visuel et sonore.",
                helpModalSubtitle1: "Comment utiliser:",
                helpModalList: [
                    "Sélectionnez une course ou créez-en une nouvelle",
                    "Configurez la cadence de départ (toujours égal ou plusieurs intervalles)",
                    "Démarrez depuis le coureur 1 ou desde una position específica",
                    "Appuyez sur 'DÉMARRER COMPTE À REBOURS' pour commencer",
                    "L'écran changera montrant le compte à rebours grand",
                    "Quand il atteint zéro 'DÉPART' s'affichera et le compte pour le suivant commencera"
                ],
                helpModalSubtitle2: "Indicateurs visuels:",
                helpModalSubtitle3: "Sons:",
                helpModalText2: "Les 2 secondes de 'DÉPART' sont automatiquement soustraites du temps du compte à rebours suivant.",
                deleteRaceModalTitle: "Confirmer suppression",
                deleteRaceModalText: "Êtes-vous sûr de vouloir supprimer cette course? Toutes les données seront perdues.",
                clearDeparturesModalTitle: "Confirmer nettoyage",
                clearDeparturesModalText: "Êtes-vous sûr de vouloir nettoyer la liste des départs? Cette action ne peut pas être annulée.",
                suggestionsModalTitle: "Envoyer suggestions",
                suggestionEmailLabel: "Email (optionnel):",
                suggestionTextLabel: "Suggestions:",
                newRaceModalTitle: "Nouvelle course",
                newRaceNameLabel: "Nom de la course:",
                newRaceDescLabel: "Description (optionnel):",
                restartModalTitle: "Confirmer redémarrage complet",
                restartModalText: "Êtes-vous sûr de vouloir redémarrer complètement? Cette action:",
                deleteConfirm: "Supprimer",
                cancel: "Annuler",
                understood: "Compris",
                createRace: "Créer course",
                sendSuggestion: "Envoyer",
                clear: "Nettoyer",
                restartConfirm: "Oui, redémarrer completement",
                selectRaceFirst: "Veuillez sélectionner une course d'abord",
                countdownStarted: "Compte à rebours démarré",
                countdownStopped: "Compte à rebours arrêté",
                raceCreated: "Course créée avec succès",
                raceDeleted: "Course supprimée",
                departuresCleared: "Liste des départs nettoyée",
                intervalAdded: "Intervalle ajouté",
                excelExported: "Excel exporté avec succès",
                suggestionSent: "Suggestion envoyée",
                updateChecked: "Mise à jour vérifiée",
                intervalSaved: "Configuration des intervalles sauvegardée",
                intervalLoaded: "Configuration des intervalles chargée",
                sessionRestarted: "Session redémarrée complètement",
                departureHeaderDorsal: "Départ",
                departureHeaderTime: "Temps",
                departureHeaderNotes: "Note",
                departureHeaderDate: "Heure",
                departurePlaceholder: "Dossard ou remarque",
                noDeparturesText: "Aucun départ enregistré",
                saveButtonText: "Enregistrer",
                cancelButtonText: "Annuler",
                editIntervalModalTitle: "Modifier Temps par Intervalle",
                salidaText: "DÉPART",
                
                // NUEVAS TRADUCCIONES AÑADIDAS:
                beepHigh: "Beep aigu",
                beepHighDesc: "En atteignant 10 secondes",
                beepEverySecond: "Beep chaque seconde",
                beepEverySecondDesc: "Dernières 5 secondes",
                beepLow: "Beep grave",
                beepLowDesc: "En atteignant zéro",
                configureAtLeastOneInterval: "Vous devez configurer au moins un intervalle pour le mode 'Plusieurs intervalles'",
                noIntervalsConfigured: "Erreur: Aucun intervalle configuré",
                noDataToExport: "Aucune donnée à exporter",
                listAlreadyEmpty: "La liste est déjà vide",
                cannotModifyLastSeconds: "Impossible de modifier pendant les 12 dernières secondes",
                countdownNotActive: "Le compte à rebours n'est pas actif",
                enterValidTime: "Entrez un temps valide (supérieur à 0)",
                enterRaceName: "Entrez un nom de course",
                fromMustBeLessThanTo: "Le corredor 'De' doit être inférieur ou égal à 'À'",
                enterValidTimeValue: "Entrez un temps valide",
                intervalOverlaps: "Cet intervalle chevauche l'intervalle existant",
                invalidValues: "Valeurs non valides",
                adjustmentsSaved: "Ajustements enregistrés. Temps: {seconds}s depuis le corredor {corredor}",
                waitCountdownEnd: "Attendez la fin du compte à rebours (moins de 12 secondes)",
                timeUpdated: "Temps mis à jour à {seconds}s pour les corredors à partir de {corredor}",
                noIntervalSelected: "Aucun intervalle sélectionné pour modification",
                intervalUpdated: "Intervalle mis à jour avec succès",
                intervalDeleted: "Intervalle supprimé avec succès",
                confirmDeleteInterval: "Êtes-vous sûr de vouloir supprimer l'intervalle {from}-{to}?",
                redBackground: "Fond ROUGE:",
                yellowBackground: "Fond JAUNE:",
                greenBackground: "Fond VERT:",
                redNumbers: "Chiffres ROUGES pulsants:",
                countdownNormalDesc: "Compte à rebours normal",
                countdownWarningDesc: "Dernières 10 secondes",
                countdownCriticalDesc: "Dernières 5 secondes",
                countdownSalidaDesc: "Moment de départ (2 secondes)",
                configuredSections: "Intervalles configurés",
                audioConfigTitle: "Configuration Audio",
                audioModeLabel: "Type de son pour le compte à rebours",
                beepOptionTitle: "Sons Beep",
                beepOptionDesc: "Bips électroniques pour chaque seconde",
                voiceOptionTitle: "Voix enregistrée",
                voiceOptionDesc: "Voix humaine comptant dans votre langue",
                muteOptionTitle: "Sans son",
                muteOptionDesc: "Effets visuels seulement",
                testAudioText: "Tester le son actuel"
            }
        };

        // ============================================
        // FUNCIONES DE SONIDO
        // ============================================

        function generateBeep(frequency, duration, type = 'sine') {
            try {
                if (!appState.audioContext) {
                    appState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                if (appState.audioContext.state === 'suspended') {
                    appState.audioContext.resume();
                }
                
                const oscillator = appState.audioContext.createOscillator();
                const gainNode = appState.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(appState.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, appState.audioContext.currentTime);
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.3, appState.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, appState.audioContext.currentTime + duration);
                
                oscillator.start(appState.audioContext.currentTime);
                oscillator.stop(appState.audioContext.currentTime + duration);
                
            } catch (error) {
                console.log("Error generando beep:", error);
            }
        }

        function playSound(type) {
            if (!appState.soundEnabled) return;
            
            try {
                switch(type) {
                    case 'warning':
                        generateBeep(300, 1.5, 'square');
                        break;
                    case 'critical':
                        generateBeep(500, 0.3, 'sine');
                        break;
                    case 'salida':
                        generateBeep(800, 1.5, 'sine');
                        break;
                    case 'beep':
                        generateBeep(500, 0.3, 'sine');
                        break;
                }
            } catch (error) {
                console.log("Error reproduciendo sonido:", error);
            }
        }

        function initAudioOnInteraction() {
            if (!appState.audioContext) {
                appState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            if (appState.audioContext.state === 'suspended') {
                appState.audioContext.resume().then(() => {
                    generateBeep(440, 0.1);
                });
            }
            
            document.removeEventListener('click', initAudioOnInteraction);
            document.removeEventListener('keydown', initAudioOnInteraction);
        }

        // ============================================
        // FUNCIONES DE AUDIO MEJORADAS
        // ============================================

        // Precarga de audios de voz
        // ============================================
        // FUNCIÓN MEJORADA PARA PRECARGAR AUDIOS
        // ============================================
        function preloadVoiceAudios() {
            console.log("Precargando audios de voz .ogg...");
            
            const languages = ['es', 'en', 'ca', 'fr'];
            const numbers = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; // ¡0 ahora es "salida"!
            
            // Contador para audios cargados
            let loadedCount = 0;
            const totalToLoad = languages.length * numbers.length;
            
            languages.forEach(lang => {
                appState.voiceAudioCache[lang] = {};
                
                // Precargar TODOS los números incluyendo 0
                numbers.forEach(num => {
                    const audio = new Audio();
                    audio.preload = 'auto';
                    
                    // Formato consistente: idioma_número.ogg
                    audio.src = `audio/${lang}_${num}.ogg`;
                    
                    audio.addEventListener('canplaythrough', () => {
                        appState.voiceAudioCache[lang][num] = audio;
                        loadedCount++;
                        console.log(`✅ Audio cargado: ${lang}_${num}.ogg (${loadedCount}/${totalToLoad})`);
                        
                        // El 0 es especial - es la "salida"
                        if (num === 0) {
                            console.log(`   (Este es el audio de SALIDA para ${lang})`);
                        }
                    });
                    
                    audio.addEventListener('error', (e) => {
                        console.error(`❌ ERROR cargando ${audio.src}:`, e.type);
                        console.error("  Verifica que exista: audio/" + lang + "_" + num + ".ogg");
                        
                        // Si es el 0 y falla, dar un mensaje específico
                        if (num === 0) {
                            console.error("  IMPORTANTE: El archivo 0.ogg es para 'SALIDA'/'GO'/'DÉPART'");
                        }
                        
                        loadedCount++;
                    });
                    
                    audio.load();
                });
            });
            
            // Verificar carga después de un tiempo
            setTimeout(() => {
                console.log(`\n=== RESUMEN DE CARGA DE AUDIOS ===`);
                console.log(`Cargados: ${loadedCount}/${totalToLoad}`);
                
                languages.forEach(lang => {
                    console.log(`\nIdioma: ${lang}`);
                    const loadedNumbers = Object.keys(appState.voiceAudioCache[lang] || {}).length;
                    console.log(`  Números cargados: ${loadedNumbers}/11`);
                    
                    // Verificar si el 0 (salida) está cargado
                    if (appState.voiceAudioCache[lang][0]) {
                        console.log(`  ✅ Audio de SALIDA (0.ogg): CARGADO`);
                    } else {
                        console.log(`  ❌ Audio de SALIDA (0.ogg): FALTA`);
                    }
                });
            }, 3000);
        }

        function playVoiceAudio(number) {
            if (appState.audioType !== 'voice') return;
            
            console.log(`🔊 Reproduciendo: ${appState.currentLanguage}_${number}.ogg`);
            
            try {
                const lang = appState.currentLanguage;
                
                // Primero intentar usar el audio precargado
                if (appState.voiceAudioCache[lang] && appState.voiceAudioCache[lang][number]) {
                    const audio = appState.voiceAudioCache[lang][number];
                    audio.currentTime = 0; // Reiniciar al inicio
                    
                    const playPromise = audio.play();
                    
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.warn(`Error reproduciendo audio precargado ${lang}_${number}:`, error);
                            // Fallback: cargar directamente
                            loadAndPlayAudioDirectly(lang, number);
                        });
                    }
                } else {
                    // Si no está precargado, cargar directamente
                    loadAndPlayAudioDirectly(lang, number);
                }
                
            } catch (error) {
                console.error("❌ Error crítico en playVoiceAudio:", error);
                // Fallback a beep
                generateBeep(500, 0.3, 'sine');
            }
        }

        function loadAndPlayAudioDirectly(lang, number) {
            console.log(`📥 Cargando directamente: ${lang}_${number}.ogg`);
            
            const audio = new Audio();
            audio.src = `audio/${lang}_${number}.ogg`;
            
            // Intentar reproducir inmediatamente
            audio.play().then(() => {
                console.log(`✅ Audio reproducido directamente: ${lang}_${number}.ogg`);
            }).catch(error => {
                console.error(`❌ Error reproduciendo ${lang}_${number}.ogg:`, error);
                
                // Si hay error, mostrar información de depuración
                if (error.name === 'NotAllowedError') {
                    console.error("  El usuario no ha interactuado con la página");
                    console.error("  Haz clic en la página primero");
                } else if (error.name === 'NotFoundError') {
                    console.error("  El archivo no se encuentra");
                    console.error("  Verifica la ruta: " + audio.src);
                }
                
                // Fallback a beep
                generateBeep(500, 0.3, 'sine');
            });
        }

        function playSalidaVoice() {
            if (appState.audioType !== 'voice') return;
            
            console.log(`🔊 Reproduciendo SALIDA (${appState.currentLanguage}_0.ogg)`);
            
            // ¡Simplemente usar playVoiceAudio con número 0!
            playVoiceAudio(0);
        }

        function loadAndPlaySalidaDirectly(lang) {
            const audio = new Audio();
            audio.src = `audio/${lang}_salida.ogg`;
            
            audio.play().catch(error => {
                console.error(`❌ Error reproduciendo salida ${lang}:`, error);
                generateBeep(800, 1.5, 'sine');
            });
        }

        function verifyAudioFiles() {
            console.log("=== VERIFICACIÓN DE ARCHIVOS .ogg ===");
            console.log("CONVENCIÓN: 0.ogg = audio de SALIDA\n");
            
            const languages = ['es', 'en', 'ca', 'fr'];
            const requiredNumbers = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0];
            
            languages.forEach(lang => {
                console.log(`\n📁 Idioma: ${lang.toUpperCase()}`);
                
                // Verificar archivos de números
                requiredNumbers.forEach(num => {
                    const audio = new Audio();
                    const url = `audio/${lang}_${num}.ogg`;
                    audio.src = url;
                    
                    audio.addEventListener('canplaythrough', () => {
                        if (num === 0) {
                            console.log(`  ✅ ${lang}_${num}.ogg - SALIDA ✓`);
                        } else {
                            console.log(`  ✅ ${lang}_${num}.ogg`);
                        }
                    });
                    
                    audio.addEventListener('error', (e) => {
                        if (num === 0) {
                            console.log(`  ❌ ${lang}_${num}.ogg - SALIDA (FALTA!)`);
                        } else {
                            console.log(`  ❌ ${lang}_${num}.ogg`);
                        }
                        console.log(`      Ruta probada: ${url}`);
                    });
                    
                    audio.load();
                });
            });
        }
       
       
        // Función de fallback para cargar audio directamente
        function fallbackVoiceAudio(number, lang) {
            console.log(`Usando fallback para: ${lang}_${number}`);
            
            const audio = new Audio();
            const formats = ['.mp3', '.ogg', '.wav'];
            
            // Intentar diferentes formatos
            for (const format of formats) {
                audio.src = `audio/${lang}_${number}${format}`;
                
                audio.addEventListener('error', () => {
                    console.log(`Formato ${format} no funciona para ${lang}_${number}`);
                });
                
                audio.addEventListener('canplaythrough', () => {
                    console.log(`Formato ${format} funciona para ${lang}_${number}`);
                    audio.play().catch(e => {
                        console.warn("Error reproduciendo fallback:", e);
                        generateBeep(500, 0.3, 'sine');
                    });
                    return; // Salir del bucle si funciona
                });
                
                audio.load();
            }
        }

        function fallbackSalidaVoice(lang) {
            const audio = new Audio();
            const formats = ['.mp3', '.ogg', '.wav'];
            
            for (const format of formats) {
                audio.src = `audio/${lang}_salida${format}`;
                
                audio.addEventListener('canplaythrough', () => {
                    audio.play().catch(e => {
                        console.warn("Error reproduciendo salida fallback:", e);
                        generateBeep(800, 1.5, 'sine');
                    });
                    return;
                });
                
                audio.addEventListener('error', () => {
                    console.log(`Formato ${format} no funciona para salida ${lang}`);
                });
                
                audio.load();
            }
        }

        function playSound(type) {
            if (appState.audioType === 'none') return;
            
            try {
                switch(type) {
                    case 'warning': // 10 segundos
                        if (appState.audioType === 'beep') {
                            generateBeep(300, 1.5, 'square');
                        } else if (appState.audioType === 'voice') {
                            playVoiceAudio(10); // "diez", "ten", etc.
                        }
                        break;
                        
                    case 'critical': // 5 segundos
                        if (appState.audioType === 'beep') {
                            generateBeep(500, 0.3, 'sine');
                        } else if (appState.audioType === 'voice') {
                            playVoiceAudio(5); // "cinco", "five", etc.
                        }
                        break;
                        
                    case 'salida': // 0 segundos - ¡SALIDA!
                        if (appState.audioType === 'beep') {
                            generateBeep(800, 1.5, 'sine');
                        } else if (appState.audioType === 'voice') {
                            playVoiceAudio(0); // ¡Usar el 0 para salida!
                        }
                        break;
                        
                    case 'beep': // Beeps normales
                        if (appState.audioType === 'beep') {
                            generateBeep(500, 0.3, 'sine');
                        }
                        break;
                        
                    case 'number': // Números del 4 al 1
                        if (appState.audioType === 'voice' && appState.countdownValue >= 0) {
                            // Solo decir números del 4 al 1
                            if (appState.countdownValue <= 4 && appState.countdownValue > 0) {
                                playVoiceAudio(appState.countdownValue);
                            }
                        }
                        break;
                }
            } catch (error) {
                console.log("Error en playSound:", error);
            }
        }

        function testCurrentAudio() {
            const t = translations[appState.currentLanguage];
            
            console.clear();
            console.log("=== PRUEBA COMPLETA DE AUDIO ===");
            console.log("Idioma:", appState.currentLanguage);
            console.log("Tipo de audio:", appState.audioType);
            console.log("Convención: 0.ogg = SALIDA/GO/DÉPART/SORTIDA\n");
            
            if (appState.audioType === 'none') {
                showMessage("Modo sin sonido activado", 'info');
                return;
            }
            
            if (appState.audioType === 'beep') {
                console.log("Probando beeps...");
                generateBeep(300, 0.5, 'square');
                setTimeout(() => generateBeep(500, 0.3, 'sine'), 600);
                setTimeout(() => generateBeep(800, 1.5, 'sine'), 1200);
                
                showMessage("Probando sonido beep", 'info');
                
            } else if (appState.audioType === 'voice') {
                console.log("Probando secuencia de carrera completa:");
                
                // Simular una secuencia de cuenta atrás real
                console.log("1. Advertencia (10 segundos)...");
                playVoiceAudio(10);
                
                setTimeout(() => {
                    console.log("2. Cinco segundos...");
                    playVoiceAudio(5);
                }, 1500);
                
                setTimeout(() => {
                    console.log("3. Cuatro...");
                    playVoiceAudio(4);
                }, 3000);
                
                setTimeout(() => {
                    console.log("4. Tres...");
                    playVoiceAudio(3);
                }, 4500);
                
                setTimeout(() => {
                    console.log("5. Dos...");
                    playVoiceAudio(2);
                }, 6000);
                
                setTimeout(() => {
                    console.log("6. Uno...");
                    playVoiceAudio(1);
                }, 7500);
                
                setTimeout(() => {
                    console.log("7. ¡SALIDA! (0)...");
                    playVoiceAudio(0); // ¡Este es el audio de salida!
                }, 9000);
                
                showMessage(`Probando voz en ${appState.currentLanguage}`, 'info');
            }
        }
        // Añadir esta función y llamarla en initApp
        function checkAvailableAudioFiles() {
            console.log("=== VERIFICANDO ARCHIVOS DE AUDIO ===");
            
            const languages = ['es', 'en', 'ca', 'fr'];
            const testNumbers = [10, 5, 1];
            
            languages.forEach(lang => {
                console.log(`\n📁 Idioma: ${lang}`);
                
                // Verificar números
                testNumbers.forEach(num => {
                    const formats = ['.mp3', '.ogg', '.wav'];
                    formats.forEach(format => {
                        const audio = new Audio();
                        const url = `audio/${lang}_${num}${format}`;
                        
                        audio.addEventListener('canplaythrough', () => {
                            console.log(`  ✅ ${lang}_${num}${format} - DISPONIBLE`);
                        });
                        
                        audio.addEventListener('error', (e) => {
                            console.log(`  ❌ ${lang}_${num}${format} - NO DISPONIBLE (${e.type})`);
                        });
                        
                        audio.src = url;
                        audio.load();
                    });
                });
                
                // Verificar "salida"
                const formats = ['.mp3', '.ogg', '.wav'];
                formats.forEach(format => {
                    const audio = new Audio();
                    const url = `audio/${lang}_salida${format}`;
                    
                    audio.addEventListener('canplaythrough', () => {
                        console.log(`  ✅ ${lang}_salida${format} - DISPONIBLE`);
                    });
                    
                    audio.addEventListener('error', (e) => {
                        console.log(`  ❌ ${lang}_salida${format} - NO DISPONIBLE (${e.type})`);
                    });
                    
                    audio.src = url;
                    audio.load();
                });
            });
        }
        // Función para seleccionar tipo de audio
        function selectAudioType(audioType) {
            appState.audioType = audioType;
            
            // Actualizar interfaz
            document.querySelectorAll('.audio-option').forEach(option => {
                option.classList.remove('active');
            });
            
            document.querySelector(`.audio-option[data-audio-type="${audioType}"]`).classList.add('active');
            
            // Guardar preferencia
            localStorage.setItem('countdown-audio-type', audioType);
            
            console.log("Tipo de audio seleccionado:", audioType);
        }

        // Cargar preferencias de audio guardadas
        function loadAudioPreferences() {
            const savedAudioType = localStorage.getItem('countdown-audio-type');
            if (savedAudioType && ['beep', 'voice', 'none'].includes(savedAudioType)) {
                appState.audioType = savedAudioType;
            }
        }
        function showExpectedFilenames() {
            console.log("=== NOMBRES DE ARCHIVOS ESPERADOS ===");
            console.log("(Para carpeta audio/)\n");
            
            const languages = {
                'es': 'Español',
                'en': 'English', 
                'ca': 'Català',
                'fr': 'Français'
            };
            
            Object.entries(languages).forEach(([code, name]) => {
                console.log(`\n${name} (${code}):`);
                console.log(`  ${code}_10.ogg  → "diez" / "ten" / "deu" / "dix"`);
                console.log(`  ${code}_9.ogg   → "nueve" / "nine" / "nou" / "neuf"`);
                console.log(`  ${code}_8.ogg   → "ocho" / "eight" / "vuit" / "huit"`);
                console.log(`  ${code}_7.ogg   → "siete" / "seven" / "set" / "sept"`);
                console.log(`  ${code}_6.ogg   → "seis" / "six" / "sis" / "six"`);
                console.log(`  ${code}_5.ogg   → "cinco" / "five" / "cinc" / "cinq"`);
                console.log(`  ${code}_4.ogg   → "cuatro" / "four" / "quatre" / "quatre"`);
                console.log(`  ${code}_3.ogg   → "tres" / "three" / "tres" / "trois"`);
                console.log(`  ${code}_2.ogg   → "dos" / "two" / "dos" / "deux"`);
                console.log(`  ${code}_1.ogg   → "uno" / "one" / "un" / "un"`);
                console.log(`  ${code}_0.ogg   → "¡SALIDA!" / "GO!" / "SORTIDA!" / "DÉPART!"`);
            });
            
            console.log("\n=== TOTAL DE ARCHIVOS NECESARIOS ===");
            console.log("4 idiomas × 11 números = 44 archivos .ogg");
        }
        
        // ============================================
        // VARIABLES PARA ORDENACIÓN
        // ============================================
        let sortState = {
            column: 'time',
            direction: 'desc' // 'asc' o 'desc'
        };

        // ============================================
        // FUNCIONES PRINCIPALES
        // ============================================
        function initApp() {
            console.log("Inicializando aplicación...");
            
            loadLanguagePreference();
            loadRacesFromStorage();
            loadAppState();
            loadIntervalConfig();
            loadAudioPreferences(); // Cargar preferencias de audio
            
            // Verificar archivos de audio
            setTimeout(() => {
                verifyAudioFiles();
            }, 500);
            
            // Precargar audios
            setTimeout(() => {
                preloadVoiceAudios();
            }, 1000);
    
            // Cargar datos de la carrera actual
            loadRaceData();
            
            updateLanguageUI();
            updateSalidaText();
            renderRacesSelect();
            setupSorting();
            
            setInterval(updateTotalTime, 1000);
            setInterval(updateCurrentTime, 1000);
            
            setupServiceWorker();
            setupPWA();
            setupCountdownResize();
            adjustCountdownSize();
            adjustInfoCornersSize();
            
            // Precargar audios de voz
            preloadVoiceAudios();
            
            // Configurar eventos - PRIMERO los de intervalos
            setupIntervalsEvents();
            setupEditIntervalModalEvents();
            setupEventListeners();
            setupAudioEventListeners(); // Configurar eventos de audio
            
            // Configurar listeners adicionales específicos para intervalos
            setTimeout(() => {
                setupSpecificIntervalListeners();
            }, 500);
            
            document.addEventListener('click', initAudioOnInteraction);
            document.addEventListener('keydown', initAudioOnInteraction);
            
            console.log("Aplicación inicializada.");
            console.log(`Idioma inicial: ${appState.currentLanguage}`);
            console.log(`Tipo de audio: ${appState.audioType}`);
            console.log(`Texto SALIDA: ${translations[appState.currentLanguage].salidaText}`);
        }

        function setupAudioEventListeners() {
            // Configurar selección de tipo de audio
            document.querySelectorAll('.audio-option').forEach(option => {
                option.addEventListener('click', function() {
                    const audioType = this.getAttribute('data-audio-type');
                    selectAudioType(audioType);
                });
            });
            
            // Botón de prueba de audio
            document.getElementById('test-audio-btn').addEventListener('click', testCurrentAudio);
        }

        function setupSpecificIntervalListeners() {
            console.log("Configurando listeners específicos para intervalos...");
            
            // Agregar listeners directos a los botones existentes
            document.querySelectorAll('.remove-interval-btn').forEach(button => {
                button.addEventListener('click', function(e) {
                    console.log("Evento click directo en botón eliminar");
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const index = parseInt(this.getAttribute('data-index'));
                    handleRemoveInterval(index);
                });
            });
            
            document.querySelectorAll('.edit-interval-btn').forEach(button => {
                button.addEventListener('click', function(e) {
                    console.log("Evento click directo en botón editar");
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const index = parseInt(this.getAttribute('data-index'));
                    if (!isNaN(index)) {
                        openEditIntervalModal(index);
                    }
                });
            });
        }

        function handleRemoveInterval(index) {
            const t = translations[appState.currentLanguage];
            
            if (!isNaN(index) && index >= 0 && index < appState.intervals.length) {
                const interval = appState.intervals[index];
                const confirmMessage = t.confirmDeleteInterval.replace('{from}', interval.from).replace('{to}', interval.to);
                
                if (confirm(confirmMessage)) {
                    appState.intervals.splice(index, 1);
                    
                    renderIntervalsList();
                    
                    intervalConfig.variableMode = {
                        intervals: [...appState.intervals],
                        saved: true
                    };
                    saveIntervalConfig();
                    
                    if (appState.currentRace) {
                        appState.currentRace.intervals = [...appState.intervals];
                        saveRaceData();
                    }
                    
                    if (appState.countdownActive) {
                        updateCurrentInterval();
                        saveAppState();
                    }
                    
                    showMessage(t.intervalDeleted, 'success');
                    console.log("Intervalo eliminado. Total restante:", appState.intervals.length);
                    
                    // Reconfigurar listeners después de renderizar
                    setTimeout(() => {
                        setupSpecificIntervalListeners();
                    }, 100);
                }
            }
        }
        function refreshIntervalButtons() {
            // Limpiar eventos antiguos
            document.querySelectorAll('.remove-interval-btn').forEach(btn => {
                const newBtn = btn.cloneNode(true);
                btn.parentNode.replaceChild(newBtn, btn);
            });
            
            document.querySelectorAll('.edit-interval-btn').forEach(btn => {
                const newBtn = btn.cloneNode(true);
                btn.parentNode.replaceChild(newBtn, btn);
            });
            
            // Agregar nuevos listeners
            setupSpecificIntervalListeners();
        }

        function loadLanguagePreference() {
            const savedLang = localStorage.getItem('countdown-language');
            if (savedLang && translations[savedLang]) {
                appState.currentLanguage = savedLang;
            }
        }

        function loadRacesFromStorage() {
            const savedRaces = localStorage.getItem('countdown-races');
            if (savedRaces) {
                appState.races = JSON.parse(savedRaces);
            }
            
            const savedCurrentRace = localStorage.getItem('countdown-current-race');
            if (savedCurrentRace) {
                appState.currentRace = JSON.parse(savedCurrentRace);
            }
        }

        function loadAppState() {
            const savedState = localStorage.getItem('countdown-app-state');
            if (savedState) {
                const state = JSON.parse(savedState);
                
                appState.departedCount = state.departedCount || 0;
                appState.nextCorredorTime = state.nextCorredorTime || 60;
                appState.intervals = state.intervals || [];
                appState.currentIntervalIndex = state.currentIntervalIndex || 0;
                appState.accumulatedTime = state.accumulatedTime || 0;
                appState.raceStartTime = state.raceStartTime || null;
                appState.isVariableMode = state.isVariableMode || false;
                
                // Asegurarse de que los tiempos de salida existentes tengan timeValue
                if (state.departureTimes && state.departureTimes.length > 0 && state.raceStartTime) {
                    appState.departureTimes = state.departureTimes.map(departure => {
                        if (departure.timeValue) return departure;
                        
                        const elapsedSeconds = Math.floor((departure.timestamp - state.raceStartTime) / 1000);
                        const hours = Math.floor(elapsedSeconds / 3600);
                        const minutes = Math.floor((elapsedSeconds % 3600) / 60);
                        const seconds = elapsedSeconds % 60;
                        
                        return {
                            ...departure,
                            timeValue: `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`,
                            elapsedSeconds: elapsedSeconds
                        };
                    });
                } else {
                    appState.departureTimes = state.departureTimes || [];
                }
                
                appState.countdownActive = false;
                appState.countdownValue = 0;
                appState.countdownPaused = false;
                
                document.getElementById('start-position').value = appState.departedCount + 1;
                
                console.log("Estado cargado, salidos:", appState.departedCount);
            }
        }

        function loadRaceData() {
            if (!appState.currentRace) {
                appState.departureTimes = [];
                appState.departedCount = 0;
                appState.intervals = [];
                appState.isVariableMode = false;
                
                document.getElementById('departed-count').textContent = appState.departedCount;
                document.getElementById('start-position').value = appState.departedCount + 1;
                renderDeparturesList();
                return;
            }
            
            appState.departureTimes = appState.currentRace.departures || [];
            appState.departedCount = appState.departureTimes.length > 0 ? 
                Math.max(...appState.departureTimes.map(d => d.corredor)) : 0;
            appState.intervals = appState.currentRace.intervals || [];
            
            document.getElementById('departed-count').textContent = appState.departedCount;
            document.getElementById('start-position').value = appState.departedCount + 1;
            
            const cadenceMode = appState.currentRace.cadenceMode || 'single';
            appState.isVariableMode = (cadenceMode === 'variable');
            
            if (appState.isVariableMode) {
                document.getElementById('single-interval-config').style.display = 'none';
                document.getElementById('variable-interval-config').style.display = 'block';
                document.getElementById('same-interval-btn').classList.remove('active');
                document.getElementById('variable-interval-btn').classList.add('active');
                
                if (appState.intervals.length > 0) {
                    intervalConfig.variableMode = {
                        intervals: [...appState.intervals],
                        saved: true
                    };
                    updateCurrentInterval();
                    renderIntervalsList();
                } else {
                    appState.intervals = [];
                    renderIntervalsList();
                }
            } else {
                document.getElementById('single-interval-config').style.display = 'block';
                document.getElementById('variable-interval-config').style.display = 'none';
                document.getElementById('same-interval-btn').classList.add('active');
                document.getElementById('variable-interval-btn').classList.remove('active');
                
                if (appState.intervals.length > 0 && appState.intervals[0]) {
                    const firstInterval = appState.intervals[0];
                    document.getElementById('interval-minutes').value = firstInterval.minutes;
                    document.getElementById('interval-seconds').value = firstInterval.seconds;
                    
                    intervalConfig.singleMode = {
                        minutes: firstInterval.minutes,
                        seconds: firstInterval.seconds,
                        saved: true
                    };
                    appState.nextCorredorTime = firstInterval.totalSeconds;
                } else {
                    const defaultMinutes = intervalConfig.singleMode.minutes || 1;
                    const defaultSeconds = intervalConfig.singleMode.seconds || 0;
                    const defaultTotalSeconds = defaultMinutes * 60 + defaultSeconds;
                    
                    document.getElementById('interval-minutes').value = defaultMinutes;
                    document.getElementById('interval-seconds').value = defaultSeconds;
                    
                    appState.intervals = [];
                    appState.nextCorredorTime = defaultTotalSeconds;
                    
                    console.log("Modo single sin intervalos guardados - usando valores por defecto");
                }
            }
            
            updateCurrentInterval();
            updateNextCorredorDisplay();
            renderDeparturesList();
            
            console.log("Datos cargados para carrera:", appState.currentRace.name);
            console.log("Modo:", cadenceMode);
            console.log("Salidas:", appState.departureTimes.length);
            console.log("Intervalos en appState:", appState.intervals.length);
        }

        function saveAppState() {
            if (appState.countdownActive) {
                localStorage.setItem('countdown-app-state', JSON.stringify({
                    countdownActive: appState.countdownActive,
                    countdownValue: appState.countdownValue,
                    departedCount: appState.departedCount,
                    nextCorredorTime: appState.nextCorredorTime,
                    intervals: appState.intervals,
                    currentIntervalIndex: appState.currentIntervalIndex,
                    departureTimes: appState.departureTimes,
                    raceStartTime: appState.raceStartTime,
                    accumulatedTime: appState.accumulatedTime,
                    countdownPaused: appState.countdownPaused,
                    isVariableMode: appState.isVariableMode
                }));
            } else {
                localStorage.removeItem('countdown-app-state');
            }
        }

        function saveRaceData() {
            if (!appState.currentRace) {
                console.log("No hay carrera actual para guardar datos");
                return;
            }
            
            const cadenceMode = appState.isVariableMode ? 'variable' : 'single';
            
            const raceIndex = appState.races.findIndex(r => r.id === appState.currentRace.id);
            if (raceIndex === -1) {
                console.log("Carrera no encontrada en el array");
                return;
            }
            
            let intervalsToSave = [];
            
            if (cadenceMode === 'variable') {
                intervalsToSave = [...appState.intervals];
            } else {
                intervalsToSave = appState.intervals.length > 0 ? [...appState.intervals] : [];
            }
            
            appState.races[raceIndex] = {
                ...appState.currentRace,
                cadenceMode: cadenceMode,
                departures: [...appState.departureTimes],
                intervals: intervalsToSave,
                lastModified: new Date().toISOString()
            };
            
            appState.currentRace = appState.races[raceIndex];
            
            saveRacesToStorage();
            
            console.log("Datos guardados para carrera:", appState.currentRace.name);
            console.log("Modo:", cadenceMode);
            console.log("Salidas con notas:", appState.departureTimes.length);
            console.log("Intervalos guardados:", intervalsToSave.length);
        }

        function saveRacesToStorage() {
            localStorage.setItem('countdown-races', JSON.stringify(appState.races));
            if (appState.currentRace) {
                localStorage.setItem('countdown-current-race', JSON.stringify(appState.currentRace));
            }
        }

        function updateLanguageUI() {
            const lang = appState.currentLanguage;
            const t = translations[lang];

            document.getElementById('audio-config-title').textContent = t.audioConfigTitle;
            document.getElementById('beep-option-title').textContent = t.beepOptionTitle;
            document.getElementById('test-audio-text').textContent = t.testAudioText;

            // Actualizar selección de audio
            document.querySelectorAll('.audio-option').forEach(option => {
                option.classList.remove('active');
            });
            document.querySelector(`.audio-option[data-audio-type="${appState.audioType}"]`).classList.add('active');

            document.getElementById('app-title-text').textContent = t.appTitle;
            document.getElementById('languages-label').textContent = t.languagesLabel;
            document.getElementById('card-race-title').textContent = t.cardRaceTitle;
            document.getElementById('new-race-text').textContent = t.newRaceText;
            document.getElementById('delete-race-text').textContent = t.deleteRaceText;
            document.getElementById('card-time-title').textContent = t.cardTimeTitle;
            document.getElementById('same-interval-text').textContent = t.sameIntervalText;
            document.getElementById('variable-interval-text').textContent = t.variableIntervalText;
            document.getElementById('interval-time-label').textContent = t.intervalTimeLabel;
            document.getElementById('minutes-text').textContent = t.minutesText;
            document.getElementById('seconds-text').textContent = t.secondsText;
            document.getElementById('add-interval-label').textContent = t.addIntervalLabel;
            document.getElementById('to-text').textContent = t.toText;
            document.getElementById('add-interval-text').textContent = t.addIntervalText;
            
            document.getElementById('start-from-x-text').textContent = t.currentPositionText;
            
            document.getElementById('card-departures-title').textContent = t.cardDeparturesTitle;
            document.getElementById('clear-departures-text').textContent = t.clearDeparturesText;
            document.getElementById('export-excel-text').textContent = t.exportExcelText;
            document.getElementById('start-countdown-text').textContent = t.startCountdownText;
            document.getElementById('exit-complete-text').textContent = t.exitCompleteText;
            document.getElementById('total-time-label').textContent = t.totalTimeLabel;
            document.getElementById('countdown-label').textContent = t.countdownlabel;
            
            document.getElementById('next-corredor-label').textContent = t.nextCorredorLabel;
            document.getElementById('departed-label').textContent = t.departedLabel;
            document.getElementById('help-text').textContent = t.helpText;
            document.getElementById('suggestions-text').textContent = t.suggestionsText;
            document.getElementById('install-text').textContent = t.installText;
            document.getElementById('update-text').textContent = t.updateText;

            // Actualizar el texto "SALIDA" en la pantalla de cuenta atrás
            const salidaDisplay = document.getElementById('salida-display');
            if (salidaDisplay) {
                salidaDisplay.textContent = t.salidaText;
            }
            
            document.querySelectorAll('.flag').forEach(flag => {
                flag.classList.remove('active');
            });
            document.getElementById('flag-' + lang).classList.add('active');
            
            updateModalTexts();
        }



        function updateSalidaText() {
            const lang = appState.currentLanguage;
            const t = translations[lang];
            const salidaDisplay = document.getElementById('salida-display');
            
            if (salidaDisplay) {
                salidaDisplay.textContent = t.salidaText;
            }
        }

        function updateModalTexts() {
            const t = translations[appState.currentLanguage];
            
            // Modal de ayuda
            document.getElementById('help-modal-title').textContent = t.helpModalTitle;
            document.getElementById('help-modal-text1').textContent = t.helpModalText1;
            document.getElementById('help-modal-subtitle1').textContent = t.helpModalSubtitle1;
            document.getElementById('help-modal-subtitle2').textContent = t.helpModalSubtitle2;
            document.getElementById('help-modal-subtitle3').textContent = t.helpModalSubtitle3;
            document.getElementById('help-modal-text2').textContent = t.helpModalText2;
            document.getElementById('help-modal-ok').textContent = t.understood;
            
            // Indicadores visuales en modal de ayuda
            document.getElementById('red-background-text').textContent = t.redBackground;
            document.getElementById('yellow-background-text').textContent = t.yellowBackground;
            document.getElementById('green-background-text').textContent = t.greenBackground;
            document.getElementById('red-numbers-text').textContent = t.redNumbers;
            document.getElementById('countdown-normal-desc').textContent = t.countdownNormalDesc;
            document.getElementById('configured-sections-label').textContent = t.configuredSections;
            document.getElementById('countdown-warning-desc').textContent = t.countdownWarningDesc;
            document.getElementById('countdown-critical-desc').textContent = t.countdownCriticalDesc;
            document.getElementById('countdown-salida-desc').textContent = t.countdownSalidaDesc;
            
            // Sonidos en modal de ayuda
            document.getElementById('beep-high-text').textContent = t.beepHigh;
            document.getElementById('beep-high-desc').textContent = t.beepHighDesc;
            document.getElementById('beep-every-second-text').textContent = t.beepEverySecond;
            document.getElementById('beep-every-second-desc').textContent = t.beepEverySecondDesc;
            document.getElementById('beep-low-text').textContent = t.beepLow;
            document.getElementById('beep-low-desc').textContent = t.beepLowDesc;
            
            const helpList = document.getElementById('help-modal-list');
            if (helpList) {
                helpList.innerHTML = '';
                t.helpModalList.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item;
                    li.style.marginBottom = '8px';
                    helpList.appendChild(li);
                });
            }
            
            // Tabla de salidas
            document.getElementById('edit-interval-modal-title').textContent = t.editIntervalModalTitle;
            document.getElementById('departure-header-dorsal').textContent = t.departureHeaderDorsal;
            document.getElementById('departure-header-time').textContent = t.departureHeaderTime;
            document.getElementById('departure-header-notes').textContent = t.departureHeaderNotes;
            document.getElementById('departure-header-date').textContent = t.departureHeaderDate;
            document.getElementById('no-departures-text').textContent = t.noDeparturesText;
            
            if (appState.departureTimes.length > 0) {
                renderDeparturesList();
            }
            
            // Modal eliminar carrera
            document.getElementById('delete-race-modal-title').textContent = t.deleteRaceModalTitle;
            document.getElementById('delete-race-modal-text').textContent = t.deleteRaceModalText;
            document.getElementById('delete-race-confirm-btn').textContent = t.deleteConfirm;
            document.getElementById('delete-race-cancel-btn').textContent = t.cancel;
            
            // Modal limpiar salidas
            document.getElementById('clear-departures-modal-title').textContent = t.clearDeparturesModalTitle;
            document.getElementById('clear-departures-modal-text').textContent = t.clearDeparturesModalText;
            document.getElementById('clear-departures-confirm-btn').textContent = t.clear;
            document.getElementById('clear-departures-cancel-btn').textContent = t.cancel;
            
            // Modal sugerencias
            document.getElementById('suggestions-modal-title').textContent = t.suggestionsModalTitle;
            document.getElementById('suggestion-email-label').textContent = t.suggestionEmailLabel;
            document.getElementById('suggestion-text-label').textContent = t.suggestionTextLabel;
            document.getElementById('send-suggestion-btn').textContent = t.sendSuggestion;
            document.getElementById('cancel-suggestion-btn').textContent = t.cancel;
            
            // Modal nueva carrera
            document.getElementById('new-race-modal-title').textContent = t.newRaceModalTitle;
            document.getElementById('new-race-name-label').textContent = t.newRaceNameLabel;
            document.getElementById('new-race-desc-label').textContent = t.newRaceDescLabel;
            document.getElementById('create-race-btn').textContent = t.createRace;
            document.getElementById('cancel-create-race-btn').textContent = t.cancel;
            
            // Modal reiniciar
            document.getElementById('restart-modal-title').textContent = t.restartModalTitle;
            document.getElementById('restart-modal-text').textContent = t.restartModalText;
            document.getElementById('restart-confirm-btn').textContent = t.restartConfirm;
            document.getElementById('restart-cancel-btn').textContent = t.cancel;

            const helpModalText = document.querySelector('#help-modal .modal-body');
            if (helpModalText) {
                // Asegúrate de que se incluye esta sección:
                const audioSection = document.createElement('div');
                audioSection.innerHTML = `
                    <h4 id="help-modal-subtitle3">Opciones de sonido:</h4>
                    <ul>
                        <li><strong>Sonidos Beep:</strong> Beeps electrónicos para cada segundo</li>
                        <li><strong>Voz grabada:</strong> Voz humana contando en tu idioma (es, en, ca, fr)</li>
                        <li><strong>Sin sonido:</strong> Solo efectos visuales</li>
                    </ul>
                `;
                // Insertar en la posición adecuada
                helpModalText.appendChild(audioSection);
            }
        }

        function renderRacesSelect() {
            const select = document.getElementById('race-select');
            select.innerHTML = '<option value="">-- Selecciona una carrera --</option>';
            
            appState.races.forEach((race, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = race.name;
                if (appState.currentRace && race.id === appState.currentRace.id) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
        }

        // ============================================
        // FUNCIONES PARA EL HISTORIAL DE SALIDAS
        // ============================================
        function registerDeparture() {
            // El número de salida es el valor ACTUAL de departedCount
            const salidaNumber = appState.departedCount + 1; // +1 porque departedCount es 0-indexed
            
            // Incrementar el contador de corredores salidos
            appState.departedCount++;
            
            let accumulatedSeconds = 0;
            
            if (appState.raceStartTime) {
                accumulatedSeconds = Math.floor((Date.now() - appState.raceStartTime) / 1000);
            }
            
            const hours = Math.floor(accumulatedSeconds / 3600);
            const minutes = Math.floor((accumulatedSeconds % 3600) / 60);
            const seconds = accumulatedSeconds % 60;
            const timeValue = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            const departure = {
                corredor: salidaNumber, // Usar el número de salida correcto
                timestamp: Date.now(),
                notes: '',
                editing: false,
                timeValue: timeValue,
                elapsedSeconds: accumulatedSeconds
            };
            
            appState.departureTimes.push(departure);
            
            // Actualizar displays
            document.getElementById('departed-count').textContent = appState.departedCount;
            document.getElementById('start-position').value = appState.departedCount + 1;
            
            renderDeparturesList();
            saveRaceData();
            saveAppState();
            
            console.log("Salida registrada - Número de salida:", salidaNumber, "Tiempo:", timeValue);
        }

        function renderDeparturesList() {
            const tableBody = document.getElementById('departures-table-body');
            const emptyState = document.getElementById('departures-empty');
            
            if (appState.departureTimes.length === 0) {
                tableBody.innerHTML = '';
                emptyState.style.display = 'block';
                return;
            }
            
            emptyState.style.display = 'none';
            
            const sortedDepartures = [...appState.departureTimes].sort((a, b) => {
                let valueA, valueB;
                
                switch(sortState.column) {
                    case 'dorsal':
                        valueA = a.corredor;
                        valueB = b.corredor;
                        break;
                    case 'timeValue':
                        valueA = a.elapsedSeconds || 0;
                        valueB = b.elapsedSeconds || 0;
                        break;
                    case 'notes':
                        valueA = (a.notes || '').toLowerCase();
                        valueB = (b.notes || '').toLowerCase();
                        break;
                    case 'date':
                        valueA = a.timestamp;
                        valueB = b.timestamp;
                        break;
                    default:
                        valueA = a.timestamp;
                        valueB = b.timestamp;
                }
                
                if (sortState.direction === 'asc') {
                    return valueA > valueB ? 1 : (valueA < valueB ? -1 : 0);
                } else {
                    return valueA < valueB ? 1 : (valueA > valueB ? -1 : 0);
                }
            });
            
            tableBody.innerHTML = '';
            
            sortedDepartures.forEach((departure, displayIndex) => {
                // Encontrar el índice REAL en el array original
                const originalIndex = appState.departureTimes.findIndex(d => 
                    d.corredor === departure.corredor && d.timestamp === departure.timestamp
                );
                
                const row = document.createElement('tr');
                
                const time = new Date(departure.timestamp);
                const timeStr = time.toLocaleTimeString('es-ES', { 
                    hour: '2-digit', 
                    minute: '2-digit',
                    second: '2-digit'
                });
                const dateStr = time.toLocaleDateString('es-ES');
                
                const t = translations[appState.currentLanguage];
                
                // Usar el índice ORIGINAL, no el de display
                const actualIndex = originalIndex !== -1 ? originalIndex : displayIndex;
                
                row.innerHTML = `
                    <td class="departure-dorsal-cell">${departure.corredor}</td>
                    <td class="departure-time-value-cell">
                        ${departure.timeValue || '--:--:--'}
                    </td>
                    <td class="departure-notes-cell">
                        ${departure.editing ? 
                            `<div class="notes-edit-container">
                                <textarea id="notes-input-${actualIndex}" class="departure-notes-input" rows="2" placeholder="${t.departurePlaceholder}" data-index="${actualIndex}">${departure.notes || ''}</textarea>
                                <div class="notes-buttons">
                                    <button class="save-notes-btn" data-index="${actualIndex}">${t.saveButtonText}</button>
                                    <button class="cancel-notes-btn" data-index="${actualIndex}">${t.cancelButtonText}</button>
                                </div>
                            </div>` :
                            `<div class="departure-notes-display ${!departure.notes ? 'empty' : ''}" data-index="${actualIndex}">
                                ${departure.notes || t.departurePlaceholder + '...'}
                            </div>`
                        }
                    </td>
                    <td class="departure-date-cell">
                        ${dateStr}<br>${timeStr}
                    </td>
                `;
                
                tableBody.appendChild(row);
                
                if (departure.editing) {
                    setupEditingMode(actualIndex);
                } else {
                    const displayElement = row.querySelector('.departure-notes-display');
                    if (displayElement) {
                        displayElement.addEventListener('click', function(e) {
                            e.stopPropagation();
                            const idx = parseInt(this.getAttribute('data-index'));
                            if (idx >= 0 && idx < appState.departureTimes.length) {
                                appState.departureTimes[idx].editing = true;
                                renderDeparturesList();
                            }
                        });
                    }
                }
            });
            
            updateSortIndicators();
        }


        function setupEditingMode(index) {
            // Usar el índice directamente del atributo data-index
            const inputElement = document.querySelector(`.departure-notes-input[data-index="${index}"]`);
            const saveButton = document.querySelector(`.save-notes-btn[data-index="${index}"]`);
            const cancelButton = document.querySelector(`.cancel-notes-btn[data-index="${index}"]`);
            
            if (inputElement) {
                inputElement.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
                
                inputElement.addEventListener('focus', function(e) {
                    e.stopPropagation();
                });
                
                inputElement.addEventListener('blur', function(e) {
                    e.stopPropagation();
                    // Solo guardar si el blur no fue causado por hacer clic en save/cancel
                    if (!e.relatedTarget || 
                        (!e.relatedTarget.classList.contains('save-notes-btn') && 
                        !e.relatedTarget.classList.contains('cancel-notes-btn'))) {
                        saveNotes(index);
                    }
                });
                
                inputElement.addEventListener('keydown', function(e) {
                    e.stopPropagation();
                    if ((e.key === 'Enter' && e.ctrlKey) || (e.key === 'Enter' && !e.shiftKey)) {
                        e.preventDefault();
                        saveNotes(index);
                    }
                });
                
                setTimeout(() => {
                    inputElement.focus();
                    inputElement.select();
                }, 100);
            }
            
            if (saveButton) {
                saveButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    saveNotes(index);
                });
                
                // También agregar event listener al contenedor de botones para prevenir propagación
                const buttonContainer = saveButton.closest('.notes-buttons');
                if (buttonContainer) {
                    buttonContainer.addEventListener('click', function(e) {
                        e.stopPropagation();
                    });
                }
            }
            
            if (cancelButton) {
                cancelButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    if (index >= 0 && index < appState.departureTimes.length) {
                        appState.departureTimes[index].editing = false;
                        renderDeparturesList();
                    }
                });
            }
        }


        function saveNotes(index) {
            // Verificar que el índice sea válido
            if (index < 0 || index >= appState.departureTimes.length) {
                console.error("Índice inválido en saveNotes:", index);
                return;
            }
            
            const inputElement = document.querySelector(`.departure-notes-input[data-index="${index}"]`);
            if (!inputElement) {
                console.error("Elemento input no encontrado para índice:", index);
                return;
            }
            
            const newNotes = inputElement.value.trim();
            
            appState.departureTimes[index].notes = newNotes;
            appState.departureTimes[index].editing = false;
            
            saveRaceData();
            
            if (appState.currentRace) {
                const raceIndex = appState.races.findIndex(r => r.id === appState.currentRace.id);
                if (raceIndex !== -1) {
                    appState.races[raceIndex].departures = [...appState.departureTimes];
                    saveRacesToStorage();
                    console.log("Nota guardada para corredor:", appState.departureTimes[index].corredor);
                }
            }
            
            setTimeout(() => {
                renderDeparturesList();
            }, 50);
        }

        function updateSortIndicators() {
            document.querySelectorAll('.departures-table th.sortable').forEach(th => {
                th.classList.remove('asc', 'desc');
                const column = th.getAttribute('data-sort');
                if (column === sortState.column) {
                    th.classList.add(sortState.direction);
                }
            });
        }

        function setupSorting() {
            document.querySelectorAll('.departures-table th.sortable').forEach(th => {
                th.addEventListener('click', function() {
                    const column = this.getAttribute('data-sort');
                    
                    if (sortState.column === column) {
                        sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortState.column = column;
                        sortState.direction = 'asc';
                    }
                    
                    renderDeparturesList();
                });
            });
        }

        function exportToExcel() {
            const t = translations[appState.currentLanguage];
            
            if (appState.departureTimes.length === 0) {
                showMessage(t.noDataToExport, 'warning');
                return;
            }
            
            const sortedForExport = [...appState.departureTimes].sort((a, b) => a.corredor - b.corredor);
            
            const data = [
                ['Carrera', appState.currentRace ? appState.currentRace.name : 'Sin nombre'],
                ['Descripción', appState.currentRace ? (appState.currentRace.description || 'Sin descripción') : ''],
                ['Fecha de exportación', new Date().toLocaleDateString()],
                ['Hora de exportación', new Date().toLocaleTimeString()],
                ['Total de salidas', appState.departureTimes.length],
                [''],
                ['Salida', 'Tiempo', 'Nota', 'Fecha', 'Hora', 'Timestamp']
            ];
            
            sortedForExport.forEach(departure => {
                const date = new Date(departure.timestamp);
                const timeValue = departure.timeValue || '--:--:--';
                
                data.push([
                    departure.corredor,
                    timeValue,
                    departure.notes || '',
                    date.toLocaleDateString(),
                    date.toLocaleTimeString(),
                    departure.timestamp
                ]);
            });
            
            const ws = XLSX.utils.aoa_to_sheet(data);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Salidas");
            
            const colWidths = [
                {wch: 8},
                {wch: 10},
                {wch: 50},
                {wch: 12},
                {wch: 10},
                {wch: 15}
            ];
            ws['!cols'] = colWidths;
            
            const headerRange = XLSX.utils.decode_range(ws['!ref']);
            for (let R = 0; R <= 4; R++) {
                for (let C = 0; C <= 1; C++) {
                    const cellAddress = XLSX.utils.encode_cell({r: R, c: C});
                    if (!ws[cellAddress]) continue;
                    ws[cellAddress].s = {
                        font: { bold: true },
                        fill: { fgColor: { rgb: "E0E0E0" } }
                    };
                }
            }
            
            const headerRow = 6;
            for (let C = 0; C <= 5; C++) {
                const cellAddress = XLSX.utils.encode_cell({r: headerRow, c: C});
                if (!ws[cellAddress]) continue;
                ws[cellAddress].s = {
                    font: { bold: true, color: { rgb: "FFFFFF" } },
                    fill: { fgColor: { rgb: "2C3E50" } },
                    alignment: { horizontal: "center" }
                };
            }
            
            ws['!autofilter'] = {
                ref: XLSX.utils.encode_range({
                    s: { r: headerRow, c: 0 },
                    e: { r: headerRow + sortedForExport.length, c: 5 }
                })
            };
            
            const raceName = appState.currentRace ? 
                appState.currentRace.name.replace(/[^a-z0-9]/gi, '_').substring(0, 50) : 'carrera';
            const date = new Date().toISOString().split('T')[0];
            const filename = `salidas_${raceName}_${date}.xlsx`;
            
            XLSX.writeFile(wb, filename);
            showMessage(t.excelExported, 'success');
        }

        function clearRaceDepartures() {
            const t = translations[appState.currentLanguage];
            
            if (!appState.currentRace) {
                showMessage(t.selectRaceFirst, 'error');
                return;
            }
            
            appState.departureTimes = [];
            appState.departedCount = 0;
            appState.raceStartTime = null;
            document.getElementById('start-position').value = 1;
            document.getElementById('departed-count').textContent = 0;
            document.getElementById('total-time-value').textContent = '00:00:00';
            
            saveRaceData();
            renderDeparturesList();
            
            showMessage(t.departuresCleared, 'success');
        }

        // ============================================
        // FUNCIONES DE CUENTA ATRÁS
        // ============================================

        function startCountdown() {
            console.log("Iniciando cuenta atrás...");
            
            const t = translations[appState.currentLanguage];
            
            if (!appState.currentRace) {
                showMessage(t.selectRaceFirst, 'error');
                return;
            }
            
            const isVariableMode = document.getElementById('variable-interval-config').style.display !== 'none';
            appState.isVariableMode = isVariableMode;
            
            if (isVariableMode && appState.intervals.length === 0) {
                showMessage(t.configureAtLeastOneInterval, 'error');
                return;
            }
            
            updateCadenceTime();
            
            if (appState.intervals.length === 0) {
                showMessage(t.noIntervalsConfigured, 'error');
                return;
            }
            
            document.querySelectorAll('.hide-on-countdown').forEach(el => {
                el.style.display = 'none';
            });
            
            const countdownScreen = document.getElementById('countdown-screen');
            countdownScreen.classList.add('active');
            countdownScreen.classList.remove('aggressive-numbers');
            
            appState.raceStartTime = Date.now();
            appState.accumulatedTime = 0;
            
            // Si empezamos desde una posición diferente, ajustar departedCount
            const startPosition = parseInt(document.getElementById('start-position').value) || 1;
            appState.departedCount = startPosition - 1;
            document.getElementById('departed-count').textContent = appState.departedCount;
            
            // Asegurar que el array departureTimes esté vacío si empezamos desde una nueva posición
            if (startPosition > 1) {
                appState.departureTimes = [];
                if (appState.currentRace) {
                    appState.currentRace.departures = [];
                    saveRaceData();
                }
            }
            
            updateCurrentInterval();
            
            appState.countdownActive = true;
            appState.countdownPaused = false;
            appState.countdownValue = appState.nextCorredorTime;
            appState.aggressiveMode = false;
            
            document.body.classList.remove('countdown-warning', 'countdown-critical', 'countdown-salida');
            document.body.classList.add('countdown-normal');
            
            countdownScreen.classList.remove('countdown-salida-active');
            
            document.getElementById('countdown-label').style.opacity = '1';
            document.getElementById('countdown-label').style.visibility = 'visible';
            
            updateCountdownDisplay();
            
            if (appState.countdownInterval) {
                clearInterval(appState.countdownInterval);
            }
            
            appState.countdownInterval = setInterval(updateCountdown, 1000);
            
            keepScreenAwake();
            
            if (!isVariableMode && appState.currentRace) {
                appState.currentRace.intervals = [...appState.intervals];
                saveRaceData();
            }
            
            saveAppState();
            
            showMessage(t.countdownStarted, 'success');
            console.log("Cuenta atrás iniciada correctamente.");
            console.log("Posición inicial:", startPosition, "Salidos:", appState.departedCount);
            console.log("Tiempo inicial:", appState.nextCorredorTime, "segundos");
        }

        function updateCadenceTime() {
            const isVariableMode = document.getElementById('variable-interval-config').style.display !== 'none';
            appState.isVariableMode = isVariableMode;
            
            if (!isVariableMode) {
                const minutes = parseInt(document.getElementById('interval-minutes').value) || 0;
                const seconds = parseInt(document.getElementById('interval-seconds').value) || 0;
                const totalSeconds = minutes * 60 + seconds;
                
                appState.nextCorredorTime = totalSeconds;
                
                appState.intervals = [{
                    from: 1,
                    to: 9999,
                    minutes: minutes,
                    seconds: seconds,
                    totalSeconds: totalSeconds
                }];
                
                console.log("Intervalo único creado para cuenta atrás:", minutes, "min", seconds, "seg");
            } else {
                updateCurrentInterval();
            }
            
            updateNextCorredorDisplay();
        }
        
        function updateCountdown() {
            if (!appState.countdownActive || appState.countdownPaused) return;
            
            const currentTime = Date.now();
            const elapsedFromRaceStart = Math.floor((currentTime - appState.raceStartTime) / 1000);
            
            const expectedElapsedTime = appState.accumulatedTime + 
                (appState.nextCorredorTime - appState.countdownValue);
            
            if (Math.abs(elapsedFromRaceStart - expectedElapsedTime) > 1) {
                appState.countdownValue = Math.max(0, appState.nextCorredorTime - 
                    (elapsedFromRaceStart - appState.accumulatedTime));
            } else {
                appState.countdownValue--;
            }
            
            if (appState.countdownValue <= 0) {
                handleCountdownZero();
                return;
            }
            
            updateCountdownDisplay();
            
            // Reproducir sonidos según el tipo seleccionado
            if (appState.countdownValue === 10) {
                document.body.classList.remove('countdown-normal');
                document.body.classList.add('countdown-warning');
                playSound('warning');
                
                const countdownScreen = document.getElementById('countdown-screen');
                countdownScreen.classList.remove('aggressive-numbers');
                appState.aggressiveMode = false;
            } else if (appState.countdownValue === 5) {
                document.body.classList.remove('countdown-warning');
                document.body.classList.add('countdown-critical');
                playSound('critical');
                
                const countdownScreen = document.getElementById('countdown-screen');
                countdownScreen.classList.add('aggressive-numbers');
                appState.aggressiveMode = true;
            } else if (appState.countdownValue < 5 && appState.countdownValue > 0) {
                // Reproducir beep para modo beep o número para modo voz
                if (appState.audioType === 'beep') {
                    playSound('beep');
                } else if (appState.audioType === 'voice') {
                    playSound('number');
                }
                
                if (!appState.aggressiveMode) {
                    const countdownScreen = document.getElementById('countdown-screen');
                    countdownScreen.classList.add('aggressive-numbers');
                    appState.aggressiveMode = true;
                }
            } else if (appState.countdownValue > 5 && appState.aggressiveMode) {
                const countdownScreen = document.getElementById('countdown-screen');
                countdownScreen.classList.remove('aggressive-numbers');
                appState.aggressiveMode = false;
            }
            
            if (appState.countdownValue % 10 === 0) {
                saveAppState();
            }
        }

        function updateCountdownDisplay() {
            const display = document.getElementById('countdown-display');
            
            if (appState.countdownValue >= 60) {
                const minutes = Math.floor(appState.countdownValue / 60);
                const seconds = appState.countdownValue % 60;
                display.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            } else {
                display.textContent = appState.countdownValue.toString();
            }
            
            updateNextCorredorDisplay();
            adjustCountdownSize();
        }

        function handleCountdownZero() {
            clearInterval(appState.countdownInterval);
            
            const countdownScreen = document.getElementById('countdown-screen');
            countdownScreen.classList.add('countdown-salida-active');
            
            countdownScreen.classList.remove('aggressive-numbers');
            appState.aggressiveMode = false;
            
            document.body.classList.remove('countdown-critical', 'countdown-warning', 'countdown-normal');
            document.body.classList.add('countdown-salida');
            
            const salidaDisplay = document.getElementById('salida-display');
            salidaDisplay.classList.add('show');
            
            playSound('salida'); // USANDO LA NUEVA FUNCIÓN
            
            // Registrar la salida
            registerDeparture();
            
            appState.accumulatedTime += appState.nextCorredorTime;
            
            appState.salidaTimeout = setTimeout(() => {
                salidaDisplay.classList.remove('show');
                countdownScreen.classList.remove('countdown-salida-active');
                prepareNextCountdown();
            }, 2000);
        }

        function canModifyDuringCountdown() {
            const t = translations[appState.currentLanguage];
            
            if (!appState.countdownActive) return true;
            
            // No permitir modificar si faltan menos de 12 segundos
            if (appState.countdownValue <= 15) {
                showMessage(t.waitCountdownEnd, 'warning');
                return false;
            }
            
            return true;
        }

        function prepareNextCountdown() {
            // ¡IMPORTANTE! NO incrementar departedCount aquí
            // departedCount ya fue incrementado en registerDeparture()
            
            // Solo actualizar qué intervalo corresponde al PRÓXIMO corredor
            // El próximo corredor es el actual + 1 (departedCount ya fue incrementado)
            updateCurrentInterval(); // Esto debe encontrar el intervalo para el NUEVO corredor
            
            // IMPORTANTE: Usar el tiempo del intervalo encontrado
            // NO usar appState.nextCorredorTime directamente porque puede haber cambiado
            
            // Restar los 2 segundos de "SALIDA" del tiempo del intervalo
            appState.countdownValue = Math.max(0, appState.nextCorredorTime - 2);
            
            document.body.classList.remove('countdown-salida');
            document.body.classList.add('countdown-normal');
            
            document.getElementById('countdown-label').style.opacity = '1';
            document.getElementById('countdown-label').style.visibility = 'visible';
            
            updateCountdownDisplay();
            
            appState.countdownInterval = setInterval(updateCountdown, 1000);
            
            saveAppState();
        }

        function updateCurrentInterval() {
            const currentCorredor = appState.departedCount + 1; // El próximo a salir
            
            const sortedIntervals = [...appState.intervals].sort((a, b) => a.from - b.from);
            
            for (let i = 0; i < sortedIntervals.length; i++) {
                const interval = sortedIntervals[i];
                
                if (currentCorredor >= interval.from && currentCorredor <= interval.to) {
                    appState.currentIntervalIndex = i;
                    appState.nextCorredorTime = interval.totalSeconds; // Usar el tiempo del intervalo
                    return;
                }
            }
            
            // Si no encuentra intervalo, usar el último o por defecto
            if (sortedIntervals.length > 0) {
                const lastInterval = sortedIntervals[sortedIntervals.length - 1];
                if (currentCorredor > lastInterval.to) {
                    appState.nextCorredorTime = lastInterval.totalSeconds;
                    appState.currentIntervalIndex = sortedIntervals.length - 1;
                }
            } else {
                appState.nextCorredorTime = 60; // Valor por defecto
            }
        }

        function updateNextCorredorDisplay() {
            const display = document.getElementById('next-corredor-time');
            if (!display) return;
            
            // Calcular qué tiempo le corresponde al SIGUIENTE corredor
            const nextCorredorNumber = appState.departedCount + 2; // El que viene después del actual
            
            let timeForNextCorredor = appState.nextCorredorTime; // Valor por defecto
            
            // Buscar en los intervalos
            if (appState.intervals && appState.intervals.length > 0) {
                const sortedIntervals = [...appState.intervals].sort((a, b) => a.from - b.from);
                
                for (const interval of sortedIntervals) {
                    if (nextCorredorNumber >= interval.from && nextCorredorNumber <= interval.to) {
                        timeForNextCorredor = interval.totalSeconds;
                        break;
                    }
                }
                
                // Si no se encuentra, buscar el último intervalo (para corredores más allá del último definido)
                if (timeForNextCorredor === appState.nextCorredorTime) {
                    const lastInterval = sortedIntervals[sortedIntervals.length - 1];
                    if (lastInterval && nextCorredorNumber > lastInterval.to) {
                        timeForNextCorredor = lastInterval.totalSeconds;
                    }
                }
            }
            
            // Formatear para mostrar
            if (timeForNextCorredor >= 60) {
                const minutes = Math.floor(timeForNextCorredor / 60);
                const seconds = timeForNextCorredor % 60;
                display.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            } else {
                display.textContent = timeForNextCorredor + "s";
            }
            
            console.log(`Display actualizado: Próximo corredor (${nextCorredorNumber}) sale en ${timeForNextCorredor}s`);
        }


        function updateTotalTime() {
            if (!appState.raceStartTime) return;
            
            const elapsed = Math.floor((Date.now() - appState.raceStartTime) / 1000);
            const hours = Math.floor(elapsed / 3600);
            const minutes = Math.floor((elapsed % 3600) / 60);
            const seconds = elapsed % 60;
            
            const display = document.getElementById('total-time-value');
            display.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function stopCountdown() {
            console.log("Deteniendo cuenta atrás...");
            
            if (appState.countdownInterval) {
                clearInterval(appState.countdownInterval);
                appState.countdownInterval = null;
            }
            
            if (appState.salidaTimeout) {
                clearTimeout(appState.salidaTimeout);
                appState.salidaTimeout = null;
            }
            
            appState.countdownActive = false;
            appState.countdownPaused = false;
            appState.raceStartTime = null;
            appState.accumulatedTime = 0;
            appState.aggressiveMode = false;
            appState.configModalOpen = false;
            
            document.body.classList.remove(
                'countdown-normal', 
                'countdown-warning', 
                'countdown-critical', 
                'countdown-salida'
            );
            
            document.getElementById('countdown-screen').classList.remove('aggressive-numbers');
            
            document.body.style.backgroundColor = '';
            document.body.style.background = '';
            document.body.style.animation = '';
            
            document.getElementById('total-time-value').textContent = '00:00:00';
            
            localStorage.removeItem('countdown-app-state');
            
            console.log("Cuenta atrás detenida");
        }

        function pauseCountdownVisual() {
            appState.countdownPaused = true;
            appState.configModalOpen = true;
        }

        function resumeCountdownVisual() {
            appState.countdownPaused = false;
            appState.configModalOpen = false;
        }


        function updateFutureIntervals(startFromCorredor, newSeconds) {
            console.log(`Actualizando intervalos futuros desde corredor ${startFromCorredor} a ${newSeconds}s`);
            
            // Encontrar todos los intervalos que empiezan en o después del corredor de inicio
            const intervalsToModify = [];
            
            // Primero, clonar los intervalos para no modificar el array mientras iteramos
            const originalIntervals = [...appState.intervals];
            appState.intervals = [];
            
            originalIntervals.forEach((interval, originalIndex) => {
                if (interval.from >= startFromCorredor) {
                    // Este intervalo está completamente en el futuro - modificar completamente
                    appState.intervals.push({
                        from: interval.from,
                        to: interval.to,
                        minutes: Math.floor(newSeconds / 60),
                        seconds: newSeconds % 60,
                        totalSeconds: newSeconds
                    });
                } else if (interval.to >= startFromCorredor) {
                    // Este intervalo se solapa parcialmente (comienza antes, termina después)
                    // Necesitamos dividirlo
                    
                    // Parte antes del cambio (mantener tiempo original)
                    const beforeInterval = {
                        from: interval.from,
                        to: startFromCorredor - 1,
                        minutes: interval.minutes,
                        seconds: interval.seconds,
                        totalSeconds: interval.totalSeconds
                    };
                    
                    // Parte después del cambio (nuevo tiempo)
                    const afterInterval = {
                        from: startFromCorredor,
                        to: interval.to,
                        minutes: Math.floor(newSeconds / 60),
                        seconds: newSeconds % 60,
                        totalSeconds: newSeconds
                    };
                    
                    // Añadir ambas partes
                    appState.intervals.push(beforeInterval);
                    appState.intervals.push(afterInterval);
                } else {
                    // Intervalo termina antes de startFromCorredor - mantener sin cambios
                    appState.intervals.push({...interval});
                }
            });
            
            // Ordenar intervalos por 'from'
            appState.intervals.sort((a, b) => a.from - b.from);
            
            // Fusionar intervalos adyacentes con el mismo tiempo
            const mergedIntervals = [];
            for (let i = 0; i < appState.intervals.length; i++) {
                if (mergedIntervals.length === 0) {
                    mergedIntervals.push({...appState.intervals[i]});
                } else {
                    const lastInterval = mergedIntervals[mergedIntervals.length - 1];
                    const currentInterval = appState.intervals[i];
                    
                    // Si los intervalos son adyacentes y tienen el mismo tiempo, fusionarlos
                    if (lastInterval.to + 1 === currentInterval.from && 
                        lastInterval.totalSeconds === currentInterval.totalSeconds) {
                        lastInterval.to = currentInterval.to;
                    } else {
                        mergedIntervals.push({...currentInterval});
                    }
                }
            }
            
            appState.intervals = mergedIntervals;
            
            // Guardar configuración
            intervalConfig.variableMode = {
                intervals: [...appState.intervals],
                saved: true
            };
            saveIntervalConfig();
            
            // Actualizar el display inferior izquierdo
            setTimeout(() => {
                updateNextCorredorDisplay();
            }, 100);
            
            console.log("Intervalos futuros actualizados:", appState.intervals);
        }

        function updateSingleIntervalForFuture(startFromCorredor, newSeconds) {
            console.log(`Actualizando modo single para futuros desde corredor ${startFromCorredor} a ${newSeconds}s`);
            
            if (appState.intervals.length === 0) {
                // No hay intervalos, crear dos: uno para el actual y otro para futuros
                appState.intervals.push({
                    from: 1,
                    to: startFromCorredor - 1,
                    minutes: Math.floor(appState.nextCorredorTime / 60),
                    seconds: appState.nextCorredorTime % 60,
                    totalSeconds: appState.nextCorredorTime
                });
                
                appState.intervals.push({
                    from: startFromCorredor,
                    to: 9999,
                    minutes: Math.floor(newSeconds / 60),
                    seconds: newSeconds % 60,
                    totalSeconds: newSeconds
                });
            } else if (appState.intervals.length === 1) {
                // Ya hay un intervalo único
                const currentInterval = appState.intervals[0];
                
                if (currentInterval.from < startFromCorredor) {
                    // El intervalo actual comienza antes, necesitamos dividirlo
                    const beforeInterval = {
                        from: currentInterval.from,
                        to: startFromCorredor - 1,
                        minutes: currentInterval.minutes,
                        seconds: currentInterval.seconds,
                        totalSeconds: currentInterval.totalSeconds
                    };
                    
                    const afterInterval = {
                        from: startFromCorredor,
                        to: 9999,
                        minutes: Math.floor(newSeconds / 60),
                        seconds: newSeconds % 60,
                        totalSeconds: newSeconds
                    };
                    
                    appState.intervals = [beforeInterval, afterInterval];
                } else {
                    // El intervalo ya comienza en el futuro, actualizarlo
                    appState.intervals[0] = {
                        from: startFromCorredor,
                        to: 9999,
                        minutes: Math.floor(newSeconds / 60),
                        seconds: newSeconds % 60,
                        totalSeconds: newSeconds
                    };
                }
            } else {
                // Ya hay múltiples intervalos (modo variable activado)
                // Encontrar y modificar los intervalos futuros
                for (let i = 0; i < appState.intervals.length; i++) {
                    const interval = appState.intervals[i];
                    
                    if (interval.from >= startFromCorredor) {
                        // Intervalo completamente futuro
                        appState.intervals[i] = {
                            from: interval.from,
                            to: interval.to,
                            minutes: Math.floor(newSeconds / 60),
                            seconds: newSeconds % 60,
                            totalSeconds: newSeconds
                        };
                    } else if (interval.to >= startFromCorredor) {
                        // Intervalo se solapa
                        const beforeInterval = {
                            from: interval.from,
                            to: startFromCorredor - 1,
                            minutes: interval.minutes,
                            seconds: interval.seconds,
                            totalSeconds: interval.totalSeconds
                        };
                        
                        const afterInterval = {
                            from: startFromCorredor,
                            to: interval.to,
                            minutes: Math.floor(newSeconds / 60),
                            seconds: newSeconds % 60,
                            totalSeconds: newSeconds
                        };
                        
                        // Reemplazar el intervalo original
                        appState.intervals.splice(i, 1, beforeInterval, afterInterval);
                        i++; // Saltar el intervalo añadido
                    }
                }
                
                // Ordenar y fusionar
                appState.intervals.sort((a, b) => a.from - b.from);
                
                const mergedIntervals = [];
                for (let i = 0; i < appState.intervals.length; i++) {
                    if (mergedIntervals.length === 0) {
                        mergedIntervals.push({...appState.intervals[i]});
                    } else {
                        const lastInterval = mergedIntervals[mergedIntervals.length - 1];
                        const currentInterval = appState.intervals[i];
                        
                        if (lastInterval.to + 1 === currentInterval.from && 
                            lastInterval.totalSeconds === currentInterval.totalSeconds) {
                            lastInterval.to = currentInterval.to;
                        } else {
                            mergedIntervals.push({...currentInterval});
                        }
                    }
                }
                
                appState.intervals = mergedIntervals;
            }
            
            // Guardar configuración single
            intervalConfig.singleMode = {
                minutes: Math.floor(newSeconds / 60),
                seconds: newSeconds % 60,
                saved: true
            };
            saveIntervalConfig();
            
            // Actualizar el display inferior izquierdo
            setTimeout(() => {
                updateNextCorredorDisplay();
            }, 100);
            
            console.log("Intervalos después de actualización single para futuros:", appState.intervals);
        }
            
        // ============================================
        // FUNCIONES DE CONFIGURACIÓN
        // ============================================

        function createNewRace() {
            const t = translations[appState.currentLanguage];
            
            const name = document.getElementById('new-race-name').value.trim();
            if (!name) {
                showMessage(t.enterRaceName, 'error');
                return;
            }
            
            const description = document.getElementById('new-race-description').value.trim();
            
            const newRace = {
                id: Date.now(),
                name: name,
                description: description,
                createdAt: new Date().toISOString(),
                lastModified: new Date().toISOString(),
                cadenceMode: 'single',
                departures: [],
                intervals: []
            };
            
            appState.races.push(newRace);
            appState.currentRace = newRace;
            
            appState.departureTimes = [];
            appState.departedCount = 0;
            appState.intervals = [];
            appState.isVariableMode = false;
            
            switchToSingleMode();
            
            document.getElementById('departed-count').textContent = 0;
            document.getElementById('start-position').value = 1;
            renderDeparturesList();
            
            saveRacesToStorage();
            renderRacesSelect();
            
            document.getElementById('new-race-modal').classList.remove('active');
            document.getElementById('new-race-name').value = '';
            document.getElementById('new-race-description').value = '';
            
            showMessage(t.raceCreated, 'success');
            
            console.log("Nueva carrera creada:", name, "Modo:", 'single');
        }
                
        function deleteCurrentRace() {
            if (!appState.currentRace) return;
            
            const raceIndex = appState.races.findIndex(r => r.id === appState.currentRace.id);
            if (raceIndex !== -1) {
                appState.races.splice(raceIndex, 1);
                appState.currentRace = null;
                
                if (appState.countdownActive) {
                    stopCountdown();
                    document.getElementById('countdown-screen').classList.remove('active');
                    document.querySelectorAll('.hide-on-countdown').forEach(el => {
                        el.style.display = '';
                    });
                }
                
                appState.departureTimes = [];
                appState.departedCount = 0;
                appState.intervals = [];
                appState.isVariableMode = false;
                
                document.getElementById('start-position').value = 1;
                document.getElementById('departed-count').textContent = 0;
                
                document.getElementById('single-interval-config').style.display = 'block';
                document.getElementById('variable-interval-config').style.display = 'none';
                document.getElementById('same-interval-btn').classList.add('active');
                document.getElementById('variable-interval-btn').classList.remove('active');
                
                saveRacesToStorage();
                renderRacesSelect();
                renderDeparturesList();
                
                document.getElementById('delete-race-modal').classList.remove('active');
                
                showMessage(translations[appState.currentLanguage].raceDeleted, 'success');
            }
        }    
                
        function addVariableInterval() {
            const t = translations[appState.currentLanguage];
            
            const from = parseInt(document.getElementById('from-corredor').value) || 1;
            const to = parseInt(document.getElementById('to-corredor').value) || 10;
            const minutes = parseInt(document.getElementById('var-minutes').value) || 0;
            const seconds = parseInt(document.getElementById('var-seconds').value) || 0;
            
            if (from > to) {
                showMessage(t.fromMustBeLessThanTo, 'error');
                return;
            }
            
            if (minutes === 0 && seconds === 0) {
                showMessage(t.enterValidTimeValue, 'error');
                return;
            }
            
            for (const interval of appState.intervals) {
                if ((from >= interval.from && from <= interval.to) ||
                    (to >= interval.from && to <= interval.to) ||
                    (from <= interval.from && to >= interval.to)) {
                    showMessage(`${t.intervalOverlaps} ${interval.from}-${interval.to}`, 'error');
                    return;
                }
            }
            
            const totalSeconds = minutes * 60 + seconds;
            
            const newInterval = {
                from: from,
                to: to,
                minutes: minutes,
                seconds: seconds,
                totalSeconds: totalSeconds
            };
            
            appState.intervals.push(newInterval);
            
            appState.intervals.sort((a, b) => a.from - b.from);
            
            renderIntervalsList();
            
            if (appState.currentRace) {
                appState.currentRace.cadenceMode = 'variable';
                appState.currentRace.intervals = [...appState.intervals];
                saveRaceData();
            }
            
            intervalConfig.variableMode = {
                intervals: [...appState.intervals],
                saved: true
            };
            saveIntervalConfig();
            
            document.getElementById('from-corredor').value = to + 1;
            document.getElementById('to-corredor').value = to + 10;
            document.getElementById('var-minutes').value = 1;
            document.getElementById('var-seconds').value = 0;

            // Refrescar botones
            setTimeout(() => {
                refreshIntervalButtons();
            }, 100);
            
            showMessage(t.intervalAdded, 'success');
        }

        function renderIntervalsList() {
            const container = document.getElementById('intervals-list');
            container.innerHTML = '';
            
            const sortedIntervals = [...appState.intervals].sort((a, b) => a.from - b.from);
            
            sortedIntervals.forEach((interval, index) => {
                const row = document.createElement('div');
                row.className = 'interval-row';
                row.setAttribute('data-index', index);
                row.innerHTML = `
                    <div class="interval-info">
                        <div class="interval-range">
                            <strong>${interval.from} - ${interval.to}</strong>
                        </div>
                        <div class="interval-time">
                            <i class="fas fa-clock"></i> 
                            ${interval.minutes}min ${interval.seconds.toString().padStart(2, '0')}s
                        </div>
                    </div>
                    <div class="interval-actions">
                        <button class="btn btn-secondary btn-sm edit-interval-btn" 
                                data-index="${index}" 
                                title="Editar este tramo"
                                onclick="event.stopPropagation();">
                            <i class="fas fa-edit"></i>
                            <span class="btn-text">Editar</span>
                        </button>
                        <button class="btn btn-danger btn-sm remove-interval-btn" 
                                data-index="${index}" 
                                title="Eliminar este tramo"
                                onclick="event.stopPropagation();">
                            <i class="fas fa-trash"></i>
                            <span class="btn-text">Eliminar</span>
                        </button>
                    </div>
                `;
                updateIntervalCount();
    
                // Refrescar botones después de renderizar
                setTimeout(() => {
                    refreshIntervalButtons();
                }, 100);
                container.appendChild(row);
            });
            
            if (appState.intervals.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'empty-state';
                emptyMessage.innerHTML = `
                    <i class="fas fa-plus-circle" style="font-size: 2rem; color: var(--gray); margin-bottom: 10px;"></i>
                    <p style="color: var(--gray); font-style: italic;">
                        No hay tramos configurados. Añade el primer tramo usando el formulario superior.
                    </p>
                `;
                container.appendChild(emptyMessage);
            }
            
            updateIntervalCount();
        }    


        function setupEditIntervalModalEvents() {
            console.log("Configurando eventos del modal de edición...");
            
            document.addEventListener('click', function(e) {
                if (e.target && e.target.id === 'save-edit-interval-btn') {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log("Botón Guardar Cambios clickeado");
                    saveEditedInterval();
                }
                
                if (e.target && e.target.id === 'cancel-edit-interval-btn') {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log("Botón Cancelar clickeado");
                    cancelEditInterval();
                }
                
                if (e.target && e.target.id === 'edit-interval-modal-close') {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log("Botón Cerrar modal clickeado");
                    cancelEditInterval();
                }
            });
            
            document.getElementById('edit-interval-modal').addEventListener('click', (e) => {
                if (e.target === document.getElementById('edit-interval-modal')) {
                    cancelEditInterval();
                }
            });
            
            document.getElementById('edit-interval-form').addEventListener('click', (e) => {
                e.stopPropagation();
            });
            
            document.getElementById('edit-interval-form').addEventListener('submit', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log("Formulario de edición enviado");
                saveEditedInterval();
            });
            
            const saveBtn = document.getElementById('save-edit-interval-btn');
            const cancelBtn = document.getElementById('cancel-edit-interval-btn');
            const closeBtn = document.getElementById('edit-interval-modal-close');
            
            if (saveBtn) {
                saveBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    saveEditedInterval();
                });
            }
            
            if (cancelBtn) {
                cancelBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    cancelEditInterval();
                });
            }
            
            if (closeBtn) {
                closeBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    cancelEditInterval();
                });
            }
        }

        function setupIntervalsEvents() {
            console.log("Configurando eventos de intervalos...");
            
            // Delegación de eventos más segura con verificación específica
            document.addEventListener('click', function(e) {
                // Verificar primero si estamos en el contenedor de notas
                const isInNotesContainer = e.target.closest('.notes-edit-container');
                const isNotesButton = e.target.closest('.save-notes-btn') || e.target.closest('.cancel-notes-btn');
                const isNotesInput = e.target.closest('.departure-notes-input');
                
                // Si estamos en el área de notas, NO procesar eventos de intervalos
                if (isInNotesContainer || isNotesButton || isNotesInput) {
                    console.log("Evento en área de notas - ignorando eventos de intervalos");
                    return;
                }
                
                // Verificar si es botón de eliminar intervalo
                const deleteButton = e.target.closest('.remove-interval-btn');
                if (deleteButton) {
                    console.log("Botón ELIMINAR detectado (después de verificación de notas)");
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const index = parseInt(deleteButton.getAttribute('data-index'));
                    console.log("Índice del intervalo a eliminar:", index);
                    
                    if (!isNaN(index) && index >= 0 && index < appState.intervals.length) {
                        console.log("Procesando eliminación para índice:", index);
                        
                        const interval = appState.intervals[index];
                        const t = translations[appState.currentLanguage];
                        const confirmMessage = t.confirmDeleteInterval.replace('{from}', interval.from).replace('{to}', interval.to);
                        
                        if (confirm(confirmMessage)) {
                            appState.intervals.splice(index, 1);
                            
                            renderIntervalsList();
                            
                            intervalConfig.variableMode = {
                                intervals: [...appState.intervals],
                                saved: true
                            };
                            saveIntervalConfig();
                            
                            if (appState.currentRace) {
                                appState.currentRace.intervals = [...appState.intervals];
                                saveRaceData();
                            }
                            
                            if (appState.countdownActive) {
                                updateCurrentInterval();
                                saveAppState();
                            }
                            
                            showMessage(t.intervalDeleted, 'success');
                            console.log("Intervalo eliminado. Total restante:", appState.intervals.length);
                        }
                    } else {
                        console.error("Índice inválido:", index);
                    }
                    return false;
                }
                
                // Verificar si es botón de editar
                const editButton = e.target.closest('.edit-interval-btn');
                if (editButton) {
                    console.log("Botón EDITAR detectado (después de verificación de notas)");
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const index = parseInt(editButton.getAttribute('data-index'));
                    console.log("Índice del intervalo a editar:", index);
                    
                    if (!isNaN(index) && index >= 0 && index < appState.intervals.length) {
                        console.log("Abriendo modal para editar intervalo:", index);
                        openEditIntervalModal(index);
                    } else {
                        console.error("Índice inválido para editar:", index);
                    }
                    return false;
                }
            });
            
            // Doble clic en la fila para editar (solo si no es en notas)
            document.addEventListener('dblclick', function(e) {
                // Verificar si estamos en el área de notas
                const isInNotesContainer = e.target.closest('.notes-edit-container');
                const isNotesButton = e.target.closest('.save-notes-btn') || e.target.closest('.cancel-notes-btn');
                const isNotesInput = e.target.closest('.departure-notes-input');
                
                if (isInNotesContainer || isNotesButton || isNotesInput) {
                    console.log("Doble clic en área de notas - ignorando");
                    return;
                }
                
                const row = e.target.closest('.interval-row');
                if (row && !e.target.closest('button')) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const index = parseInt(row.getAttribute('data-index'));
                    
                    if (!isNaN(index) && index >= 0 && index < appState.intervals.length) {
                        console.log("DOBLE CLIC en fila para editar intervalo:", index);
                        openEditIntervalModal(index);
                    }
                }
            });
            
            console.log("Eventos de intervalos configurados correctamente");
        }        

        function updateIntervalCount() {
            const count = appState.intervals.length;
            console.log("Total de intervalos configurados:", count);
        }

        function sendSuggestion() {
            const t = translations[appState.currentLanguage];
            
            const email = document.getElementById('suggestion-email').value.trim();
            const text = document.getElementById('suggestion-text').value.trim();
            
            if (!text) {
                showMessage(t.suggestionTextLabel, 'error');
                return;
            }
            
            console.log('Sugerencia enviada:', { email, text });
            
            document.getElementById('suggestions-modal').classList.remove('active');
            document.getElementById('suggestion-email').value = '';
            document.getElementById('suggestion-text').value = '';
            
            showMessage(t.suggestionSent, 'success');
        }

        // ============================================
        // UTILIDADES
        // ============================================

        function showMessage(text, type = 'info') {
            const messageDiv = document.getElementById('message');
            messageDiv.textContent = text;
            messageDiv.className = `message ${type}`;
            messageDiv.style.display = 'block';
            
            setTimeout(() => {
                messageDiv.style.display = 'none';
            }, 3000);
        }

        function saveLastUpdate() {
            localStorage.setItem('countdown-last-update', Date.now().toString());
        }

        // ============================================
        // CONFIGURACIÓN MEJORADA DE INTERVALOS
        // ============================================

        const intervalConfig = {
            singleMode: {
                minutes: 1,
                seconds: 0,
                saved: false
            },
            variableMode: {
                intervals: [],
                saved: false
            }
        };

        function loadIntervalConfig() {
            const savedConfig = localStorage.getItem('countdown-interval-config');
            
            if (savedConfig) {
                try {
                    const config = JSON.parse(savedConfig);
                    
                    if (config.singleMode) {
                        intervalConfig.singleMode = config.singleMode;
                    }
                    
                    if (config.variableMode) {
                        intervalConfig.variableMode = config.variableMode;
                    }
                } catch (e) {
                    console.error("Error cargando configuración:", e);
                }
            }
        }

        function saveIntervalConfig() {
            localStorage.setItem('countdown-interval-config', JSON.stringify(intervalConfig));
        }

        function switchToSingleMode() {
            if (document.getElementById('variable-interval-config').style.display !== 'none') {
                if (appState.currentRace) {
                    appState.currentRace.intervals = [...appState.intervals];
                    appState.currentRace.cadenceMode = 'variable';
                    saveRaceData();
                }
                
                intervalConfig.variableMode = {
                    intervals: [...appState.intervals],
                    saved: true
                };
                saveIntervalConfig();
            }
            
            document.getElementById('interval-minutes').value = intervalConfig.singleMode.minutes;
            document.getElementById('interval-seconds').value = intervalConfig.singleMode.seconds;
            
            document.getElementById('single-interval-config').style.display = 'block';
            document.getElementById('variable-interval-config').style.display = 'none';
            
            document.getElementById('same-interval-btn').classList.add('active');
            document.getElementById('variable-interval-btn').classList.remove('active');
            
            const totalSeconds = intervalConfig.singleMode.minutes * 60 + intervalConfig.singleMode.seconds;
            
            appState.isVariableMode = false;
            
            if (appState.currentRace) {
                appState.currentRace.cadenceMode = 'single';
                if (appState.intervals.length > 0) {
                    appState.currentRace.intervals = [...appState.intervals];
                } else {
                    appState.currentRace.intervals = [];
                }
                saveRaceData();
            }
            
            appState.nextCorredorTime = totalSeconds;
            updateNextCorredorDisplay();
            
            console.log("Modo single activado. Intervalos:", appState.intervals.length);
        }

        function switchToVariableMode() {
            const currentMinutes = parseInt(document.getElementById('interval-minutes').value) || 0;
            const currentSeconds = parseInt(document.getElementById('interval-seconds').value) || 0;
            
            intervalConfig.singleMode = {
                minutes: currentMinutes,
                seconds: currentSeconds,
                saved: true
            };
            saveIntervalConfig();
            
            document.getElementById('single-interval-config').style.display = 'none';
            document.getElementById('variable-interval-config').style.display = 'block';
            
            document.getElementById('same-interval-btn').classList.remove('active');
            document.getElementById('variable-interval-btn').classList.add('active');
            
            appState.isVariableMode = true;
            
            if (appState.currentRace && appState.currentRace.intervals && appState.currentRace.intervals.length > 0) {
                appState.intervals = [...appState.currentRace.intervals];
                renderIntervalsList();
            } else if (intervalConfig.variableMode.saved && intervalConfig.variableMode.intervals.length > 0) {
                appState.intervals = [...intervalConfig.variableMode.intervals];
                renderIntervalsList();
                
                if (appState.currentRace) {
                    appState.currentRace.cadenceMode = 'variable';
                    appState.currentRace.intervals = [...appState.intervals];
                    saveRaceData();
                }
            } else {
                appState.intervals = [];
                renderIntervalsList();
            }
            
            console.log("Modo variable activado. Intervalos:", appState.intervals.length);
        }   
        
        function setupEditIntervalModalEvents() {
            console.log("Configurando eventos del modal de edición...");
            
            document.addEventListener('click', function(e) {
                if (e.target && e.target.id === 'save-edit-interval-btn') {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log("Botón Guardar Cambios clickeado");
                    saveEditedInterval();
                }
                
                if (e.target && e.target.id === 'cancel-edit-interval-btn') {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log("Botón Cancelar clickeado");
                    cancelEditInterval();
                }
                
                if (e.target && e.target.id === 'edit-interval-modal-close') {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log("Botón Cerrar modal clickeado");
                    cancelEditInterval();
                }
            });
            
            document.getElementById('edit-interval-modal').addEventListener('click', (e) => {
                if (e.target === document.getElementById('edit-interval-modal')) {
                    cancelEditInterval();
                }
            });
            
            document.getElementById('edit-interval-form').addEventListener('click', (e) => {
                e.stopPropagation();
            });
            
            document.querySelectorAll('.edit-interval-input').forEach(input => {
                input.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            });
            
            document.getElementById('edit-interval-form').addEventListener('submit', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log("Formulario de edición enviado");
                saveEditedInterval();
            });
            
            const saveBtn = document.getElementById('save-edit-interval-btn');
            const cancelBtn = document.getElementById('cancel-edit-interval-btn');
            const closeBtn = document.getElementById('edit-interval-modal-close');
            
            if (saveBtn) {
                saveBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    saveEditedInterval();
                });
            }
            
            if (cancelBtn) {
                cancelBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    cancelEditInterval();
                });
            }
            
            if (closeBtn) {
                closeBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    cancelEditInterval();
                });
            }
        }

        // ============================================
        // EVENT LISTENERS - FUNCIÓN CORREGIDA
        // ============================================

        function setupEventListeners() {
            console.log("Configurando event listeners...");
            
            document.querySelectorAll('.flag').forEach(flag => {
                flag.addEventListener('click', function() {
                    const lang = this.getAttribute('data-lang');
                    appState.currentLanguage = lang;
                    localStorage.setItem('countdown-language', lang);
                    updateLanguageUI();      // Actualiza toda la interfaz
                    updateSalidaText();      // Actualiza específicamente el texto "SALIDA"
                    console.log(`Idioma cambiado a: ${lang}`);
                });
            });
            document.getElementById('exit-complete-btn').addEventListener('click', () => {
                document.getElementById('restart-confirm-modal').classList.add('active');
            });

            document.getElementById('restart-modal-close').addEventListener('click', () => {
                document.getElementById('restart-confirm-modal').classList.remove('active');
            });

            document.getElementById('restart-cancel-btn').addEventListener('click', () => {
                document.getElementById('restart-confirm-modal').classList.remove('active');
            });

            // En setupEventListeners(), modificar el evento del botón de reinicio:
            document.getElementById('restart-confirm-btn').addEventListener('click', () => {
                const t = translations[appState.currentLanguage];
                
                if (appState.countdownActive) {
                    stopCountdown();
                    document.getElementById('countdown-screen').classList.remove('active');
                    document.querySelectorAll('.hide-on-countdown').forEach(el => {
                        el.style.display = '';
                    });
                }
                
                // RESET COMPLETO - AÑADIR ESTAS LÍNEAS:
                appState.departedCount = 0;
                appState.departureTimes = [];
                
                if (appState.currentRace) {
                    appState.currentRace.departures = [];
                    saveRaceData();
                }
                
                appState.nextCorredorTime = 60;
                appState.currentIntervalIndex = 0;
                appState.accumulatedTime = 0;
                appState.raceStartTime = null;
                appState.countdownActive = false;
                appState.countdownPaused = false;
                
                document.getElementById('departed-count').textContent = '0';
                document.getElementById('start-position').value = 1;
                updateNextCorredorDisplay();
                
                renderDeparturesList(); // Esto mostrará la lista vacía
                document.getElementById('total-time-value').textContent = '00:00:00';
                
                localStorage.removeItem('countdown-app-state');
                
                document.getElementById('restart-confirm-modal').classList.remove('active');
                
                showMessage(t.sessionRestarted, 'success');
                console.log("Sesión reiniciada, TODOS los datos borrados");
            });


            document.getElementById('help-icon-header').addEventListener('click', function() {
                window.open('Crono_cuenta_atras_ayuda.html', '_blank');
            });

            document.getElementById('footer-help-btn').addEventListener('click', function() {
                window.open('Crono_cuenta_atras_ayuda.html', '_blank');
            });
            
            document.getElementById('help-modal-close').addEventListener('click', () => {
                document.getElementById('help-modal').classList.remove('active');
            });
            
            document.getElementById('help-modal-ok').addEventListener('click', () => {
                document.getElementById('help-modal').classList.remove('active');
            });
            
            document.getElementById('delete-race-modal-close').addEventListener('click', () => {
                document.getElementById('delete-race-modal').classList.remove('active');
            });
            
            document.getElementById('delete-race-cancel-btn').addEventListener('click', () => {
                document.getElementById('delete-race-modal').classList.remove('active');
            });
            
            document.getElementById('clear-departures-modal-close').addEventListener('click', () => {
                document.getElementById('clear-departures-modal').classList.remove('active');
            });
            
            document.getElementById('clear-departures-cancel-btn').addEventListener('click', () => {
                document.getElementById('clear-departures-modal').classList.remove('active');
            });
            
            document.getElementById('suggestions-modal-close').addEventListener('click', () => {
                document.getElementById('suggestions-modal').classList.remove('active');
            });
            
            document.getElementById('cancel-suggestion-btn').addEventListener('click', () => {
                document.getElementById('suggestions-modal').classList.remove('active');
            });
            
            document.getElementById('new-race-modal-close').addEventListener('click', () => {
                document.getElementById('new-race-modal').classList.remove('active');
            });
            
            document.getElementById('cancel-create-race-btn').addEventListener('click', () => {
                document.getElementById('new-race-modal').classList.remove('active');
            });
            
            document.getElementById('config-during-countdown-close').addEventListener('click', () => {
                document.getElementById('config-during-countdown-modal').classList.remove('active');
                resumeCountdownVisual();
            });
            
            document.getElementById('resume-countdown-btn').addEventListener('click', () => {
                document.getElementById('config-during-countdown-modal').classList.remove('active');
                resumeCountdownVisual();
            });
            
            document.getElementById('stop-countdown-btn').addEventListener('click', () => {
                const t = translations[appState.currentLanguage];
                stopCountdown();
                document.getElementById('countdown-screen').classList.remove('active');
                document.querySelectorAll('.hide-on-countdown').forEach(el => {
                    el.style.display = '';
                });
                document.getElementById('config-during-countdown-modal').classList.remove('active');
                showMessage(t.countdownStopped, 'info');
            });
            
            document.getElementById('adjust-times-btn').addEventListener('click', () => {
                document.getElementById('config-during-countdown-modal').classList.remove('active');
                document.getElementById('adjust-times-modal').classList.add('active');
                
                document.getElementById('adjust-next-time').value = appState.nextCorredorTime;
                document.getElementById('adjust-departed').value = appState.departedCount;
                // Eliminar esta línea:
                // document.getElementById('adjust-current-time').value = appState.countdownValue;
            });

            document.getElementById('adjust-times-close').addEventListener('click', () => {
                document.getElementById('adjust-times-modal').classList.remove('active');
                resumeCountdownVisual();
            });
            
            document.getElementById('cancel-adjustments-btn').addEventListener('click', () => {
                document.getElementById('adjust-times-modal').classList.remove('active');
                resumeCountdownVisual();
            });
            
            document.getElementById('save-adjustments-btn').addEventListener('click', () => {
                const t = translations[appState.currentLanguage];
                
                const newNextTime = parseInt(document.getElementById('adjust-next-time').value) || 60;
                const newDeparted = parseInt(document.getElementById('adjust-departed').value) || 0;
                
                if (newNextTime <= 0 || newDeparted < 0) {
                    showMessage(t.invalidValues, 'error');
                    return;
                }
                
                // Solo cambiar el tiempo para futuros corredores
                // El tiempo actual NO se modifica
                appState.departedCount = newDeparted;
                
                // Aplicar nuevo tiempo desde el SIGUIENTE corredor
                const currentCorredor = appState.departedCount + 1; // Corredor actual en cuenta atrás
                const startFromCorredor = currentCorredor + 1; // Aplicar desde el siguiente
                
                if (appState.isVariableMode) {
                    updateFutureIntervals(startFromCorredor, newNextTime);
                } else {
                    updateSingleIntervalForFuture(startFromCorredor, newNextTime);
                }
                
                document.getElementById('start-position').value = newDeparted + 1;
                
                // ACTUALIZAR EL DISPLAY INFERIOR IZQUIERDO (Próximo sale a)
                const displayElement = document.getElementById('next-corredor-time');
                if (displayElement) {
                    if (newNextTime >= 60) {
                        const minutes = Math.floor(newNextTime / 60);
                        const seconds = newNextTime % 60;
                        displayElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    } else {
                        displayElement.textContent = newNextTime + "s";
                    }
                }
                
                updateCurrentInterval(); // Actualizar el intervalo actual
                updateNextCorredorDisplay();
                document.getElementById('departed-count').textContent = newDeparted;
                updateCountdownDisplay();
                
                document.getElementById('adjust-times-modal').classList.remove('active');
                resumeCountdownVisual();
                saveAppState();
                
                const message = t.adjustmentsSaved
                    .replace('{seconds}', newNextTime)
                    .replace('{corredor}', startFromCorredor);
                showMessage(message, 'success');
            });

            document.querySelectorAll('.modal').forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.classList.remove('active');
                        if (modal.id === 'config-during-countdown-modal' || 
                            modal.id === 'adjust-times-modal') {
                            resumeCountdownVisual();
                        }
                    }
                });
            });
            
            document.getElementById('race-select').addEventListener('change', function() {
                const index = parseInt(this.value);
                if (index >= 0 && index < appState.races.length) {
                    if (appState.currentRace) {
                        saveRaceData();
                    }
                    
                    appState.currentRace = appState.races[index];
                    
                    loadRaceData();
                    
                    saveRacesToStorage();
                    
                    console.log("Cambiada a carrera:", appState.currentRace.name);
                    console.log("Modo:", appState.currentRace.cadenceMode || 'single');
                    console.log("Salidas:", appState.departureTimes.length);
                    console.log("Intervalos:", appState.intervals.length);
                } else {
                    appState.currentRace = null;
                    appState.departureTimes = [];
                    appState.departedCount = 0;
                    appState.intervals = [];
                    appState.isVariableMode = false;
                    
                    document.getElementById('departed-count').textContent = 0;
                    document.getElementById('start-position').value = 1;
                    renderDeparturesList();
                    
                    document.getElementById('single-interval-config').style.display = 'block';
                    document.getElementById('variable-interval-config').style.display = 'none';
                    document.getElementById('same-interval-btn').classList.add('active');
                    document.getElementById('variable-interval-btn').classList.remove('active');
                }
            });          
            document.getElementById('new-race-btn').addEventListener('click', () => {
                document.getElementById('new-race-modal').classList.add('active');
                document.getElementById('new-race-name').focus();
            });
            
            document.getElementById('create-race-btn').addEventListener('click', createNewRace);
            
            document.getElementById('delete-race-btn').addEventListener('click', () => {
                const t = translations[appState.currentLanguage];
                if (!appState.currentRace) {
                    showMessage(t.selectRaceFirst, 'error');
                    return;
                }
                document.getElementById('delete-race-modal').classList.add('active');
            });
            
            document.getElementById('delete-race-confirm-btn').addEventListener('click', () => {
                deleteCurrentRace();
            });

            document.getElementById('same-interval-btn').addEventListener('click', function() {
                switchToSingleMode();
                if (appState.currentRace) {
                    saveRaceData();
                }
            });
            document.getElementById('variable-interval-btn').addEventListener('click', function() {
                switchToVariableMode();
                if (appState.currentRace) {
                    saveRaceData();
                }
            });
            document.getElementById('add-interval-btn').addEventListener('click', addVariableInterval);
            
            document.getElementById('start-position').addEventListener('change', function() {
                const position = parseInt(this.value) || 1;
                appState.departedCount = Math.max(0, position - 1);
                document.getElementById('departed-count').textContent = appState.departedCount;
                updateCurrentInterval();
                saveAppState();
                console.log("Posición actualizada:", position, "Salidos:", appState.departedCount);
            });
            
            document.getElementById('start-position').addEventListener('blur', function() {
                const position = parseInt(this.value) || 1;
                appState.departedCount = Math.max(0, position - 1);
                document.getElementById('departed-count').textContent = appState.departedCount;
                updateCurrentInterval();
                saveAppState();
            });
            
            document.getElementById('clear-departures-btn').addEventListener('click', () => {
                const t = translations[appState.currentLanguage];
                if (appState.departureTimes.length === 0) {
                    showMessage(t.listAlreadyEmpty, 'info');
                    return;
                }
                document.getElementById('clear-departures-modal').classList.add('active');
            });
            
            document.getElementById('clear-departures-confirm-btn').addEventListener('click', () => {
                clearRaceDepartures();
                document.getElementById('clear-departures-modal').classList.remove('active');
            });
            
            document.getElementById('export-excel-btn').addEventListener('click', exportToExcel);
            
            document.getElementById('start-countdown-btn').addEventListener('click', startCountdown);
            
            document.getElementById('config-toggle').addEventListener('click', function(e) {
                e.stopPropagation();
                
                const t = translations[appState.currentLanguage];
                
                // VALIDACIÓN AÑADIDA:
                if (appState.countdownActive && appState.countdownValue <= 12) {
                    showMessage(t.waitCountdownEnd, 'warning');
                    return;
                }
                
                if (appState.countdownActive && !appState.configModalOpen) {
                    pauseCountdownVisual();
                    document.getElementById('config-during-countdown-modal').classList.add('active');
                }
            });

            document.getElementById('config-toggle').addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                if (appState.countdownActive && !appState.configModalOpen) {
                    pauseCountdownVisual();
                    document.getElementById('config-during-countdown-modal').classList.add('active');
                }
            });


            document.getElementById('next-corredor-time').addEventListener('dblclick', function(e) {
                e.stopPropagation();

                if (!canModifyDuringCountdown()) {
                    return;
                }

                const t = translations[appState.currentLanguage];

                // Si la cuenta atrás no está activa, no permitir editar
                if (!appState.countdownActive) {
                    showMessage(t.countdownNotActive, 'warning');
                    return;
                }
                
                const currentText = this.textContent;
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'inline-edit-input';
                input.value = currentText;
                input.placeholder = 'Ej: 1:30 o 90';
                
                this.innerHTML = '';
                this.appendChild(input);
                input.focus();
                input.select();
                
                const finishEdit = () => {
                    const value = input.value.trim();
                    let seconds = 0;
                    
                    // Parsear el valor ingresado
                    if (value.includes(':')) {
                        const parts = value.split(':');
                        const mins = parseInt(parts[0]) || 0;
                        const secs = parseInt(parts[1]) || 0;
                        seconds = mins * 60 + secs;
                    } else if (value.toLowerCase().includes('min')) {
                        const mins = parseInt(value) || 0;
                        seconds = mins * 60;
                    } else {
                        seconds = parseInt(value) || 0;
                    }
                    
                    if (seconds <= 0) {
                        showMessage(t.enterValidTime, 'error');
                        this.textContent = currentText;
                        return;
                    }
                    
                    // CORRECCIÓN: NO modificar appState.nextCorredorTime directamente
                    // porque eso afectaría al corredor actual
                    
                    // El corredor actual es: departedCount + 1 (el que está en cuenta atrás)
                    const currentCorredor = appState.departedCount + 1;
                    
                    // El nuevo tiempo debe aplicarse desde el SIGUIENTE corredor
                    const startFromCorredor = currentCorredor + 1;
                    
                    console.log(`Corredor actual: ${currentCorredor}, Aplicar desde: ${startFromCorredor}`);
                    
                    // ACTUALIZAR INTERVALOS FUTUROS (NO el actual)
                    if (appState.isVariableMode) {
                        // En modo variable, modificar intervalos futuros
                        updateFutureIntervals(startFromCorredor, seconds);
                    } else {
                        // En modo single, crear un nuevo intervalo desde el siguiente corredor
                        updateSingleIntervalForFuture(startFromCorredor, seconds);
                    }
                    
                    // IMPORTANTE: NO cambiar appState.nextCorredorTime
                    // porque eso cambiaría el tiempo del corredor actual
                    
                    // Solo actualizar el display para mostrar el nuevo tiempo futuro
                    // Pero mantener el tiempo actual intacto
                    const displayText = seconds >= 60 ? 
                        `${Math.floor(seconds / 60)}:${(seconds % 60).toString().padStart(2, '0')}` : 
                        seconds + "s";
                    
                    this.textContent = displayText;
                    
                    // Guardar cambios
                    saveAppState();
                    if (appState.currentRace) {
                        saveRaceData();
                    }
                    
                    // Mostrar mensaje informativo
                    const message = t.timeUpdated
                        .replace('{seconds}', seconds)
                        .replace('{corredor}', startFromCorredor);
                    showMessage(message, 'success');
                };
                
                input.addEventListener('blur', finishEdit);
                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        finishEdit();
                    }
                });
            });
            
            
            document.getElementById('departed-count').addEventListener('dblclick', function(e) {
                e.stopPropagation();
                if (!canModifyDuringCountdown()) {
                    return;
                }
                
                const currentValue = parseInt(this.textContent) || 0;
                const input = document.createElement('input');
                input.type = 'number';
                input.className = 'inline-edit-input';
                input.value = currentValue;
                input.min = 0;
                
                this.innerHTML = '';
                this.appendChild(input);
                input.focus();
                input.select();
                
                const finishEdit = () => {
                    const newValue = parseInt(input.value) || 0;
                    appState.departedCount = newValue;
                    document.getElementById('start-position').value = newValue + 1;
                    this.textContent = newValue;
                    updateCurrentInterval();
                    saveAppState();
                    renderDeparturesList();
                };
                
                input.addEventListener('blur', finishEdit);
                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        finishEdit();
                    }
                });
            });
            
            document.getElementById('suggestions-btn').addEventListener('click', () => {
                document.getElementById('suggestions-modal').classList.add('active');
                document.getElementById('suggestion-text').focus();
            });
            
            document.getElementById('send-suggestion-btn').addEventListener('click', sendSuggestion);
            
            document.getElementById('install-btn').addEventListener('click', installPWA);
            
            document.getElementById('update-btn').addEventListener('click', () => {
                const t = translations[appState.currentLanguage];
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.ready.then(registration => {
                        registration.update();
                        showMessage(t.updateChecked, 'info');
                    });
                }
            });
            
            document.getElementById('interval-minutes').addEventListener('change', function() {
                intervalConfig.singleMode.minutes = parseInt(this.value) || 0;
                saveIntervalConfig();
                updateCadenceTime();
            });

            document.getElementById('interval-seconds').addEventListener('change', function() {
                intervalConfig.singleMode.seconds = parseInt(this.value) || 0;
                saveIntervalConfig();
                updateCadenceTime();
            });
            
            
            document.getElementById('adjust-next-time').addEventListener('click', function(e) {
                e.stopPropagation();
            });

            document.getElementById('adjust-departed').addEventListener('click', function(e) {
                e.stopPropagation();
            });

        }
                
        // ============================================
        // FUNCIONES DE MANTENIMIENTO DE PANTALLA
        // ============================================
        
        function setupServiceWorker() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('../unified-sw.js', {scope: '/Web/'})
                    .then(registration => {
                        console.log('ServiceWorker registrado:', registration.scope);
                        
                        setInterval(() => {
                            registration.update();
                        }, 60 * 60 * 1000);
                    })
                    .catch(error => {
                        console.log('Error registrando ServiceWorker:', error);
                    });
            }
        }

        function setupPWA() {
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                appState.deferredPrompt = e;
                
                const installBtn = document.getElementById('install-btn');
                installBtn.style.display = 'flex';
            });
        }

        function installPWA() {
            if (appState.deferredPrompt) {
                appState.deferredPrompt.prompt();
                appState.deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        showMessage('Aplicación instalada', 'success');
                    }
                    appState.deferredPrompt = null;
                });
            }
        }

        function keepScreenAwake() {
            if (!appState.countdownActive) return;
            
            if ('wakeLock' in navigator) {
                navigator.wakeLock.request('screen')
                    .then(wakeLock => {
                        console.log('Wake Lock activado');
                    })
                    .catch(err => {
                        console.log('Wake Lock no disponible:', err);
                    });
            }
            
            const video = document.getElementById('keep-alive-video');
            if (video) {
                video.loop = true;
                video.play().catch(e => console.log('Video keep-alive falló:', e));
            }
            
            if (navigator.vibrate) {
                navigator.vibrate(0);
            }
        }
        
        function adjustCountdownSize() {
            const display = document.getElementById('countdown-display');
            if (!display) return;
            
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const isAggressive = document.getElementById('countdown-screen').classList.contains('aggressive-numbers');
            
            let fontSize;
            const minDimension = Math.min(screenWidth, screenHeight);
            
            if (isAggressive) {
                if (minDimension < 400) {
                    fontSize = minDimension * 0.35;
                } else if (minDimension < 768) {
                    fontSize = minDimension * 0.30;
                } else if (minDimension < 1024) {
                    fontSize = minDimension * 0.25;
                } else {
                    fontSize = minDimension * 0.20;
                }
            } else {
                if (minDimension < 400) {
                    fontSize = minDimension * 0.30;
                } else if (minDimension < 768) {
                    fontSize = minDimension * 0.25;
                } else if (minDimension < 1024) {
                    fontSize = minDimension * 0.20;
                } else {
                    fontSize = minDimension * 0.15;
                }
            }
            
            fontSize = Math.max(80, Math.min(fontSize, 500));
            display.style.fontSize = `${fontSize}px`;
            display.style.lineHeight = `${fontSize * 0.9}px`;
        }
        
        function adjustInfoCornersSize() {
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const minDimension = Math.min(screenWidth, screenHeight);
            
            const infoCorners = document.querySelectorAll('.info-corner');
            infoCorners.forEach(corner => {
                if (minDimension < 400) {
                    corner.style.maxWidth = '40vw';
                } else if (minDimension < 768) {
                    corner.style.maxWidth = '35vw';
                } else if (minDimension < 1024) {
                    corner.style.maxWidth = '30vw';
                } else {
                    corner.style.maxWidth = '25vw';
                }
                
                if (minDimension < 400) {
                    corner.style.padding = '0.6vw 1vw';
                } else if (minDimension < 768) {
                    corner.style.padding = '0.7vw 1.1vw';
                } else {
                    corner.style.padding = '0.8vw 1.2vw';
                }
            });
        }

        function setupCountdownResize() {
            window.addEventListener('load', function() {
                adjustCountdownSize();
                adjustInfoCornersSize();
            });
            window.addEventListener('resize', function() {
                adjustCountdownSize();
                adjustInfoCornersSize();
            });
            window.addEventListener('orientationchange', function() {
                setTimeout(function() {
                    adjustCountdownSize();
                    adjustInfoCornersSize();
                }, 300);
            });
        }
        
        // ============================================
        // INICIALIZACIÓN
        // ============================================

        document.addEventListener('DOMContentLoaded', initApp);

        window.addEventListener('beforeunload', () => {
            if (appState.countdownActive) {
                saveLastUpdate();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && appState.countdownActive && !appState.configModalOpen) {
                pauseCountdownVisual();
                document.getElementById('config-during-countdown-modal').classList.add('active');
            }
            
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                document.getElementById('start-countdown-btn').click();
            }
        });

        // ============================================
        // FUNCIÓN PARA ACTUALIZAR HORA ACTUAL
        // ============================================
        function updateCurrentTime() {
            const now = new Date();
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const seconds = now.getSeconds().toString().padStart(2, '0');
            
            const display = document.getElementById('current-time-value');
            if (display) {
                display.textContent = `${hours}:${minutes}:${seconds}`;
            }
        }
        
        let editingIntervalIndex = -1;

        function openEditIntervalModal(index) {
            console.log("Abriendo modal de edición para índice:", index);
            
            const t = translations[appState.currentLanguage];
            
            if (index < 0 || index >= appState.intervals.length) {
                console.error("Índice inválido:", index);
                showMessage(t.noIntervalSelected, 'error');
                return;
            }
            
            const interval = appState.intervals[index];
            console.log("Intervalo a editar:", interval);
            
            editingIntervalIndex = index;
            
            document.getElementById('edit-from-corredor').value = interval.from;
            document.getElementById('edit-to-corredor').value = interval.to;
            document.getElementById('edit-interval-minutes').value = interval.minutes;
            document.getElementById('edit-interval-seconds').value = interval.seconds;
            
            document.getElementById('edit-interval-modal').classList.add('active');
            document.getElementById('edit-from-corredor').focus();
            
            console.log("Modal abierto correctamente");
        }

        function closeEditIntervalModal() {
            console.log("Cerrando modal de edición de intervalo");
            
            editingIntervalIndex = -1;
            
            document.getElementById('edit-from-corredor').value = '';
            document.getElementById('edit-to-corredor').value = '';
            document.getElementById('edit-interval-minutes').value = '';
            document.getElementById('edit-interval-seconds').value = '';
            
            document.getElementById('edit-interval-modal').classList.remove('active');
            
            console.log("Modal cerrado");
        }

        function saveEditedInterval() {
            console.log("saveEditedInterval iniciado, índice:", editingIntervalIndex);
            
            const t = translations[appState.currentLanguage];
            
            if (editingIntervalIndex < 0 || editingIntervalIndex >= appState.intervals.length) {
                console.error("No hay tramo seleccionado para editar");
                showMessage(t.noIntervalSelected, 'error');
                closeEditIntervalModal();
                return;
            }
            
            const from = parseInt(document.getElementById('edit-from-corredor').value) || 1;
            const to = parseInt(document.getElementById('edit-to-corredor').value) || 10;
            const minutes = parseInt(document.getElementById('edit-interval-minutes').value) || 0;
            const seconds = parseInt(document.getElementById('edit-interval-seconds').value) || 0;
            
            console.log("Valores del formulario:", {from, to, minutes, seconds});
            
            if (from > to) {
                showMessage(t.fromMustBeLessThanTo, 'error');
                return;
            }
            
            if (minutes === 0 && seconds === 0) {
                showMessage(t.enterValidTimeValue, 'error');
                return;
            }
            
            for (let i = 0; i < appState.intervals.length; i++) {
                if (i === editingIntervalIndex) continue;
                
                const interval = appState.intervals[i];
                if ((from >= interval.from && from <= interval.to) ||
                    (to >= interval.from && to <= interval.to) ||
                    (from <= interval.from && to >= interval.to)) {
                    showMessage(`${t.intervalOverlaps} ${interval.from}-${interval.to}`, 'error');
                    return;
                }
            }
            
            const totalSeconds = minutes * 60 + seconds;
            
            const updatedInterval = {
                from: from,
                to: to,
                minutes: minutes,
                seconds: seconds,
                totalSeconds: totalSeconds
            };
            
            console.log("Intervalo actualizado:", updatedInterval);
            
            appState.intervals[editingIntervalIndex] = updatedInterval;
            
            appState.intervals.sort((a, b) => a.from - b.from);
            
            const newIndex = appState.intervals.findIndex(interval => 
                interval.from === from && interval.to === to && interval.totalSeconds === totalSeconds
            );
            
            console.log("Nuevo índice después de ordenar:", newIndex);
            
            renderIntervalsList();
            
            intervalConfig.variableMode = {
                intervals: [...appState.intervals],
                saved: true
            };
            saveIntervalConfig();
            
            if (appState.currentRace) {
                appState.currentRace.intervals = [...appState.intervals];
                saveRaceData();
            }
            
            if (appState.countdownActive) {
                updateCurrentInterval();
                saveAppState();
            }
            
            closeEditIntervalModal();
            showMessage(t.intervalUpdated, 'success');
            console.log("Intervalo guardado correctamente");
        }
        
        function cancelEditInterval() {
            console.log("Cancelando edición de intervalo");
            closeEditIntervalModal();
        }

        updateCurrentTime();
    </script>

    <!-- Script para XLSX -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</body>
</html>